{
  "version": 3,
  "sources": ["../../src/cubing/search/inside/solve/puzzles/2x2x2.ts", "../../src/cubing/search/inside/solve/tremble.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/sgs-side-events/index.ts", "../../src/cubing/search/inside/solve/twsearch.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/4x4x4/index.ts", "../../src/cubing/search/inside/solve/puzzles/4x4x4.ts", "../../src/cubing/search/inside/solve/puzzles/big-cubes.ts", "../../src/cubing/search/inside/solve/puzzles/5x5x5.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/fto/index.ts", "../../src/cubing/search/inside/solve/puzzles/fto.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/kilominx/index.ts", "../../src/cubing/search/inside/solve/puzzles/kilominx.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/master_tetraminx/index.ts", "../../src/cubing/search/inside/solve/puzzles/master_tetraminx.ts", "../../src/cubing/search/inside/solve/puzzles/megaminx.ts", "../../src/cubing/search/inside/solve/puzzles/pyraminx.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/sgs-unofficial/index.ts", "../../src/cubing/search/inside/solve/puzzles/redi_cube.ts", "../../src/cubing/search/inside/solve/puzzles/skewb.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/sq1/index.ts", "../../src/cubing/search/inside/solve/puzzles/sq1.ts", "../../src/cubing/search/inside/api.ts"],
  "sourcesContent": ["import { Alg, Move } from \"../../../../alg\";\nimport type { KPuzzle } from \"../../../../kpuzzle\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { cube2x2x2, puzzles } from \"../../../../puzzles\";\nimport { randomPermuteInPlace, randomUIntBelow } from \"random-uint-below\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\nimport { solveTwsearch, twsearchPromise } from \"../twsearch\";\nimport { experimentalNormalize2x2x2Orientation } from \"../../../../puzzles/cubing-private\";\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgsCachedData: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedData222();\n      return new TrembleSolver(\n        await puzzles[\"2x2x2\"].kpuzzle(),\n        sgsCachedData,\n        \"URFLBD\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitialize222(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solve222HTMSubOptimal(\n  state: KState,\n  maxDepth: number = 11,\n): Promise<Alg> {\n  mustBeInsideWorker();\n  return await solveTwsearch(\n    (\n      await cube2x2x2.kpuzzle()\n    ).definition,\n    state.experimentalToTransformation()!.transformationData,\n    {\n      moveSubset: \"UFLR\".split(\"\"), // TODO: <U, F, R>\n      maxDepth,\n    },\n  );\n}\n\n// TODO: fix def consistency.\n// TODO: why is this ending up with the wrong rotation sometimes?\nexport async function solve222HTMOptimal(\n  state: KState,\n  maxDepth: number = 11,\n): Promise<Alg> {\n  mustBeInsideWorker();\n  const { normalizedState, normalizationAlg } =\n    experimentalNormalize2x2x2Orientation(state);\n  const orientedResult = await solveTwsearch(\n    (\n      await cube2x2x2.kpuzzle()\n    ).definition,\n    normalizedState.experimentalToTransformation()!.transformationData,\n    {\n      moveSubset: \"UFLR\".split(\"\"), // TODO: <U, F, R>\n      maxDepth,\n    },\n  );\n  return normalizationAlg.concat(orientedResult);\n}\n\nasync function hasHTMSolutionWithFewerMoves(\n  state: KState,\n  filterMin: number,\n): Promise<boolean> {\n  try {\n    (await solve222HTMOptimal(state, filterMin - 1)).log();\n    return true;\n  } catch (e) {\n    if (e instanceof (await twsearchPromise).NoSolutionError) {\n      return false;\n    }\n    throw e;\n  }\n}\n\nfunction isCancelling(alg: Alg): boolean {\n  let lastFamily: undefined | string;\n  for (const node of alg.childAlgNodes()) {\n    const move = node.as(Move);\n    if (!move) {\n      throw new Error(\"Unexpected solution with a non-move node!\");\n    }\n    const { family } = move;\n    if (\n      lastFamily &&\n      ((lastFamily === \"L\" && family === \"R\") ||\n        (lastFamily === \"R\" && family === \"L\"))\n    ) {\n      return true;\n    }\n    lastFamily = family;\n  }\n  return false;\n}\n\n// TODO: fix def consistency.\nexport async function solve222ForScramble(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  return solveTwsearch(\n    (await cube2x2x2.kpuzzle()).definition,\n    state.experimentalToTransformation()!.transformationData,\n    {\n      moveSubset: \"UFLR\".split(\"\"),\n      minDepth: 11,\n    },\n  );\n}\n\n// TODO: factor out and test.\nfunction mutatingRandomizeOrbit(\n  kpuzzle: KPuzzle,\n  orbitName: string,\n  state: KState,\n  options?: { orientationSum?: number },\n): void {\n  randomPermuteInPlace(state.stateData[orbitName].pieces);\n\n  const orbitDef = kpuzzle.definition.orbits[orbitName];\n  const ori = state.stateData[orbitName].orientation;\n\n  let sum = 0;\n  for (let i = 0; i < orbitDef.numPieces; i++) {\n    const o = randomUIntBelow(orbitDef.numOrientations);\n    ori[i] = o;\n    sum += o;\n  }\n\n  // console.log(\"aaaa\", options && \"orientationSum\" in options);\n  if (options && \"orientationSum\" in options) {\n    // console.log(\"sfdsf\", options!.orientationSum),\n    ori[0] =\n      (((ori[0] + options.orientationSum! - sum) % orbitDef.numOrientations) +\n        orbitDef.numOrientations) %\n      orbitDef.numOrientations;\n  }\n}\n\n// TODO: Use SGS?\nexport async function random222State(): Promise<KState> {\n  const kpuzzle = await puzzles[\"2x2x2\"].kpuzzle();\n  const stateCopy: KState = new KState(\n    kpuzzle,\n    JSON.parse(JSON.stringify(kpuzzle.startState().stateData)),\n  ); // TODO\n  mutatingRandomizeOrbit(kpuzzle, \"CORNERS\", stateCopy, {\n    orientationSum: 0,\n  });\n  return stateCopy;\n}\n\nexport async function random222Scramble(): Promise<Alg> {\n  let state = await random222State();\n  while (await hasHTMSolutionWithFewerMoves(state, 4)) {\n    console.info(\"Filtered out a 2x2x2 state!\");\n    state = await random222State();\n  }\n  const inverseState = state\n    .experimentalToTransformation()!\n    .invert()\n    .toKState(); // Note: Inversion is not needed for randomness, but it is more consistent with other code.\n  let sol = await solve222ForScramble(inverseState);\n  while (isCancelling(sol)) {\n    // Rely on `--randomstart` to find us a non-cancelling with \u22482/3 probability.\n    // TODO: Check that this works for 100% of states.\n    sol = await solve222ForScramble(inverseState);\n  }\n\n  return sol;\n}\n", "import { Alg, AlgBuilder, Move, QuantumMove } from \"../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../kpuzzle\";\nimport type { KState } from \"../../../kpuzzle/KState\";\nimport { experimentalCountMoves } from \"../../../notation\";\nimport { randomChoice } from \"random-uint-below\";\nimport type { SGSCachedData } from \"./parseSGS\";\n\nconst DEFAULT_STAGE1_DEPTH_LIMIT = 2; // Moderately performant default.\n\nconst DOUBLECHECK_PLACED_PIECES = true;\nconst DEBUG = false;\n\n// TODO: Take moves instead of move names?\nfunction calculateMoves(\n  kpuzzle: KPuzzle,\n  moveNames: string[],\n): {\n  move: Move;\n  transformation: KTransformation;\n}[] {\n  const searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[] = [];\n  // const identity = identityTransformation(def); // TODO\n  // TODO: Make it easy to filter moves.\n  moveNames.forEach(function (moveName) {\n    const rootMove = new Move(moveName);\n    if (rootMove.amount !== 1) {\n      throw new Error(\n        \"SGS cannot handle def moves with an amount other than 1 yet.\",\n      );\n    }\n    let transformation = kpuzzle.identityTransformation();\n    for (let i = 1; true; i++) {\n      transformation = transformation.applyMove(rootMove);\n      if (transformation.isIdentityTransformation()) {\n        break;\n      }\n      searchMoves.push({\n        move: rootMove.modified({ amount: i }),\n        transformation,\n      });\n    }\n  });\n  return searchMoves;\n}\n\n// function badRandomMoves(moves: string[], ksp: KSolvePuzzle): KSolvePuzzleState {\n//   // var sum = 0;\n//   var scramble = \"\";\n//   for (var i = 0; i < 1000; i++) {\n//     scramble = scramble + \" \" + moves[Math.floor(moves.length * Math.random())];\n//   }\n//   // var sol = \"\";\n//   const indexer = new TreeAlgIndexer(ksp, Alg.fromString(scramble));\n//   return indexer.transformAtIndex(indexer.numMoves()) as any; // TODO\n// }\n\nexport class TrembleSolver {\n  private searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[];\n\n  constructor(\n    private kpuzzle: KPuzzle,\n    private sgs: SGSCachedData,\n    trembleMoveNames?: string[],\n  ) {\n    this.searchMoves = calculateMoves(\n      this.kpuzzle,\n      trembleMoveNames ?? Object.keys(this.kpuzzle.definition.moves),\n    );\n  }\n\n  // public badRandomMoves(): KSolvePuzzleState {\n  //   return badRandomMoves(this.moves, this.ksp);\n  // }\n\n  public async solve(\n    state: KState,\n    stage1DepthLimit: number = DEFAULT_STAGE1_DEPTH_LIMIT,\n    quantumMoveOrder?: (quantumMove: QuantumMove) => number,\n  ): Promise<Alg> {\n    const transformation = state.experimentalToTransformation();\n    if (!transformation) {\n      throw new Error(\n        \"distinguishable pieces are not supported in tremble solver yt\",\n      );\n    }\n    let bestAlg: Alg | null = null;\n    let bestLen = 1000000;\n    const recur = (\n      recursiveTransformation: KTransformation, // TODO: Support KStatq1\n      togo: number,\n      sofar: Alg,\n    ) => {\n      // console.log(\"recur\");\n      if (togo === 0) {\n        const sgsAlg = this.sgsPhaseSolve(recursiveTransformation, bestLen);\n        if (!sgsAlg) {\n          return;\n        }\n        // console.log(\"sgs done!\", sofar.toString(), \"|\", sgsAlg.toString());\n        const newAlg = sofar.concat(sgsAlg).experimentalSimplify({\n          cancel: { puzzleSpecificModWrap: \"canonical-centered\" },\n          puzzleSpecificSimplifyOptions: { quantumMoveOrder },\n        });\n\n        const len = experimentalCountMoves(newAlg);\n        if (bestAlg === null || len < bestLen) {\n          if (DEBUG) {\n            console.log(`New best (${len} moves): ${newAlg.toString()}`);\n            console.log(`Tremble moves are: ${sofar.toString()}`);\n          }\n          bestAlg = newAlg;\n          bestLen = len;\n        }\n        return;\n      }\n      for (const searchMove of this.searchMoves) {\n        recur(\n          recursiveTransformation.applyTransformation(\n            searchMove.transformation,\n          ),\n          togo - 1,\n          sofar.concat([searchMove.move]),\n        );\n      }\n    };\n    for (let d = 0; d <= stage1DepthLimit; d++) {\n      recur(transformation, d, new Alg());\n    }\n    if (bestAlg === null) {\n      throw new Error(\"SGS search failed.\");\n    }\n    return bestAlg;\n  }\n\n  private sgsPhaseSolve(\n    initialTransformation: KTransformation, // TODO: Handle KState\n    bestLenSofar: number,\n  ): Alg | null {\n    // const pieceNames = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\n\n    // function loggo(s: string) {\n    //   // console.warn(s);\n    //   // document.body.appendChild(document.createElement(\"div\")).textContent = s;\n    // }\n\n    // console.log(\"sgsPhaseSolve\");\n    const algBuilder = new AlgBuilder();\n    let transformation = initialTransformation;\n    for (const step of this.sgs.ordering) {\n      const cubieSeq = step.pieceOrdering;\n      let key = \"\";\n      const inverseTransformation = transformation.invert();\n      for (let i = 0; i < cubieSeq.length; i++) {\n        const loc = cubieSeq[i];\n        const orbitName = loc.orbitName;\n        const idx = loc.permutationIdx;\n        key += ` ${inverseTransformation.transformationData[orbitName].permutation[idx]} ${inverseTransformation.transformationData[orbitName].orientation[idx]}`;\n      }\n      // console.log(key, step.lookup);\n      const info = step.lookup[key];\n      if (!info) {\n        throw new Error(\"Missing algorithm in sgs or esgs?\");\n      }\n      algBuilder.experimentalPushAlg(info.alg);\n      if (algBuilder.experimentalNumAlgNodes() >= bestLenSofar) {\n        return null;\n      }\n      transformation = transformation.applyTransformation(info.transformation);\n      if (DOUBLECHECK_PLACED_PIECES) {\n        for (let i = 0; i < cubieSeq.length; i++) {\n          const location = cubieSeq[i];\n          const orbitName = location.orbitName;\n          const idx = location.permutationIdx;\n          if (\n            transformation.transformationData[orbitName].permutation[idx] !==\n              idx ||\n            transformation.transformationData[orbitName].orientation[idx] !== 0\n          ) {\n            throw new Error(\"bad SGS :-(\");\n          }\n        }\n      }\n    }\n    return algBuilder.toAlg();\n  }\n}\n\nexport function randomStateFromSGS(\n  kpuzzle: KPuzzle,\n  sgs: SGSCachedData,\n): KState {\n  let transformation = kpuzzle.identityTransformation();\n  for (const step of sgs.ordering) {\n    const sgsAction = randomChoice(Object.values(step.lookup));\n    transformation = transformation.applyTransformation(\n      sgsAction.transformation,\n    );\n  }\n  return transformation.toKState();\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicSideEvents = from<\n  typeof import(\"./search-dynamic-sgs-side-events\")\n>(() => import(\"./search-dynamic-sgs-side-events\"));\n", "import type { Alg } from \"../../../alg\";\nimport {\n  KPuzzle,\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"../../../kpuzzle\";\nimport { from } from \"../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const twsearchPromise: Promise<\n  typeof import(\"../../../vendor/mpl/twsearch\")\n> = from(async () => import(\"../../../vendor/mpl/twsearch\"));\n\nexport interface TwsearchOptions {\n  moveSubset?: string[];\n  startState?: KTransformationData;\n  minDepth?: number;\n  maxDepth?: number;\n}\n\nlet existingPuzzleDefString: undefined | string;\nlet existingMoveSubsetString: undefined | string;\n\nfunction mustBeNaturalNumber(meaning: string, n: number): void {\n  if (typeof n !== \"number\" || !Number.isInteger(n) || n < 0) {\n    throw new Error(`Invalid ${meaning}: ${n}`);\n  }\n}\n\nexport async function solveTwsearch(\n  def: KPuzzleDefinition,\n  stateData: KTransformationData,\n  options?: TwsearchOptions,\n): Promise<Alg> {\n  const {\n    setArg,\n    setKPuzzleDefString,\n    serializeDefToTws,\n    solveState,\n    serializeKTransformationDataToTws,\n  } = await twsearchPromise;\n  const kpuzzle = new KPuzzle(def);\n  setArg(\"--startprunedepth 5\"); // TODO\n  let moveSubsetString = \"\"; // TODO: pass the full set of moves, to avoid rotations not being treated as moves.\n  if (options) {\n    if (options.moveSubset) {\n      moveSubsetString = options?.moveSubset?.join(\",\");\n      // TODO: better, reusable validation\n      if (moveSubsetString.includes(\" \")) {\n        throw new Error(\"A move contains a space\u203D\");\n      }\n      if (moveSubsetString.includes(\"-\")) {\n        throw new Error(\"A move contains a dash\");\n      }\n      setArg(`--moves ${moveSubsetString}`); // TODO: remove the need for this.\n    }\n    let { minDepth, maxDepth } = options;\n    if (typeof minDepth !== \"undefined\") {\n      mustBeNaturalNumber(\"minDepth\", minDepth);\n      if (typeof maxDepth !== \"undefined\") {\n        mustBeNaturalNumber(\"maxDepth\", maxDepth);\n      } else {\n        maxDepth = 1000000;\n      }\n\n      setArg(\"--randomstart\");\n      setArg(`--mindepth ${minDepth}`);\n      setArg(`--maxdepth ${maxDepth}`);\n    } else if (typeof maxDepth !== \"undefined\") {\n      mustBeNaturalNumber(\"maxDepth\", maxDepth);\n      setArg(\"--mindepth 0\");\n      setArg(`--maxdepth ${maxDepth}`);\n    }\n  }\n\n  const puzzleDefString = serializeDefToTws(kpuzzle, options);\n  if (existingPuzzleDefString) {\n    if (existingPuzzleDefString !== puzzleDefString) {\n      throw new Error(\n        \"Attempted to solve two puzzles in the same worker using `twsearch`. This is not currently supported!\",\n      );\n    }\n  } else {\n    existingPuzzleDefString = puzzleDefString;\n    await setKPuzzleDefString(puzzleDefString);\n  }\n\n  if (\n    typeof existingMoveSubsetString !== \"undefined\" &&\n    moveSubsetString !== existingMoveSubsetString\n  ) {\n    throw new Error(\n      \"Attempted to solve two different move subsets in the same worker using `twsearch`. This is not currently supported!\",\n    );\n  }\n\n  return await solveState(\n    serializeKTransformationDataToTws(\"SearchState\", stateData, true),\n  );\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamic4x4x4Solver = from<\n  typeof import(\"./search-dynamic-solve-4x4x4\")\n>(() => import(\"./search-dynamic-solve-4x4x4\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { dynamic4x4x4Solver } from \"./dynamic/4x4x4\";\n\nconst randomSuffixes = [\n  [null, \"x\", \"x2\", \"x'\", \"z\", \"z'\"],\n  [null, \"y\", \"y2\", \"y'\"],\n];\n\nexport async function initialize444(): Promise<void> {\n  return (await dynamic4x4x4Solver).initialize();\n}\n\nexport async function random444Scramble(): Promise<Alg> {\n  return (await dynamic4x4x4Solver).random444Scramble();\n}\n\nexport async function random444OrientedScramble(): Promise<Alg> {\n  return addOrientationSuffix(await random444Scramble(), randomSuffixes);\n}\n", "import { Alg, AlgBuilder, Move, QuantumMove } from \"../../../../alg\";\nimport { randomChoice, randomUIntBelow } from \"random-uint-below\";\n\nfunction numMoves(n: number): number {\n  switch (n) {\n    case 5:\n      return 60;\n    case 6:\n      return 80;\n    default:\n      return 100;\n  }\n}\n\nconst axesFaces = [\n  [\"U\", \"D\"],\n  [\"L\", \"R\"],\n  [\"F\", \"B\"],\n];\nconst axesMovesCache: Map<number, QuantumMove[][]> = new Map();\nfunction cachedAxesMoves(n: number): QuantumMove[][] {\n  const existing = axesMovesCache.get(n);\n  if (existing) {\n    return existing;\n  }\n  const axesMoves = [];\n  for (const faces of axesFaces) {\n    const axisMoveFamilies: QuantumMove[] = [];\n    axesMoves.push(axisMoveFamilies);\n\n    for (const face of faces) {\n      axisMoveFamilies.push(new QuantumMove(face));\n      if (n > 3) {\n        axisMoveFamilies.push(new QuantumMove(`${face}w`));\n      }\n      for (let i = 3; i <= n / 2; i++) {\n        axisMoveFamilies.push(new QuantumMove(`${face}w`, i));\n      }\n    }\n  }\n  axesMovesCache.set(n, axesMoves);\n  return axesMoves;\n}\n\n// TODO: Document this algorithm and compare to TNoodle.\nexport async function bigCubeRandomMoves(n: number): Promise<Alg> {\n  const axesMoves = cachedAxesMoves(n);\n\n  const cachedNumMoves = numMoves(n);\n  const algBuilder = new AlgBuilder();\n  let currentAxisIdx = 0;\n  const currentAxisQuantumMoves = new Set();\n  while (algBuilder.experimentalNumAlgNodes() < cachedNumMoves) {\n    const newAxisIdx = randomUIntBelow(3);\n    if (newAxisIdx !== currentAxisIdx) {\n      currentAxisQuantumMoves.clear();\n    }\n    currentAxisIdx = newAxisIdx;\n\n    const quantumMove = randomChoice(axesMoves[currentAxisIdx]);\n    const quantumMoveStr = quantumMove.toString();\n    if (currentAxisQuantumMoves.has(quantumMoveStr)) {\n      // Skip duplicates and resample with replacement.\n      continue;\n    }\n    currentAxisQuantumMoves.add(quantumMoveStr);\n    algBuilder.push(new Move(quantumMove, randomChoice([1, 2, -1])));\n  }\n\n  return algBuilder.toAlg();\n}\n", "import type { Alg } from \"../../../../alg\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { bigCubeRandomMoves } from \"./big-cubes\";\n\nconst randomSuffixes = [\n  [null, \"3Rw\", \"3Rw2\", \"3Rw'\", \"3Fw\", \"3Fw'\"],\n  [null, \"3Dw\", \"3Dw2\", \"3Dw'\"],\n];\n\nexport async function oriented555RandomMoves(): Promise<Alg> {\n  return addOrientationSuffix(await bigCubeRandomMoves(5), randomSuffixes);\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicFTOSolver = from<\n  typeof import(\"./search-dynamic-solve-fto\")\n>(() => import(\"./search-dynamic-solve-fto\"));\n", "import { Alg } from \"../../../../alg\";\nimport type { KState } from \"../../../../kpuzzle/KState\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { from } from \"../../../../vendor/mit/p-lazy/p-lazy\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { dynamicFTOSolver } from \"./dynamic/fto\";\n\nconst dynamic = from<\n  typeof import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\")\n>(() => import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\"));\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (await dynamic).sgsDataFTO();\n      return new TrembleSolver(await puzzles[\"fto\"].kpuzzle(), json, [\n        \"U\",\n        \"R\",\n        \"F\",\n        \"L\",\n        \"D\",\n        \"B\",\n        \"BR\",\n        \"BL\",\n      ]);\n    })())\n  );\n}\n\nexport async function preInitializeFTO(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveFTO(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    state,\n    TREMBLE_DEPTH,\n    () => 3, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomFTOScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(await (await dynamicFTOSolver).randomFTOScrambleString());\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicKilominxSolver = from<\n  typeof import(\"./search-dynamic-solve-kilominx\")\n>(() => import(\"./search-dynamic-solve-kilominx\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicKilominxSolver } from \"./dynamic/kilominx\";\n\nexport async function randomKilominxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await dynamicKilominxSolver).getRandomKilominxScramble();\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicMasterTetraminxSolver = from<\n  typeof import(\"./search-dynamic-solve-master_tetraminx\")\n>(() => import(\"./search-dynamic-solve-master_tetraminx\"));\n", "import { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicMasterTetraminxSolver } from \"./dynamic/master_tetraminx\";\n\nexport async function randomMasterTetraminxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(\n    await (\n      await dynamicMasterTetraminxSolver\n    ).randomMasterTetraminxScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KStateData } from \"../../../../kpuzzle\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 2;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedSGSDataMegaminx();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n        json,\n        [\"U\", \"R\", \"F\", \"L\", \"BR\", \"BL\", \"FR\", \"FL\", \"DR\", \"DL\", \"B\", \"D\"],\n      );\n    })())\n  );\n}\n\nexport async function preInitializeMegaminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveMegaminx(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const stateDataWithoutMO: KStateData = JSON.parse(\n    JSON.stringify(state.stateData),\n  );\n  stateDataWithoutMO.CENTERS.orientation = new Array(12).fill(0);\n  const stateWithoutMO = new KState(\n    await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n    stateDataWithoutMO,\n  );\n  const alg = await trembleSolver.solve(\n    stateWithoutMO,\n    TREMBLE_DEPTH,\n    () => 5, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KState } from \"../../../../kpuzzle/KState\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomStateFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataPyraminx();\n      return new TrembleSolver(\n        await puzzles.pyraminx.kpuzzle(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializePyraminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solvePyraminx(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(state, TREMBLE_DEPTH, () => 3); // TODO: Attach quantum move order lookup to puzzle.\n  return alg;\n}\n\nexport async function randomPyraminxStateFixedOrientation(): Promise<KState> {\n  mustBeInsideWorker();\n  // Note: this sets all center orientations to 0.\n  return randomStateFromSGS(\n    await puzzles.pyraminx.kpuzzle(),\n    await (await searchDynamicSideEvents).sgsDataPyraminxFixedOrientation(),\n  );\n}\n\nexport async function randomPyraminxScrambleFixedOrientation(): Promise<Alg> {\n  return solvePyraminx(await randomPyraminxStateFixedOrientation());\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicUnofficial = from<\n  typeof import(\"./search-dynamic-sgs-unofficial\")\n>(() => import(\"./search-dynamic-sgs-unofficial\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { searchDynamicUnofficial } from \"./dynamic/sgs-unofficial\";\n\nexport async function randomRediCubeScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await searchDynamicUnofficial).getRandomRediCubeScramble();\n}\n", "import type { Alg, QuantumMove } from \"../../../../alg\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomStateFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataSkewb();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializeSkewb(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nasync function resetCenterOrientation(state: KState): Promise<KState> {\n  return new KState(\n    await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n    {\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    },\n  );\n}\n\n// TODO: fix def consistency.\nexport async function solveSkewb(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    await resetCenterOrientation(state),\n    TREMBLE_DEPTH,\n    (quantumMove: QuantumMove) => (quantumMove.family === \"y\" ? 4 : 3), // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomSkewbFixedCornerState(): Promise<KState> {\n  // Note: this sets all center orientations to 0.\n  return randomStateFromSGS(\n    await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n    await (await searchDynamicSideEvents).sgsDataSkewbFixedCorner(),\n  );\n}\n\nexport async function randomSkewbFixedCornerScramble(): Promise<Alg> {\n  return solveSkewb(await randomSkewbFixedCornerState());\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicSq1Solver = from<\n  typeof import(\"./search-dynamic-solve-sq1\")\n>(() => import(\"./search-dynamic-solve-sq1\"));\n", "import { Alg } from \"../../../../alg\";\nimport { dynamicSq1Solver } from \"./dynamic/sq1\";\n\nexport async function getRandomSquare1Scramble(): Promise<Alg> {\n  return Alg.fromString(\n    await (await dynamicSq1Solver).getRandomSquare1ScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../alg\";\nimport {\n  KPuzzleDefinition,\n  KState,\n  KStateData,\n  KTransformationData,\n} from \"../../kpuzzle\";\nimport { puzzles } from \"../../puzzles\";\nimport { setIsInsideWorker } from \"./inside-worker\";\nimport {\n  preInitialize222,\n  random222Scramble,\n  solve222HTMSubOptimal,\n} from \"./solve/puzzles/2x2x2\";\nimport {\n  initialize333,\n  random333FewestMovesScramble,\n  random333OrientedScramble,\n  random333Scramble,\n  solve333,\n} from \"./solve/puzzles/3x3x3\";\nimport {\n  initialize444,\n  random444OrientedScramble,\n  random444Scramble,\n} from \"./solve/puzzles/4x4x4\";\nimport { oriented555RandomMoves } from \"./solve/puzzles/5x5x5\";\nimport { bigCubeRandomMoves } from \"./solve/puzzles/big-cubes\";\nimport { randomFTOScramble } from \"./solve/puzzles/fto\";\nimport { randomKilominxScramble } from \"./solve/puzzles/kilominx\";\nimport { randomMasterTetraminxScramble } from \"./solve/puzzles/master_tetraminx\";\nimport { solveMegaminx } from \"./solve/puzzles/megaminx\";\nimport {\n  randomPyraminxScrambleFixedOrientation,\n  solvePyraminx,\n} from \"./solve/puzzles/pyraminx\";\nimport { randomRediCubeScramble } from \"./solve/puzzles/redi_cube\";\nimport {\n  randomSkewbFixedCornerScramble,\n  solveSkewb,\n} from \"./solve/puzzles/skewb\";\nimport { getRandomSquare1Scramble } from \"./solve/puzzles/sq1\";\nimport { solveTwsearch, TwsearchOptions } from \"./solve/twsearch\";\n\nconst IDLE_PREFETCH_TIMEOUT_MS = 1000;\n\nsetIsInsideWorker(true);\n\nlet DEBUG_MEASURE_PERF = true;\nexport function setDebugMeasurePerf(newDebugMeasurePerf: boolean): void {\n  DEBUG_MEASURE_PERF = newDebugMeasurePerf;\n}\n\nfunction now() {\n  return (typeof performance === \"undefined\" ? Date : performance).now();\n}\n\nasync function measurePerf<T>(\n  name: string,\n  f: () => T | Promise<T>,\n  options?: { isPrefetch?: boolean },\n): Promise<T> {\n  if (!DEBUG_MEASURE_PERF) {\n    return f();\n  }\n\n  const start = now();\n  const result = f();\n  if ((result as any)?.then) {\n    await result;\n  }\n  const end = now();\n  console.warn(\n    `${name}${options?.isPrefetch ? \" (prefetched)\" : \"\"}: ${Math.round(\n      end - start,\n    )}ms`,\n  );\n  return result;\n}\n\nconst prefetchPromises: Map<string, Promise<Alg>> = new Map();\n// This would just be a number, except `node` is extremely silly and returns an object instead.\n// https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\nlet queuedPrefetchTimeoutID: ReturnType<typeof setTimeout> | null = null;\n\nasync function randomScrambleForEvent(\n  eventID: string,\n  options?: { isPrefetch?: boolean },\n): Promise<Alg> {\n  switch (eventID) {\n    case \"222\":\n      return measurePerf(\"random222Scramble\", random222Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"333\":\n    case \"333oh\":\n    case \"333ft\":\n      return measurePerf(\"random333Scramble\", random333Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"333fm\":\n      return measurePerf(\n        \"random333FewestMovesScramble\",\n        random333FewestMovesScramble,\n      );\n    case \"333bf\":\n    case \"333mb\":\n      return measurePerf(\n        \"random333OrientedScramble\",\n        random333OrientedScramble,\n      );\n    case \"444\":\n      return measurePerf(\"random444Scramble\", random444Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"444bf\":\n      return measurePerf(\n        \"random444OrientedScramble\",\n        random444OrientedScramble,\n      );\n    case \"555\":\n      return measurePerf(\n        \"bigCubeScramble(5)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 5),\n      );\n    case \"555bf\":\n      return measurePerf(\"oriented555RandomMoves\", oriented555RandomMoves);\n    case \"666\":\n      return measurePerf(\n        \"bigCubeScramble(6)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 6),\n      );\n    case \"777\":\n      return measurePerf(\n        \"bigCubeScramble(7)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 7),\n      );\n    case \"skewb\":\n      return measurePerf(\n        \"randomSkewbFixedCornerScramble\",\n        randomSkewbFixedCornerScramble,\n      );\n    case \"pyram\":\n      return measurePerf(\n        \"randomPyraminxScrambleFixedOrientation\",\n        randomPyraminxScrambleFixedOrientation,\n      );\n    case \"sq1\":\n      return measurePerf(\"getRandomSquare1Scramble\", getRandomSquare1Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"fto\":\n      return measurePerf(\"randomFTOScramble\", randomFTOScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"master_tetraminx\":\n      return measurePerf(\n        \"randomMasterTetraminxScramble\",\n        randomMasterTetraminxScramble,\n      );\n    case \"kilominx\":\n      return measurePerf(\"randomKilominxScramble\", randomKilominxScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"redi_cube\":\n      return measurePerf(\"randomRediCubeScramble\", randomRediCubeScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    default:\n      throw new Error(`unsupported event: ${eventID}`);\n  }\n}\n\nexport enum PrefetchLevel {\n  Auto = \"auto\",\n  None = \"none\",\n  Immediate = \"immediate\",\n}\n\nlet currentPrefetchLevel = PrefetchLevel.Auto;\n\nexport const insideAPI = {\n  initialize: async (eventID: string) => {\n    switch (eventID) {\n      case \"222\":\n        return measurePerf(\"preInitialize222\", preInitialize222);\n      case \"333\":\n      case \"333oh\":\n      case \"333ft\":\n        return measurePerf(\"initialize333\", initialize333);\n      case \"444\":\n        return measurePerf(\"initialize444\", initialize444);\n      default:\n        throw new Error(`unsupported event: ${eventID}`);\n    }\n  },\n\n  setScramblePrefetchLevel(prefetchLevel: `${PrefetchLevel}`) {\n    currentPrefetchLevel = prefetchLevel as PrefetchLevel;\n  },\n\n  randomScrambleForEvent: async (eventID: string): Promise<Alg> => {\n    let promise = prefetchPromises.get(eventID);\n    if (promise) {\n      prefetchPromises.delete(eventID);\n    } else {\n      promise = randomScrambleForEvent(eventID);\n    }\n    if (currentPrefetchLevel !== PrefetchLevel.None) {\n      promise.then(() => {\n        // `queuedPrefetch` could be 0, but:\n        // > Passing an invalid ID to clearTimeout() silently does nothing; no exception is thrown.\n        // https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout#notes\n        if (queuedPrefetchTimeoutID) {\n          clearTimeout(queuedPrefetchTimeoutID);\n        }\n        queuedPrefetchTimeoutID = setTimeout(\n          () => {\n            prefetchPromises.set(\n              eventID,\n              randomScrambleForEvent(eventID, {\n                isPrefetch: true,\n              }),\n            );\n          },\n          currentPrefetchLevel === PrefetchLevel.Immediate\n            ? 0\n            : IDLE_PREFETCH_TIMEOUT_MS,\n        );\n      });\n    }\n    return promise;\n  },\n\n  randomScrambleStringForEvent: async (eventID: string): Promise<string> => {\n    return (await insideAPI.randomScrambleForEvent(eventID)).toString();\n  },\n\n  solve333ToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"3x3x3\"].kpuzzle(), stateData);\n    return (await solve333(state)).toString();\n  },\n\n  solve222ToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"2x2x2\"].kpuzzle(), stateData);\n    return (await solve222HTMSubOptimal(state)).toString();\n  },\n\n  solveSkewbToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"skewb\"].kpuzzle(), stateData);\n    return (await solveSkewb(state)).toString();\n  },\n\n  solvePyraminxToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"pyraminx\"].kpuzzle(), stateData);\n    return (await solvePyraminx(state)).toString();\n  },\n\n  solveMegaminxToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"megaminx\"].kpuzzle(), stateData);\n    return (await solveMegaminx(state)).toString();\n  },\n\n  setDebugMeasurePerf: async (measure: boolean): Promise<void> => {\n    setDebugMeasurePerf(measure);\n  },\n\n  solveTwsearchToString: async (\n    def: KPuzzleDefinition,\n    stateData: KTransformationData,\n    options?: TwsearchOptions,\n  ): Promise<string> => {\n    return (await solveTwsearch(def, stateData, options)).toString();\n  },\n};\n\nexport type WorkerInsideAPI = typeof insideAPI;\n"],
  "mappings": "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",
  "names": ["randomChoice", "randomUIntBelow", "randomSuffixes", "cachedTrembleSolver", "getCachedTrembleSolver", "getCachedTrembleSolver", "TREMBLE_DEPTH", "cachedTrembleSolver", "getCachedTrembleSolver", "getCachedTrembleSolver", "TREMBLE_DEPTH", "TREMBLE_DEPTH", "cachedTrembleSolver", "getCachedTrembleSolver", "getCachedTrembleSolver", "TREMBLE_DEPTH"]
}
