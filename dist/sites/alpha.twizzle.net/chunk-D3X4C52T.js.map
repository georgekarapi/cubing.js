{
  "version": 3,
  "sources": ["../../../src/cubing/kpuzzle/combine.ts", "../../../src/cubing/kpuzzle/calculate.ts", "../../../src/cubing/kpuzzle/construct.ts", "../../../src/cubing/kpuzzle/KState.ts", "../../../src/cubing/kpuzzle/KTransformation.ts", "../../../src/cubing/kpuzzle/KPuzzle.ts", "../../../src/cubing/puzzles/stickerings/mask.ts", "../../../src/cubing/puzzles/stickerings/puzzle-stickerings.ts", "../../../src/cubing/puzzles/stickerings/cube-like-stickerings.ts", "../../../src/cubing/puzzles/async/lazy-cached.ts", "../../../src/cubing/vendor/mit/p-lazy/p-lazy.ts", "../../../src/cubing/puzzles/async/async-pg3d.ts", "../../../src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts", "../../../src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts", "../../../src/cubing/puzzles/PuzzleLoader.ts", "../../../src/cubing/puzzles/implementations/dynamic/2x2x2/puzzle-orientation.ts", "../../../src/cubing/puzzles/customPGPuzzleLoader.ts", "../../../src/cubing/puzzles/cubing-private/index.ts", "../../../src/cubing/puzzles/implementations/3x3x3/puzzle-specific-simplifications.ts", "../../../src/cubing/puzzles/implementations/3x3x3/index.ts", "../../../src/cubing/puzzles/events.ts", "../../../src/cubing/puzzles/implementations/2x2x2/index.ts", "../../../src/cubing/puzzles/implementations/clock/index.ts", "../../../src/cubing/puzzles/stickerings/fto-stickerings.ts", "../../../src/cubing/puzzles/implementations/fto/index.ts", "../../../src/cubing/puzzles/stickerings/megaminx-stickerings.ts", "../../../src/cubing/puzzles/implementations/megaminx/index.ts", "../../../src/cubing/puzzles/implementations/pyraminx/index.ts", "../../../src/cubing/puzzles/implementations/square1/index.ts", "../../../src/cubing/puzzles/implementations/kilominx/index.ts", "../../../src/cubing/puzzles/implementations/redi-cube/index.ts", "../../../src/cubing/puzzles/implementations/4x4x4/index.ts", "../../../src/cubing/puzzles/implementations/melindas2x2x2x2/index.ts", "../../../src/cubing/puzzles/index.ts"],
  "sourcesContent": ["import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = transformationData1[orbitName];\n    const orbit2 = transformationData2[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToStateData(\n  definition: KPuzzleDefinition,\n  stateData: KStateData,\n  transformationData: KTransformationData,\n): KStateData {\n  const newStateData = {} as KStateData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = stateData[orbitName];\n    const orbit2 = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newStateData[orbitName] = orbit1;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newStateData;\n}\n", "import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { functionFromTraversal } from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n  KPuzzleDefinition,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignoreOrientation?: boolean;\n    ignorePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignoreOrientation &&\n      orbitTransformationData1.orientation[idx] !==\n        orbitTransformationData2.orientation[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    kpuzzle.definition.orbits,\n  )) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitName],\n        transformationData2[orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition: KOrbitDefinition =\n      kpuzzle.definition.orbits[orbitName];\n    const orbitTransformationData = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitName] = orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: orbitTransformationData.orientation,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientation[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const algNode of alg.childAlgNodes()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseAlgNode(algNode, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseAlgNode(algNode, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nexport const algToTransformation = functionFromTraversal(\n  AlgToTransformationTraversal,\n);\n\nexport function canConvertStateToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(definition)) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.startStateData[orbitName].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const transformationOrbit = transformation.transformationData[orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientation[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, Math.abs(orientationSum));\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n", "import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientation: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    definition.orbits,\n  )) {\n    transformation[orbitName] = constructIdentityOrbitTransformation(\n      orbitDefinition.numPieces,\n    );\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  const quantumKey = move.quantum.toString();\n  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey] as\n    | KTransformationData\n    | undefined;\n\n  if (!quantumMoveDefinition) {\n    const derivedFrom =\n      kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];\n\n    if (derivedFrom) {\n      // TODO: avoid the round trip?\n      quantumMoveDefinition =\n        kpuzzle.algToTransformation(derivedFrom).transformationData;\n    }\n  }\n\n  if (quantumMoveDefinition) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      quantumMoveDefinition,\n      move.amount,\n    );\n  }\n\n  // Handle e.g. `y2` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const moveDefinition = kpuzzle.definition.moves[move.toString()];\n  if (moveDefinition) {\n    return moveDefinition;\n  }\n\n  // Handle e.g. `y2'` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const inverseMoveDefinition =\n    kpuzzle.definition.moves[move.invert().toString()];\n  if (inverseMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);\n  }\n\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n", "import type { KPuzzle } from \"./KPuzzle\";\nimport type { Alg, Move } from \"../alg\";\nimport { applyTransformationDataToStateData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type {\n  KStateData,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport class KState {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly stateData: KStateData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      stateData: this.stateData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KState {\n    const newStateData = applyTransformationDataToStateData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.startStateData,\n      transformation.transformationData,\n    );\n    return new KState(transformation.kpuzzle, newStateData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KState {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KState {\n    if (transformation.isIdentityTransformation()) {\n      return new KState(this.kpuzzle, this.stateData);\n    }\n    const newStateData = applyTransformationDataToStateData(\n      this.kpuzzle.definition,\n      this.stateData,\n      transformation.transformationData,\n    );\n    return new KState(this.kpuzzle, newStateData);\n  }\n\n  applyMove(move: Move | string): KState {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KState {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: stateOrbitData.pieces,\n        orientation: stateOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIsSolved(options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (!this.kpuzzle.definition.experimentalIsStateSolved) {\n      throw new Error(\n        \"`KState.experimentalIsSolved()` is not supported for this puzzle at the moment.\",\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsStateSolved(this, options);\n  }\n}\n", "import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKState(): KState {\n    return KState.fromTransformation(this);\n  }\n\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n", "import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  startState(): KState {\n    return new KState(this, this.definition.startStateData);\n  }\n\n  #cachedCanConvertStateToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete start state data\n  canConvertStateToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertStateToUniqueTransformation ??=\n      ((): boolean => {\n        for (const [orbitName, orbitDefinition] of Object.entries(\n          this.definition.orbits,\n        )) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.startStateData[orbitName]\n            .pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n}\n", "// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshStickeringMask =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"ignored\"\n  | \"invisible\";\n\nexport type FaceletStickeringMask = {\n  mask: FaceletMeshStickeringMask;\n  hintMask?: FaceletMeshStickeringMask;\n};\n\nexport type PieceStickeringMask = {\n  // TODO: foundation?\n  facelets: (FaceletMeshStickeringMask | FaceletStickeringMask | null)[];\n};\n\nexport type OrbitStickeringMask = {\n  pieces: (PieceStickeringMask | null)[];\n};\n\nexport type StickeringMask = {\n  specialBehaviour?: \"picture\"; // TODO: remove this\n  name?: string; // TODO\n  orbits: Record<string, OrbitStickeringMask>;\n};\n\nexport function getFaceletStickeringMask(\n  stickeringMask: StickeringMask,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshStickeringMask {\n  const orbitStickeringMask = stickeringMask.orbits[orbitName];\n  const pieceStickeringMask: PieceStickeringMask | null =\n    orbitStickeringMask.pieces[pieceIdx];\n  if (pieceStickeringMask === null) {\n    return regular;\n  }\n  const faceletStickeringMask:\n    | FaceletMeshStickeringMask\n    | FaceletStickeringMask\n    | null = pieceStickeringMask.facelets?.[faceletIdx];\n  if (faceletStickeringMask === null) {\n    return regular;\n  }\n  if (typeof faceletStickeringMask === \"string\") {\n    return faceletStickeringMask;\n  }\n  if (hint) {\n    return faceletStickeringMask.hintMask ?? faceletStickeringMask.mask;\n  }\n  console.log(faceletStickeringMask);\n  return faceletStickeringMask.mask;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const [orbitName, orbitDef] of Object.entries(\n      kpuzzle.definition.orbits,\n    )) {\n      this.stickerings.set(\n        orbitName,\n        new Array(orbitDef.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\n\n// We specify 5 facelets, because that's the maximum we need for any built-in puzzles (e.g. Megaminx centers or icosa vertices).\n// TODO: use \"primary\" and \"non-primary\" fields instead of listing all non-primary facelets.\nconst pieceStickerings: Record<string, PieceStickeringMask> = {\n  // regular\n  [PieceStickering.Regular]: {\n    // r\n    facelets: [regular, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Ignored]: {\n    // i\n    facelets: [ignored, ignored, ignored, ignored, ignored],\n  },\n\n  // oriented stickers\n  [PieceStickering.OrientationStickers]: {\n    // o\n    facelets: [oriented, oriented, oriented, oriented, oriented],\n  },\n\n  // \"OLL\"\n  [PieceStickering.IgnoreNonPrimary]: {\n    // riiii\n    facelets: [regular, ignored, ignored, ignored, ignored],\n  },\n\n  // invisible\n  [PieceStickering.Invisible]: {\n    // invisiblePiece\n    facelets: [invisible, invisible, invisible, invisible, invisible],\n  },\n\n  // \"PLL\"\n  [PieceStickering.PermuteNonPrimary]: {\n    // drrrr\n    facelets: [dim, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Dim]: {\n    // d\n    facelets: [dim, dim, dim, dim, dim],\n  },\n\n  // \"OLL\"\n  [PieceStickering.Ignoriented]: {\n    // diiii\n    facelets: [dim, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.OrientationWithoutPermutation]: {\n    // oiiii\n    facelets: [oriented, ignored, ignored, ignored, ignored],\n  },\n};\n\nexport function getPieceStickeringMask(\n  pieceStickering: PieceStickering,\n): PieceStickeringMask {\n  return pieceStickerings[pieceStickering];\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toStickeringMask(): StickeringMask {\n    const stickeringMask: StickeringMask = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceStickeringMask[] = [];\n      const orbitStickeringMask: OrbitStickeringMask = {\n        pieces,\n      };\n      stickeringMask.orbits[orbitName] = orbitStickeringMask;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceStickeringMask(pieceStickering));\n      }\n    }\n    return stickeringMask;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] =\n          !pieceSet.stickerings.get(orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitName].permutation[i] !== i ||\n          transformation.transformationData[orbitName].orientation[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  orbits(orbitNames: string[]): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName)!.fill(true);\n    }\n    return pieceSet;\n  }\n\n  orbitPrefix(orbitPrefix: string): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName in this.kpuzzle.definition.orbits) {\n      if (orbitName.startsWith(orbitPrefix)) {\n        pieceSet.stickerings.get(orbitName)!.fill(true);\n      }\n    }\n    return pieceSet;\n  }\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const [orbitName, orbitDef] of Object.entries(this.def.orbits)) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDef.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n", "import type { PuzzleID } from \"../../twisty\";\n\nconst LL = \"Last Layer\";\nconst LS = \"Last Slot\";\nconst megaAnd3x3x3LL = {\n  \"3x3x3\": LL,\n  megaminx: LL,\n};\nconst megaAnd3x3x3LS = {\n  \"3x3x3\": LS,\n  megaminx: LS,\n};\n\nexport const experimentalStickerings: Record<\n  string,\n  { groups?: Partial<Record<PuzzleID, string>> }\n> = {\n  full: { groups: { \"3x3x3\": \"Stickering\", megaminx: \"Stickering\" } }, // default\n  OLL: { groups: megaAnd3x3x3LL },\n  PLL: { groups: megaAnd3x3x3LL },\n  LL: { groups: megaAnd3x3x3LL },\n  EOLL: { groups: megaAnd3x3x3LL },\n  COLL: { groups: megaAnd3x3x3LL },\n  OCLL: { groups: megaAnd3x3x3LL },\n  CPLL: { groups: megaAnd3x3x3LL },\n  CLL: { groups: megaAnd3x3x3LL },\n  EPLL: { groups: megaAnd3x3x3LL },\n  ELL: { groups: megaAnd3x3x3LL },\n  ZBLL: { groups: megaAnd3x3x3LL },\n  LS: { groups: megaAnd3x3x3LS },\n  ELS: { groups: megaAnd3x3x3LS },\n  CLS: { groups: megaAnd3x3x3LS },\n  ZBLS: { groups: megaAnd3x3x3LS },\n  VLS: { groups: megaAnd3x3x3LS },\n  WVLS: { groups: megaAnd3x3x3LS },\n  F2L: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Daisy: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Cross: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  EO: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOline: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOcross: { groups: { \"3x3x3\": \"ZZ\" } },\n  CMLL: { groups: { \"3x3x3\": \"Roux\" } },\n  L10P: { groups: { \"3x3x3\": \"Roux\" } },\n  L6E: { groups: { \"3x3x3\": \"Roux\" } },\n  L6EO: { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  L2C: {\n    groups: {\n      \"4x4x4\": \"Reduction\",\n      \"5x5x5\": \"Reduction\",\n      \"6x6x6\": \"Reduction\",\n    },\n  },\n  PBL: {\n    groups: {\n      \"2x2x2\": \"Ortega\",\n    },\n  },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  invisible: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  picture: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } }, // TODO\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } },\n};\n", "import type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PieceSet,\n  PieceStickering,\n  StickeringMask,\n  PuzzleStickering,\n  StickeringManager,\n} from \"./mask\";\nimport { experimentalStickerings } from \"./puzzle-stickerings\";\n\n// TODO: cache calculations?\nexport async function cubeLikeStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const CENTERS = (): PieceSet => m.orbitPrefix(\"CENTER\");\n  const EDGES = (): PieceSet => m.orbitPrefix(\"EDGE\");\n  const CORNERS = (): PieceSet =>\n    m.or([\n      m.orbitPrefix(\"CORNER\"),\n      m.orbitPrefix(\"C4RNER\"),\n      m.orbitPrefix(\"C5RNER\"),\n    ]);\n\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n  const centerLL = (): PieceSet => m.and([LL(), CENTERS()]);\n\n  const edgeFR = (): PieceSet => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  const cornerDFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Regular); // For PG\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\": {\n      dimF2L();\n      setPLL();\n      break;\n    }\n    case \"CLS\": {\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"OLL\": {\n      dimF2L();\n      setOLL();\n      break;\n    }\n    case \"EOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"COLL\": {\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"OCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"CPLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.and([CORNERS(), LL()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      puzzleStickering.set(\n        m.and([m.not(CORNERS()), LL()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"CLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"EPLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), EDGES()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"ELL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ELS\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    }\n    case \"LL\": {\n      dimF2L();\n      break;\n    }\n    case \"F2L\": {\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    }\n    case \"ZBLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ZBLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"VLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    }\n    case \"WVLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"LS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim);\n      break;\n    }\n    case \"EO\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    }\n    case \"EOline\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    }\n    case \"EOcross\": {\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    }\n    case \"CMLL\": {\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L10P\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L6E\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    }\n    case \"L6EO\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.OrientationStickers,\n      ); // For PG\n      break;\n    }\n    case \"Daisy\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"Cross\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"2x2x2\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"2x2x3\": {\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"L2C\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"L\", \"R\", \"B\", \"D\"])),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    case \"PBL\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"D\"])),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"Void Cube\": {\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    }\n    case \"picture\":\n    // fallthrough\n    case \"invisible\": {\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    }\n    case \"centers-only\": {\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toStickeringMask();\n}\n\nexport async function cubeLikeStickeringList(\n  puzzleID: PuzzleID,\n  options?: { use3x3x3Fallbacks: boolean },\n): Promise<ExperimentalStickering[]> {\n  const stickerings: ExperimentalStickering[] = [];\n  const stickeringsFallback: ExperimentalStickering[] = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups) {\n      if (puzzleID in info.groups) {\n        stickerings.push(name);\n      } else if (options?.use3x3x3Fallbacks && \"3x3x3\" in info.groups) {\n        stickeringsFallback.push(name);\n      }\n    }\n  }\n  return stickerings.concat(stickeringsFallback);\n}\n", "export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n", "// @ts-nocheck\n\nexport class PLazy<T> extends Promise<T> {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n\n    this._executor = executor;\n  }\n\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.catch(onRejected);\n  }\n}\n\nexport function from<T>(function_): Promise<T> {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n", "import { KPuzzle, KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { StickeringMask } from \"../stickerings/mask\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../stickerings/cube-like-stickerings\";\nimport { getCached } from \"./lazy-cached\";\nimport { Move, PuzzleSpecificSimplifyOptions, QuantumMove } from \"../../alg\";\nimport { PLazy } from \"../../vendor/mit/p-lazy/p-lazy\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(this.pg(), this.id));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n\n  puzzleSpecificSimplifyOptionsPromise = puzzleSpecificSimplifyOptionsPromise(\n    this.kpuzzle.bind(this),\n  );\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return cubeLikeStickeringMask(this, stickering);\n  }\n  stickerings = () =>\n    cubeLikeStickeringList(this.id as PuzzleID, { use3x3x3Fallbacks: true });\n}\n\nexport function puzzleSpecificSimplifyOptionsPromise(\n  kpuzzlePromiseFn: () => Promise<KPuzzle>,\n): Promise<PuzzleSpecificSimplifyOptions> {\n  return new PLazy(\n    async (resolve: (options: PuzzleSpecificSimplifyOptions) => void) => {\n      const kpuzzle = await kpuzzlePromiseFn();\n      resolve({\n        quantumMoveOrder: (m: QuantumMove) => {\n          return kpuzzle.moveToTransformation(new Move(m)).repetitionOrder();\n        },\n      });\n    },\n  );\n}\n", "import type { KPuzzleDefinition } from \"../../../../kpuzzle\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: {\n    EDGES: { numPieces: 12, numOrientations: 2 },\n    CORNERS: { numPieces: 8, numOrientations: 3 },\n    CENTERS: { numPieces: 6, numOrientations: 4 },\n  },\n  startStateData: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientation: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n};\n\ncube3x3x3KPuzzleDefinition.experimentalDerivedMoves = {\n  Uw: \"u\",\n  Lw: \"l\",\n  Fw: \"f\",\n  Rw: \"r\",\n  Bw: \"b\",\n  Dw: \"d\",\n\n  Uv: \"y\",\n  Lv: \"x'\",\n  Fv: \"z\",\n  Rv: \"x\",\n  Bv: \"z'\",\n  Dv: \"y'\",\n\n  \"2U\": \"u U'\",\n  \"2L\": \"l L'\",\n  \"2F\": \"f F'\",\n  \"2R\": \"r R'\",\n  \"2B\": \"b B'\",\n  \"2D\": \"d D'\",\n};\n", "import { Alg } from \"../../../../alg\";\nimport { KState, KTransformation } from \"../../../../kpuzzle\";\nimport { experimental3x3x3KPuzzle } from \"../../../cubing-private\";\n\nexport function puzzleOrientation3x3x3Idx(state: KState): [number, number] {\n  const idxU = state.stateData[\"CENTERS\"].pieces[0];\n  const idxD = state.stateData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = state.stateData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCacheRaw: KTransformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array<KTransformation>(6);\n  });\n\nconst puzzleOrientationCacheInitialized = false;\nexport function puzzleOrientation3x3x3Cache(): KTransformation[][] {\n  if (!puzzleOrientationCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(\n            transformation.toKState(),\n          );\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize3x3x3Orientation(state: KState): KState {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(state);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return state.applyTransformation(orientationTransformation);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs3x3x3Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize3x3x3Orientation(state);\n  }\n  if (options.ignoreCenterOrientation) {\n    state = new KState(state.kpuzzle, {\n      EDGES: state.stateData.EDGES,\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    });\n  }\n  return !!state.experimentalToTransformation()?.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n", "import type { PuzzleSpecificSimplifyOptions } from \"../alg\";\nimport type { AppendOptions } from \"../alg/simplify\";\nimport type { KPuzzle } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../twisty\";\nimport type { StickeringMask } from \"./stickerings/mask\";\n\nexport interface PuzzleLoader {\n  id: string;\n  // shortName?: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number; // TODO: date?\n  /** @deprecated */\n  def?: never;\n  kpuzzle: () => Promise<KPuzzle>; // TODO\n  svg: () => Promise<string>;\n  llSVG?: () => Promise<string>;\n  pg?: () => Promise<PuzzleGeometry>;\n  stickeringMask?: (\n    stickering: ExperimentalStickering,\n  ) => Promise<StickeringMask>;\n  stickerings?: () => Promise<ExperimentalStickering[]>;\n  puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n  puzzleSpecificSimplifyOptionsPromise?: Promise<PuzzleSpecificSimplifyOptions>; // TODO\n}\n\n// TODO: consolidate the `puzzleSpecificSimplifyOptionsPromise` with `puzzleSpecificSimplifyOptions` somehow, so that we don't have to do this.\nexport async function getPartialAppendOptionsForPuzzleSpecificSimplifyOptions(\n  puzzleLoader: PuzzleLoader,\n): Promise<AppendOptions> {\n  const puzzleSpecificSimplifyOptions =\n    await (puzzleLoader.puzzleSpecificSimplifyOptions ??\n      puzzleLoader.puzzleSpecificSimplifyOptionsPromise);\n  if (!puzzleSpecificSimplifyOptions) {\n    return {};\n  }\n  return { puzzleLoader: { puzzleSpecificSimplifyOptions } };\n}\n", "import { Alg } from \"../../../../alg\";\nimport type { KPuzzle, KState, KTransformation } from \"../../../../kpuzzle\";\n\nexport function puzzleOrientation2x2x2Idx(state: KState): number {\n  const inverse = state.experimentalToTransformation()!.invert();\n\n  const inverseDFL = inverse.transformationData[\"CORNERS\"];\n  return inverseDFL.permutation[6] * 3 + inverseDFL.orientation[6];\n}\n\nconst puzzleOrientationCacheRaw: {\n  transformation: KTransformation;\n  alg: Alg;\n}[] = new Array<KTransformation>(24) as any;\n\nconst puzzleOrientationCacheInitialized = false;\n// We rely on the (first) caller to pass in the `KPuzzle`, so that we don't need to get our own synchronous reference.\nexport function puzzleOrientation2x2x2Cache(\n  kpuzzle: KPuzzle,\n): typeof puzzleOrientationCacheRaw {\n  if (!puzzleOrientationCacheInitialized) {\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = kpuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const idx = puzzleOrientation2x2x2Idx(transformation.toKState());\n          puzzleOrientationCacheRaw[idx] = {\n            transformation: transformation.invert(),\n            alg: uAlg.concat(yAlg),\n          };\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize2x2x2Orientation(state: KState): {\n  normalizedState: KState;\n  normalizationAlg: Alg;\n} {\n  const idx = puzzleOrientation2x2x2Idx(state);\n  const { transformation, alg } = puzzleOrientation2x2x2Cache(state.kpuzzle)[\n    idx\n  ];\n  return {\n    normalizedState: state.applyTransformation(transformation),\n    normalizationAlg: alg.invert(),\n  };\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs2x2x2Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize2x2x2Orientation(state).normalizedState;\n  }\n  return !!state.experimentalToTransformation()!.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n", "import { KPuzzle, KPuzzleDefinition } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport { puzzleSpecificSimplifyOptionsPromise } from \"./async/async-pg3d\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: dedup with `cubing/puzzles`\nexport async function asyncGetKPuzzle(\n  desc: PuzzleDescriptionString,\n): Promise<KPuzzle> {\n  const pg = await descAsyncGetPuzzleGeometry(desc);\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = `description: ${desc}`;\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const kpuzzlePromiseFn = async () => {\n    return (cachedKPuzzle ??= asyncGetKPuzzle(desc));\n  };\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: kpuzzlePromiseFn,\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n    puzzleSpecificSimplifyOptionsPromise:\n      puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn),\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n", "import { KPuzzle } from \"../../kpuzzle\";\nimport { cube3x3x3KPuzzleDefinition as experimentalCube3x3x3KPuzzleDefinition } from \"../implementations/dynamic/3x3x3/3x3x3.kpuzzle.json\";\nimport { experimentalIs3x3x3Solved } from \"../implementations/dynamic/3x3x3/puzzle-orientation\";\nexport { getPartialAppendOptionsForPuzzleSpecificSimplifyOptions } from \"../PuzzleLoader\";\nexport { experimentalCube3x3x3KPuzzleDefinition };\n\n/** @deprecated */\nexport const experimental3x3x3KPuzzle = new KPuzzle(\n  experimentalCube3x3x3KPuzzleDefinition,\n);\nexperimentalCube3x3x3KPuzzleDefinition.experimentalIsStateSolved =\n  experimentalIs3x3x3Solved;\n\nexport {\n  experimentalIs3x3x3Solved,\n  normalize3x3x3Orientation as experimentalNormalize3x3x3Orientation,\n  puzzleOrientation3x3x3Cache as experimentalPuzzleOrientation3x3x3Cache,\n  puzzleOrientation3x3x3Idx as experimentalPuzzleOrientation3x3x3Idx,\n} from \"../implementations/dynamic/3x3x3/puzzle-orientation\"; // TODO: Actually dynamic\nexport { experimentalStickerings } from \"../stickerings/puzzle-stickerings\";\n\nexport {\n  experimentalIs2x2x2Solved,\n  normalize2x2x2Orientation as experimentalNormalize2x2x2Orientation,\n  puzzleOrientation2x2x2Cache as experimentalPuzzleOrientation2x2x2Cache,\n  puzzleOrientation2x2x2Idx as experimentalPuzzleOrientation2x2x2Idx,\n} from \"../implementations/dynamic/2x2x2/puzzle-orientation\"; // TODO: Actually dynamic\n\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"../customPGPuzzleLoader\";\nexport { getFaceletStickeringMask as experimentalGetFaceletStickeringMask } from \"../stickerings/mask\";\nexport type {\n  PieceStickeringMask as ExperimentalPieceStickeringMask,\n  FaceletMeshStickeringMask as ExperimentalFaceletMeshStickeringMask,\n  StickeringMask as ExperimentalStickeringMask,\n} from \"../stickerings/mask\";\nexport {\n  getPieceStickeringMask as experimentalGetPieceStickeringMask,\n  PieceStickering as ExperimentalPieceStickering,\n} from \"../stickerings/mask\";\n", "import type { PuzzleSpecificSimplifyOptions } from \"../../../alg\";\nimport { Move, QuantumMove } from \"../../../alg\";\n\nenum Axis {\n  X = \"x axis\",\n  Y = \"y axis\",\n  Z = \"z axis\",\n}\n\nenum MoveSourceType {\n  INDEXABLE_SLICE_NEAR,\n  INDEXABLE_SLICE_FAR,\n  INDEXABLE_WIDE_NEAR,\n  INDEXABLE_WIDE_FAR,\n  SPECIFIC_SLICE,\n  ROTATION,\n}\n\ninterface MoveSourceInfo {\n  family: string;\n  direction: -1 | 1;\n  type: MoveSourceType;\n  from: number;\n  to: number;\n}\n\nfunction makeSourceInfo(\n  moveStrings: string[],\n  type: MoveSourceType,\n  from: number,\n  to: number,\n): MoveSourceInfo[] {\n  const output: MoveSourceInfo[] = [];\n  for (const moveString of moveStrings) {\n    const move = Move.fromString(moveString);\n    const { family, amount: direction } = move;\n    if (![-1, 1].includes(direction)) {\n      // TODO: test iner/outer\n      // TODO: Can we move this to a test file?\n      throw new Error(\"Invalid config move\");\n    }\n    output.push({ family, direction: direction as -1 | 1, type, from, to });\n  }\n  return output;\n}\n\ninterface AxisInfo {\n  sliceDiameter: number;\n  extendsThroughEntirePuzzle: boolean;\n  moveSourceInfos: MoveSourceInfo[];\n}\n\n// TODO: wide slices\nconst axisInfos: Record<Axis, AxisInfo> = {\n  [Axis.X]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"R\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"L'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"r\", \"Rw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"l'\", \"Lw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"M'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"x\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Y]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"U\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"D'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"u\", \"Uw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"d'\", \"Dw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"E'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"y\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Z]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"F\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"B'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"f\", \"Fw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 3),\n      ...makeSourceInfo([\"b'\", \"Bw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 3),\n      ...makeSourceInfo([\"S\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"z\", \"Fv\", \"Bv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n};\n\nconst byFamily: Record<string, { axis: Axis; moveSourceInfo: MoveSourceInfo }> =\n  {};\nfor (const [axis, info] of Object.entries(axisInfos)) {\n  for (const moveSourceInfo of info.moveSourceInfos) {\n    byFamily[moveSourceInfo.family] = { axis: axis as Axis, moveSourceInfo };\n  }\n}\n\n// TODO: lazy initialization?\nconst byAxisThenType: Record<\n  Axis,\n  Partial<Record<MoveSourceType, MoveSourceInfo[]>>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Partial<Record<MoveSourceType, MoveSourceInfo[]>> = {};\n  byAxisThenType[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    (entry[moveSourceInfo.type] ??= []).push(moveSourceInfo);\n  }\n}\n\n// TODO: consolidate lookup tables?\nconst byAxisThenSpecificSlices: Record<\n  Axis,\n  Map<number, MoveSourceInfo>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Map<number, MoveSourceInfo> = new Map();\n  byAxisThenSpecificSlices[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    // We only want to use the first entry per slice index (in the unlikely case there are multiple).\n    if (!entry.get(moveSourceInfo.from)) {\n      entry.set(moveSourceInfo.from, moveSourceInfo);\n    }\n  }\n}\n\nfunction firstOfType(\n  axis: Axis,\n  moveSourceType: MoveSourceType,\n): MoveSourceInfo {\n  const entry = byAxisThenType[axis][moveSourceType]?.[0];\n  if (!entry) {\n    throw new Error(\n      `Could not find a reference move (axis: ${axis}, move source type: ${moveSourceType})`,\n    );\n  }\n  return entry;\n}\n\nconst areQuantumMovesSameAxis = (\n  quantumMove1: QuantumMove,\n  quantumMove2: QuantumMove,\n) => {\n  return (\n    byFamily[quantumMove1.family].axis === byFamily[quantumMove2.family].axis\n  );\n};\n\nfunction simplestMove(\n  axis: Axis,\n  from: number,\n  to: number,\n  directedAmount: number,\n): Move {\n  if (from + 1 === to) {\n    const sliceSpecificInfo = byAxisThenSpecificSlices[axis].get(from);\n    if (sliceSpecificInfo) {\n      return new Move(\n        new QuantumMove(sliceSpecificInfo.family),\n        directedAmount * sliceSpecificInfo.direction,\n      );\n    }\n  }\n\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  if (from === 0 && to === sliceDiameter) {\n    const moveSourceInfo = firstOfType(axis, MoveSourceType.ROTATION);\n    return new Move(\n      new QuantumMove(moveSourceInfo.family),\n      directedAmount * moveSourceInfo.direction,\n    );\n  }\n\n  // const specificSliceInfo = byAxisThenSpecificSlices[axis].get(from);\n  const far = from + to > sliceDiameter; // (from + to) / 2 > sliceDiameter / 2\n  if (far) {\n    [from, to] = [sliceDiameter - to, sliceDiameter - from];\n  }\n\n  let outerLayer: number | null = from + 1; // change to 1-indexed\n  let innerLayer: number | null = to; // already 1-indexed\n  const slice = outerLayer === innerLayer;\n  if (slice) {\n    innerLayer = null;\n  }\n\n  if (outerLayer === 1) {\n    outerLayer = null;\n  }\n  if (slice && outerLayer === 1) {\n    innerLayer = null;\n  }\n  if (!slice && innerLayer === 2) {\n    innerLayer = null;\n  }\n\n  const moveSourceType = slice\n    ? far\n      ? MoveSourceType.INDEXABLE_SLICE_FAR\n      : MoveSourceType.INDEXABLE_SLICE_NEAR\n    : far\n    ? MoveSourceType.INDEXABLE_WIDE_FAR\n    : MoveSourceType.INDEXABLE_WIDE_NEAR;\n  const moveSourceInfo = firstOfType(axis, moveSourceType);\n  return new Move(\n    new QuantumMove(moveSourceInfo.family, innerLayer, outerLayer),\n    directedAmount * moveSourceInfo.direction,\n  );\n}\n\nfunction simplifySameAxisMoves(\n  moves: Move[],\n  quantumMod: boolean = true, // TODO\n): Move[] {\n  if (moves.length === 0) {\n    // TODO: can we use the type system to avoid this?\n    return [];\n  }\n\n  const axis: Axis = byFamily[moves[0].family].axis;\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  const sliceDeltas = new Map<number, number>();\n  let lastCandidateRange: {\n    suffixLength: number;\n    sliceDeltas: Map<number, number>;\n  } | null = null;\n\n  function adjustValue(idx: number, relativeDelta: number) {\n    let newDelta = (sliceDeltas.get(idx) ?? 0) + relativeDelta;\n    if (quantumMod) {\n      newDelta = (newDelta % 4) + (5 % 4) - 1; // TODO: Use a passed-in `modMove`?\n    }\n    if (newDelta === 0) {\n      sliceDeltas.delete(idx);\n    } else {\n      sliceDeltas.set(idx, newDelta);\n    }\n  }\n  // TODO: go as far as possible instead of trying to take all moves, e.g. simplify U y y' to U.\n  let suffixLength = 0;\n  // TODO: Reverse iterator?\n  for (const move of Array.from(moves).reverse()) {\n    suffixLength++;\n    const { moveSourceInfo } = byFamily[move.family];\n    const directedAmount = move.amount * moveSourceInfo.direction;\n    // console.log({ directedAmount });\n    switch (moveSourceInfo.type) {\n      case MoveSourceType.INDEXABLE_SLICE_NEAR: {\n        // We convert to zero-indexing\n        const idx = (move.innerLayer ?? 1) - 1;\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_SLICE_FAR: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        const idx = sliceDiameter - (move.innerLayer ?? 1);\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_NEAR: {\n        adjustValue((move.outerLayer ?? 1) - 1, directedAmount);\n        adjustValue(move.innerLayer ?? 2, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_FAR: {\n        adjustValue(sliceDiameter - (move.innerLayer ?? 2), directedAmount);\n        adjustValue(\n          sliceDiameter - ((move.outerLayer ?? 1) - 1),\n          -directedAmount,\n        );\n        break;\n      }\n      case MoveSourceType.SPECIFIC_SLICE: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        adjustValue(moveSourceInfo.from, directedAmount);\n        adjustValue(moveSourceInfo.to, -directedAmount);\n        break;\n      }\n      case MoveSourceType.ROTATION: {\n        adjustValue(0, directedAmount);\n        adjustValue(sliceDiameter, -directedAmount);\n        break;\n      }\n    }\n    if ([0, 2].includes(sliceDeltas.size)) {\n      lastCandidateRange = { suffixLength, sliceDeltas: new Map(sliceDeltas) };\n    }\n  }\n  if (sliceDeltas.size === 0) {\n    return [];\n  }\n  // TODO: handle this check in the destructuring assignment?\n  if (!lastCandidateRange) {\n    return moves;\n  }\n  let [from, to] = lastCandidateRange.sliceDeltas.keys();\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n  const directedAmount = lastCandidateRange.sliceDeltas.get(from)!;\n  // TODO: Handle empty move\n  return [\n    ...moves.slice(0, -lastCandidateRange.suffixLength),\n    ...(directedAmount !== 0\n      ? [simplestMove(axis, from, to, directedAmount)]\n      : []),\n  ];\n}\n\nexport const puzzleSpecificSimplifyOptions333: PuzzleSpecificSimplifyOptions = {\n  quantumMoveOrder: () => 4,\n  // doQuantumMovesCommute: areQuantumMovesSameAxis,\n  axis: { areQuantumMovesSameAxis, simplifySameAxisMoves },\n};\n", "// Include 3x3x3 in the main bundle for better performance.\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport { experimental3x3x3KPuzzle } from \"../../cubing-private\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  cubeLikeStickeringMask,\n  cubeLikeStickeringList,\n} from \"../../stickerings/cube-like-stickerings\";\nimport { puzzleSpecificSimplifyOptions333 } from \"./puzzle-specific-simplifications\";\n\n/** @category Specific Puzzles */\nexport const cube3x3x3: PuzzleLoader = {\n  id: \"3x3x3\",\n  fullName: \"3\u00D73\u00D73 Cube\",\n  inventedBy: [\"Ern\u0151 Rubik\"],\n  inventionYear: 1974, // https://en.wikipedia.org/wiki/Rubik%27s_Cube#Conception_and_development\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\")\n    ).cube3x3x3SVG;\n  }),\n  llSVG: getCached(async () => {\n    return (\n      await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\")\n    ).cube3x3x3LLSVG;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  stickeringMask: (\n    stickering: ExperimentalStickering,\n  ): Promise<StickeringMask> => cubeLikeStickeringMask(cube3x3x3, stickering),\n  stickerings: () => cubeLikeStickeringList(\"3x3x3\"),\n  puzzleSpecificSimplifyOptions: puzzleSpecificSimplifyOptions333,\n};\n", "import type { PuzzleID } from \"../twisty\";\n\ninterface EventInfo {\n  puzzleID: PuzzleID;\n  eventName: string;\n}\n\nexport const wcaEvents: Record<string, EventInfo> = {\n  \"333\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Cube\" },\n  \"222\": { puzzleID: \"2x2x2\", eventName: \"2x2x2 Cube\" },\n  \"444\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Cube\" },\n  \"555\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Cube\" },\n  \"666\": { puzzleID: \"6x6x6\", eventName: \"6x6x6 Cube\" },\n  \"777\": { puzzleID: \"7x7x7\", eventName: \"7x7x7 Cube\" },\n  \"333bf\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Blindfolded\" },\n  \"333fm\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Fewest Moves\" },\n  \"333oh\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 One-Handed\" },\n  clock: { puzzleID: \"clock\", eventName: \"Clock\" },\n  minx: { puzzleID: \"megaminx\", eventName: \"Megaminx\" },\n  pyram: { puzzleID: \"pyraminx\", eventName: \"Pyraminx\" },\n  skewb: { puzzleID: \"skewb\", eventName: \"Skewb\" },\n  sq1: { puzzleID: \"square1\", eventName: \"Square-1\" },\n  \"444bf\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Blindfolded\" },\n  \"555bf\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Blindfolded\" },\n  \"333mb\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Multi-Blind\" },\n};\n\n/** @category Event Info */\nexport function wcaEventInfo(event: string): EventInfo | null {\n  return wcaEvents[event] ?? null;\n}\n\nexport const twizzleEvents: Record<string, EventInfo> = {\n  ...wcaEvents,\n  fto: { puzzleID: \"fto\", eventName: \"Face-Turning Octahedron\" },\n  master_tetraminx: {\n    puzzleID: \"master_tetraminx\",\n    eventName: \"Master Tetraminx\",\n  },\n  kilominx: {\n    puzzleID: \"kilominx\",\n    eventName: \"Kilominx\",\n  },\n  redi_cube: {\n    puzzleID: \"redi_cube\",\n    eventName: \"Redi Cube\",\n  },\n};\n\n/** @category Event Info */\nexport function eventInfo(event: string): EventInfo | null {\n  return twizzleEvents[event] ?? null;\n}\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../../stickerings/cube-like-stickerings\";\n\n/** @category Specific Puzzles */\nexport const cube2x2x2: PuzzleLoader = {\n  id: \"2x2x2\",\n  fullName: \"2\u00D72\u00D72 Cube\",\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .cube2x2x2JSON,\n      ),\n  ),\n  svg: async () =>\n    (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .cube2x2x2SVG,\n  llSVG: getCached(\n    async () =>\n      (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n        .cube2x2x2LLSVG,\n  ),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"2x2x2\");\n  }),\n  stickeringMask: (\n    stickering: ExperimentalStickering,\n  ): Promise<StickeringMask> => cubeLikeStickeringMask(cube2x2x2, stickering),\n  stickerings: () =>\n    cubeLikeStickeringList(\"2x2x2\", { use3x3x3Fallbacks: true }),\n};\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const clock: PuzzleLoader = {\n  id: \"clock\",\n  fullName: \"Clock\",\n  inventedBy: [\"Christopher C. Wiggs\", \"Christopher J. Taylor\"],\n  inventionYear: 1988, // Patent application year: https://www.jaapsch.net/puzzles/patents/us4869506.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .clockJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n    ).clockSVG;\n  }),\n};\n", "import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  StickeringMask,\n  PuzzleStickering,\n  StickeringManager,\n  PieceSet,\n  PieceStickering,\n} from \"./mask\";\n\nexport async function ftoStickering(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const experimentalFTO_FC = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.or(m.moves([\"F\", \"BL\", \"BR\"])))]);\n  const experimentalFTO_F2T = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.move(\"F\"))]);\n  const experimentalFTO_SC = (): PieceSet =>\n    m.or([\n      experimentalFTO_F2T(),\n      m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"BL\", \"BR\"])))]),\n    ]);\n  const experimentalFTO_L2C = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"U\"), m.move(\"F\")]),\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n  const experimentalFTO_LBT = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"experimental-fto-fc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_FC()),\n        PieceStickering.Ignored,\n      );\n      break;\n    }\n    case \"experimental-fto-f2t\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_F2T()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_FC(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-sc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_SC()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_F2T(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-l2c\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_L2C()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_SC(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-lbt\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_LBT()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_L2C(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-l3t\": {\n      puzzleStickering.set(experimentalFTO_LBT(), PieceStickering.Dim);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toStickeringMask();\n}\n\nexport async function ftoStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"experimental-fto-fc\",\n    \"experimental-fto-f2t\",\n    \"experimental-fto-sc\",\n    \"experimental-fto-l2c\",\n    \"experimental-fto-lbt\",\n    \"experimental-fto-l3t\",\n  ];\n}\n", "import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  ftoStickering,\n  ftoStickerings,\n} from \"../../stickerings/fto-stickerings\";\n\nclass FTOPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"FTO\",\n      id: \"fto\",\n      fullName: \"Face-Turning Octahedron\",\n      inventedBy: [\"Karl Rohrbach\", \"David Pitcher\"], // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n      inventionYear: 1983, // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n    });\n  }\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return ftoStickering(this, stickering);\n  }\n  stickerings = ftoStickerings;\n  override svg = getCached(async () => {\n    return (\n      await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\")\n    ).ftoSVG;\n  });\n}\n\nexport const fto = new FTOPuzzleLoader();\n", "import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { StickeringMask } from \"./mask\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"./cube-like-stickerings\";\nimport { from } from \"../../vendor/mit/p-lazy/p-lazy\";\n\n// TODO: cache calculations?\nexport async function megaminxStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  // TODO: optimize lookup instead of looking through a list\n  if ((await megaminxStickerings()).includes(stickering)) {\n    return cubeLikeStickeringMask(puzzleLoader, stickering);\n  }\n  console.warn(\n    `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n  );\n  return cubeLikeStickeringMask(puzzleLoader, \"full\");\n}\n\nconst megaminxStickeringListPromise: Promise<string[]> = from(() =>\n  cubeLikeStickeringList(\"megaminx\"),\n);\nexport function megaminxStickerings(): Promise<string[]> {\n  return megaminxStickeringListPromise;\n}\n", "import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  megaminxStickeringMask,\n  megaminxStickerings,\n} from \"../../stickerings/megaminx-stickerings\";\n\nclass MegaminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"megaminx\",\n      fullName: \"Megaminx\",\n      // Too many simultaneous inventors to name.\n      inventionYear: 1981, // Earliest date from https://www.jaapsch.net/puzzles/megaminx.htm\n    });\n  }\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return megaminxStickeringMask(this, stickering);\n  }\n  stickerings = megaminxStickerings;\n\n  llSVG = getCached(async () => {\n    return (\n      await import(\"../dynamic/megaminx/puzzles-dynamic-megaminx\")\n    ).megaminxLLSVG;\n  });\n}\n\nexport const megaminx = new MegaminxPuzzleLoader();\n", "import { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\nclass PyraminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"pyraminx\",\n      fullName: \"Pyraminx\",\n      inventedBy: [\"Uwe Meffert\"],\n    });\n  }\n  override svg = getCached(async () => {\n    return (\n      await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n    ).pyraminxSVG;\n  });\n}\n\nexport const pyraminx = new PyraminxPuzzleLoader();\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const square1: PuzzleLoader = {\n  id: \"square1\",\n  fullName: \"Square-1\",\n  inventedBy: [\"Karel Hr\u0161el\", \"Vojtech Kopsk\u00FD\"],\n  inventionYear: 1990, // Czech patent application year: http://spisy.upv.cz/Patents/FullDocuments/277/277266.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .sq1HyperOrbitJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n    ).sq1HyperOrbitSVG;\n  }),\n};\n", "import type { PuzzleLoader } from \"../..\";\nimport type { Move } from \"../../../alg\";\nimport { KPuzzle, KTransformationData } from \"../../../kpuzzle\";\nimport type { ExperimentalPGNotation } from \"../../../puzzle-geometry\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\n// TODO: Make this consistent with Megaminx corners\nexport const kilominx: PuzzleLoader = {\n  id: \"kilominx\",\n  fullName: \"Kilominx\",\n  kpuzzle: getCached(async () => {\n    const pg = await asyncGetPuzzleGeometry(\"megaminx + chopasaurus\");\n    const kpuzzleDefinition = JSON.parse(\n      JSON.stringify(pg.getKPuzzleDefinition(true)),\n    );\n    delete kpuzzleDefinition.orbits.CENTERS;\n    delete kpuzzleDefinition.orbits.CENTERS2;\n    delete kpuzzleDefinition.startStateData.CENTERS;\n    delete kpuzzleDefinition.startStateData.CENTERS2;\n    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {\n      delete (moveDefinition as any).CENTERS;\n      delete (moveDefinition as any).CENTERS2;\n    }\n    kpuzzleDefinition.name = \"kilominx\";\n    delete kpuzzleDefinition.experimentalPuzzleDescription;\n    const puzzleGeometry = await import(\"../../../puzzle-geometry\");\n    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n      pg,\n      pg.getOrbitsDef(true),\n    );\n    const kpuzzle = new KPuzzle(kpuzzleDefinition, {\n      experimentalPGNotation: {\n        lookupMove: (move: Move): KTransformationData | null => {\n          if (move.toString() === \"x2\" || move.toString() === \"x2'\") {\n            return x2Transformation.transformationData;\n          }\n          return pgNotation.lookupMove(move);\n        },\n      } as ExperimentalPGNotation,\n    });\n    const x2Transformation = kpuzzle.algToTransformation(\"Rv2 Fv Uv'\");\n    kpuzzleDefinition.moves[\"x2\"] = x2Transformation;\n    return kpuzzle;\n  }),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\")\n    ).kilominxSVG;\n  }),\n};\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const rediCube: PuzzleLoader = {\n  id: \"redi_cube\",\n  fullName: \"Redi Cube\",\n  // Announced 2009-07-21: https://www.youtube.com/watch?v=cjfMzA1u3vM\n  // https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1520\n  inventedBy: [\"Oskar van Deventer\"],\n  inventionYear: 2009,\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n          .rediCubeJSON,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .rediCubeSVG;\n  },\n};\n", "import { CubePGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nconst cube4x4x4: PuzzleLoader = new CubePGPuzzleLoader({\n  id: \"4x4x4\",\n  fullName: \"4\u00D74\u00D74 Cube\",\n});\n\ncube4x4x4.llSVG = getCached(async () => {\n  return (\n    await import(\"../dynamic/4x4x4/puzzles-dynamic-4x4x4\")\n  ).cube4x4x4LLSVG;\n});\n\nexport { cube4x4x4 };\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const melindas2x2x2x2: PuzzleLoader = {\n  id: \"melindas2x2x2x2\",\n  fullName: \"Melinda's 2\u00D72\u00D72\u00D72\",\n  inventedBy: [\"Melinda Green\"],\n  // inventionYear: 20__, // TODO\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .melindas2x2x2x2OrbitJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (\n      await import(\"../dynamic/side-events/puzzles-dynamic-side-events\")\n    ).melindas2x2x2x2OrbitSVG;\n  }),\n};\n", "export { eventInfo, wcaEventInfo, wcaEvents, twizzleEvents } from \"./events\";\nexport type { PuzzleLoader };\nexport { cube2x2x2, cube3x3x3 };\n\nimport { CubePGPuzzleLoader, PGPuzzleLoader } from \"./async/async-pg3d\";\nimport { cube2x2x2 } from \"./implementations/2x2x2\";\nimport { cube3x3x3 } from \"./implementations/3x3x3\";\nimport { clock } from \"./implementations/clock\";\nimport { fto } from \"./implementations/fto\";\nimport { megaminx } from \"./implementations/megaminx\";\nimport { pyraminx } from \"./implementations/pyraminx\";\nimport { square1 } from \"./implementations/square1\";\nimport { kilominx } from \"./implementations/kilominx\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\nimport { rediCube } from \"./implementations/redi-cube\";\nimport { cube4x4x4 } from \"./implementations/4x4x4\";\nimport { melindas2x2x2x2 } from \"./implementations/melindas2x2x2x2\";\n\n/** @category All Puzzles */\nexport const puzzles: Record<string, PuzzleLoader> = {\n  /******** Start of WCA Puzzles *******/\n  \"3x3x3\": cube3x3x3,\n  \"2x2x2\": cube2x2x2,\n  \"4x4x4\": cube4x4x4,\n  \"5x5x5\": new CubePGPuzzleLoader({ id: \"5x5x5\", fullName: \"5\u00D75\u00D75 Cube\" }),\n  \"6x6x6\": new CubePGPuzzleLoader({ id: \"6x6x6\", fullName: \"6\u00D76\u00D76 Cube\" }),\n  \"7x7x7\": new CubePGPuzzleLoader({ id: \"7x7x7\", fullName: \"7\u00D77\u00D77 Cube\" }),\n  \"40x40x40\": new CubePGPuzzleLoader({\n    id: \"40x40x40\",\n    fullName: \"40\u00D740\u00D740 Cube\",\n  }),\n  // 3x3x3 Blindfolded\n  // 3x3x3 Fewest Moves\n  // 3x3x3 One-Handed\n  clock,\n  megaminx: megaminx,\n  pyraminx,\n  skewb: new PGPuzzleLoader({\n    id: \"skewb\",\n    fullName: \"Skewb\",\n    inventedBy: [\"Tony Durham\"], // https://www.jaapsch.net/puzzles/skewb.htm\n    // inventionYear: 1982, // 1982 is actually the year of Hofstadter's column.\n  }),\n  square1,\n  // 4x4x4 Blindfolded\n  // 5x5x5 Blindfolded\n  /******** End of WCA puzzles ********/\n  fto: fto,\n  gigaminx: new PGPuzzleLoader({\n    id: \"gigaminx\",\n    fullName: \"Gigaminx\",\n    inventedBy: [\"Tyler Fox\"],\n    inventionYear: 2006, // Earliest date from https://www.twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1475\n  }),\n  master_tetraminx: new PGPuzzleLoader({\n    pgID: \"master tetraminx\",\n    id: \"master_tetraminx\",\n    fullName: \"Master Tetraminx\",\n    inventedBy: [\"Katsuhiko Okamoto\"], // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n    inventionYear: 2002, // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n  }),\n  kilominx,\n  redi_cube: rediCube,\n  melindas2x2x2x2,\n};\n"],
  "mappings": "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",
  "names": ["combineTransformationData", "definition", "transformationData1", "transformationData2", "newTransformationData", "orbitName", "orbitDefinition", "orbit1", "orbit2", "isOrbitTransformationDataIdentityUncached", "newPerm", "idx", "newOri", "applyTransformationDataToStateData", "stateData", "transformationData", "newStateData", "newPieces", "isOrbitTransformationDataIdentityUncached", "numOrientations", "orbitTransformationData", "permutation", "numPieces", "idx", "orientation", "isOrbitTransformationDataIdentical", "orbitDefinition", "orbitTransformationData1", "orbitTransformationData2", "options", "isTransformationDataIdentical", "kpuzzle", "transformationData1", "transformationData2", "orbitName", "invertTransformation", "transformationData", "newTransformationData", "newPerm", "newOri", "fromIdx", "repeatTransformationUncached", "amount", "halfish", "twiceHalfish", "combineTransformationData", "AlgToTransformationTraversal", "TraversalDownUp", "alg", "transformation", "algNode", "grouping", "algTransformation", "KTransformation", "move", "commutator", "aTransformation", "bTransformation", "conjugate", "_", "algToTransformation", "functionFromTraversal", "gcd", "a", "b", "transformationRepetitionOrder", "definition", "transformation", "order", "orbitName", "orbitDefinition", "transformationOrbit", "orbitPieces", "startIdx", "currentIdx", "orientationSum", "cycleLength", "FREEZE", "identityOrbitCache", "constructIdentityOrbitTransformation", "numPieces", "cached", "newPermutation", "newOrientation", "i", "orbitTransformation", "constructIdentityTransformationDataUncached", "definition", "transformation", "orbitName", "orbitDefinition", "moveToTransformationUncached", "kpuzzle", "move", "quantumKey", "quantumMoveDefinition", "derivedFrom", "repeatTransformationUncached", "moveDefinition", "inverseMoveDefinition", "KState", "kpuzzle", "stateData", "transformation", "newStateData", "applyTransformationDataToStateData", "source", "move", "alg", "transformationData", "orbitName", "stateOrbitData", "transformationOrbit", "KTransformation", "options", "KTransformation", "kpuzzle", "transformationData", "invertTransformation", "#cachedIsIdentity", "transformation", "constructIdentityTransformationDataUncached", "t2", "isTransformationDataIdentical", "source", "combineTransformationData", "move", "alg", "KState", "transformationRepetitionOrder", "amount", "repeatTransformationUncached", "KPuzzle", "definition", "options", "#moveToTransformationDataCache", "KTransformation", "move", "Move", "cacheKey", "cachedTransformationData", "transformationData", "moveToTransformationUncached", "alg", "Alg", "algToTransformation", "source", "KState", "#cachedCanConvertStateToUniqueTransformation", "orbitName", "orbitDefinition", "pieces", "piece", "getFaceletStickeringMask", "stickeringMask", "orbitName", "pieceIdx", "faceletIdx", "hint", "pieceStickeringMask", "regular", "faceletStickeringMask", "PieceAnnotation", "kpuzzle", "defaultValue", "orbitName", "orbitDef", "regular", "ignored", "oriented", "invisible", "dim", "pieceStickerings", "getPieceStickeringMask", "pieceStickering", "PuzzleStickering", "pieceSet", "pieces", "i", "stickeringMask", "orbitStickeringMask", "StickeringManager", "pieceSets", "newPieceSet", "pieceLoop", "moveSource", "transformation", "moveSources", "orbitNames", "orbitPrefix", "LL", "LS", "megaAnd3x3x3LL", "megaAnd3x3x3LS", "experimentalStickerings", "cubeLikeStickeringMask", "puzzleLoader", "stickering", "kpuzzle", "puzzleStickering", "PuzzleStickering", "m", "StickeringManager", "LL", "orUD", "orLR", "M", "F2L", "CENTERS", "EDGES", "CORNERS", "L6E", "centerLL", "edgeFR", "cornerDFR", "slotFR", "dimF2L", "setPLL", "setOLL", "dimOLL", "cubeLikeStickeringList", "puzzleID", "options", "stickerings", "stickeringsFallback", "name", "info", "experimentalStickerings", "getCached", "getValue", "cachedPromise", "PLazy", "executor", "resolve", "function_", "value", "error", "_resolve", "reject", "onFulfilled", "onRejected", "from", "asyncGetPuzzleGeometry", "puzzleName", "asyncGetKPuzzle", "pgPromise", "pg", "kpuzzleDefinition", "puzzleGeometry", "pgNotation", "KPuzzle", "PGPuzzleLoader", "info", "puzzleSpecificSimplifyOptionsPromise", "#cachedPG", "asyncGetPuzzleGeometry", "#cachedKPuzzle", "asyncGetKPuzzle", "#cachedSVG", "CubePGPuzzleLoader", "cubeLikeStickeringList", "stickering", "cubeLikeStickeringMask", "kpuzzlePromiseFn", "PLazy", "resolve", "kpuzzle", "m", "Move", "cube3x3x3KPuzzleDefinition", "puzzleOrientation3x3x3Idx", "state", "idxU", "idxD", "unadjustedIdxL", "idxL", "puzzleOrientationCacheRaw", "puzzleOrientationCacheInitialized", "puzzleOrientation3x3x3Cache", "uAlgs", "s", "Alg", "yAlg", "uAlg", "transformation", "experimental3x3x3KPuzzle", "i", "normalize3x3x3Orientation", "orientationTransformation", "experimentalIs3x3x3Solved", "options", "KState", "getPartialAppendOptionsForPuzzleSpecificSimplifyOptions", "puzzleLoader", "puzzleSpecificSimplifyOptions", "puzzleOrientation2x2x2Idx", "state", "inverseDFL", "puzzleOrientationCacheRaw", "puzzleOrientationCacheInitialized", "puzzleOrientation2x2x2Cache", "kpuzzle", "uAlgs", "s", "Alg", "yAlg", "uAlg", "transformation", "i", "idx", "normalize2x2x2Orientation", "alg", "descAsyncGetPuzzleGeometry", "desc", "asyncGetKPuzzle", "pg", "kpuzzleDefinition", "puzzleGeometry", "pgNotation", "KPuzzle", "nextCustomID", "customPGPuzzleLoader", "info", "customID", "cachedKPuzzle", "kpuzzlePromiseFn", "puzzleLoader", "puzzleSpecificSimplifyOptionsPromise", "experimental3x3x3KPuzzle", "KPuzzle", "cube3x3x3KPuzzleDefinition", "experimentalIs3x3x3Solved", "makeSourceInfo", "moveStrings", "type", "from", "to", "output", "moveString", "move", "Move", "family", "direction", "axisInfos", "byFamily", "axis", "info", "moveSourceInfo", "byAxisThenType", "_a", "entry", "byAxisThenSpecificSlices", "firstOfType", "moveSourceType", "areQuantumMovesSameAxis", "quantumMove1", "quantumMove2", "simplestMove", "directedAmount", "sliceSpecificInfo", "QuantumMove", "axisInfo", "sliceDiameter", "far", "outerLayer", "innerLayer", "slice", "simplifySameAxisMoves", "moves", "quantumMod", "sliceDeltas", "lastCandidateRange", "adjustValue", "idx", "relativeDelta", "newDelta", "suffixLength", "puzzleSpecificSimplifyOptions333", "cube3x3x3", "getCached", "experimental3x3x3KPuzzle", "asyncGetPuzzleGeometry", "stickering", "cubeLikeStickeringMask", "cubeLikeStickeringList", "puzzleSpecificSimplifyOptions333", "wcaEvents", "twizzleEvents", "wcaEvents", "cube2x2x2", "getCached", "KPuzzle", "asyncGetPuzzleGeometry", "stickering", "cubeLikeStickeringMask", "cubeLikeStickeringList", "clock", "getCached", "KPuzzle", "ftoStickering", "puzzleLoader", "stickering", "kpuzzle", "puzzleStickering", "PuzzleStickering", "m", "StickeringManager", "experimentalFTO_FC", "experimentalFTO_F2T", "experimentalFTO_SC", "experimentalFTO_L2C", "experimentalFTO_LBT", "ftoStickerings", "FTOPuzzleLoader", "PGPuzzleLoader", "ftoStickerings", "getCached", "stickering", "ftoStickering", "fto", "megaminxStickeringMask", "puzzleLoader", "stickering", "megaminxStickerings", "cubeLikeStickeringMask", "megaminxStickeringListPromise", "from", "cubeLikeStickeringList", "MegaminxPuzzleLoader", "PGPuzzleLoader", "megaminxStickerings", "getCached", "stickering", "megaminxStickeringMask", "megaminx", "PyraminxPuzzleLoader", "PGPuzzleLoader", "getCached", "pyraminx", "square1", "getCached", "KPuzzle", "kilominx", "getCached", "pg", "asyncGetPuzzleGeometry", "kpuzzleDefinition", "moveDefinition", "puzzleGeometry", "pgNotation", "kpuzzle", "KPuzzle", "move", "x2Transformation", "rediCube", "getCached", "KPuzzle", "cube4x4x4", "CubePGPuzzleLoader", "getCached", "melindas2x2x2x2", "getCached", "KPuzzle", "puzzles", "cube3x3x3", "cube2x2x2", "cube4x4x4", "CubePGPuzzleLoader", "clock", "megaminx", "pyraminx", "PGPuzzleLoader", "square1", "fto", "kilominx", "rediCube", "melindas2x2x2x2"]
}
