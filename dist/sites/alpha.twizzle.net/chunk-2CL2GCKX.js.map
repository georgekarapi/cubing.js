{
  "version": 3,
  "sources": ["../../../src/cubing/search/inside/solve/tremble.ts", "../../../src/cubing/search/inside/solve/puzzles/dynamic/sgs-side-events/index.ts", "../../../src/cubing/search/inside/solve/twsearch.ts", "../../../src/cubing/search/inside/solve/puzzles/2x2x2.ts", "../../../src/cubing/search/inside/solve/puzzles/dynamic/4x4x4/index.ts", "../../../src/cubing/search/inside/solve/puzzles/4x4x4.ts", "../../../src/cubing/search/inside/solve/puzzles/big-cubes.ts", "../../../src/cubing/search/inside/solve/puzzles/5x5x5.ts", "../../../src/cubing/search/inside/solve/puzzles/dynamic/fto/index.ts", "../../../src/cubing/search/inside/solve/puzzles/fto.ts", "../../../src/cubing/search/inside/solve/puzzles/dynamic/kilominx/index.ts", "../../../src/cubing/search/inside/solve/puzzles/kilominx.ts", "../../../src/cubing/search/inside/solve/puzzles/dynamic/master_tetraminx/index.ts", "../../../src/cubing/search/inside/solve/puzzles/master_tetraminx.ts", "../../../src/cubing/search/inside/solve/puzzles/megaminx.ts", "../../../src/cubing/search/inside/solve/puzzles/pyraminx.ts", "../../../src/cubing/search/inside/solve/puzzles/dynamic/sgs-unofficial/index.ts", "../../../src/cubing/search/inside/solve/puzzles/redi_cube.ts", "../../../src/cubing/search/inside/solve/puzzles/skewb.ts", "../../../src/cubing/search/inside/solve/puzzles/dynamic/sq1/index.ts", "../../../src/cubing/search/inside/solve/puzzles/sq1.ts", "../../../src/cubing/search/inside/api.ts"],
  "sourcesContent": ["import { Alg, AlgBuilder, Move, QuantumMove } from \"../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../kpuzzle\";\nimport type { KState } from \"../../../kpuzzle/KState\";\nimport { experimentalCountMoves } from \"../../../notation\";\nimport { randomChoice } from \"random-uint-below\";\nimport type { SGSCachedData } from \"./parseSGS\";\n\nconst DEFAULT_STAGE1_DEPTH_LIMIT = 2; // Moderately performant default.\n\nconst DOUBLECHECK_PLACED_PIECES = true;\nconst DEBUG = false;\n\n// TODO: Take moves instead of move names?\nfunction calculateMoves(\n  kpuzzle: KPuzzle,\n  moveNames: string[],\n): {\n  move: Move;\n  transformation: KTransformation;\n}[] {\n  const searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[] = [];\n  // const identity = identityTransformation(def); // TODO\n  // TODO: Make it easy to filter moves.\n  moveNames.forEach(function (moveName) {\n    const rootMove = new Move(moveName);\n    if (rootMove.amount !== 1) {\n      throw new Error(\n        \"SGS cannot handle def moves with an amount other than 1 yet.\",\n      );\n    }\n    let transformation = kpuzzle.identityTransformation();\n    for (let i = 1; true; i++) {\n      transformation = transformation.applyMove(rootMove);\n      if (transformation.isIdentityTransformation()) {\n        break;\n      }\n      searchMoves.push({\n        move: rootMove.modified({ amount: i }),\n        transformation,\n      });\n    }\n  });\n  return searchMoves;\n}\n\n// function badRandomMoves(moves: string[], ksp: KSolvePuzzle): KSolvePuzzleState {\n//   // var sum = 0;\n//   var scramble = \"\";\n//   for (var i = 0; i < 1000; i++) {\n//     scramble = scramble + \" \" + moves[Math.floor(moves.length * Math.random())];\n//   }\n//   // var sol = \"\";\n//   const indexer = new TreeAlgIndexer(ksp, Alg.fromString(scramble));\n//   return indexer.transformAtIndex(indexer.numMoves()) as any; // TODO\n// }\n\nexport class TrembleSolver {\n  private searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[];\n\n  constructor(\n    private kpuzzle: KPuzzle,\n    private sgs: SGSCachedData,\n    trembleMoveNames?: string[],\n  ) {\n    this.searchMoves = calculateMoves(\n      this.kpuzzle,\n      trembleMoveNames ?? Object.keys(this.kpuzzle.definition.moves),\n    );\n  }\n\n  // public badRandomMoves(): KSolvePuzzleState {\n  //   return badRandomMoves(this.moves, this.ksp);\n  // }\n\n  public async solve(\n    state: KState,\n    stage1DepthLimit: number = DEFAULT_STAGE1_DEPTH_LIMIT,\n    quantumMoveOrder?: (quantumMove: QuantumMove) => number,\n  ): Promise<Alg> {\n    const transformation = state.experimentalToTransformation();\n    if (!transformation) {\n      throw new Error(\n        \"distinguishable pieces are not supported in tremble solver yt\",\n      );\n    }\n    let bestAlg: Alg | null = null;\n    let bestLen = 1000000;\n    const recur = (\n      recursiveTransformation: KTransformation, // TODO: Support KStatq1\n      togo: number,\n      sofar: Alg,\n    ) => {\n      // console.log(\"recur\");\n      if (togo === 0) {\n        const sgsAlg = this.sgsPhaseSolve(recursiveTransformation, bestLen);\n        if (!sgsAlg) {\n          return;\n        }\n        // console.log(\"sgs done!\", sofar.toString(), \"|\", sgsAlg.toString());\n        const newAlg = sofar.concat(sgsAlg).experimentalSimplify({\n          cancel: { puzzleSpecificModWrap: \"canonical-centered\" },\n          puzzleSpecificSimplifyOptions: { quantumMoveOrder },\n        });\n\n        const len = experimentalCountMoves(newAlg);\n        if (bestAlg === null || len < bestLen) {\n          if (DEBUG) {\n            console.log(`New best (${len} moves): ${newAlg.toString()}`);\n            console.log(`Tremble moves are: ${sofar.toString()}`);\n          }\n          bestAlg = newAlg;\n          bestLen = len;\n        }\n        return;\n      }\n      for (const searchMove of this.searchMoves) {\n        recur(\n          recursiveTransformation.applyTransformation(\n            searchMove.transformation,\n          ),\n          togo - 1,\n          sofar.concat([searchMove.move]),\n        );\n      }\n    };\n    for (let d = 0; d <= stage1DepthLimit; d++) {\n      recur(transformation, d, new Alg());\n    }\n    if (bestAlg === null) {\n      throw new Error(\"SGS search failed.\");\n    }\n    return bestAlg;\n  }\n\n  private sgsPhaseSolve(\n    initialTransformation: KTransformation, // TODO: Handle KState\n    bestLenSofar: number,\n  ): Alg | null {\n    // const pieceNames = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\n\n    // function loggo(s: string) {\n    //   // console.warn(s);\n    //   // document.body.appendChild(document.createElement(\"div\")).textContent = s;\n    // }\n\n    // console.log(\"sgsPhaseSolve\");\n    const algBuilder = new AlgBuilder();\n    let transformation = initialTransformation;\n    for (const step of this.sgs.ordering) {\n      const cubieSeq = step.pieceOrdering;\n      let key = \"\";\n      const inverseTransformation = transformation.invert();\n      for (let i = 0; i < cubieSeq.length; i++) {\n        const loc = cubieSeq[i];\n        const orbitName = loc.orbitName;\n        const idx = loc.permutationIdx;\n        key += ` ${inverseTransformation.transformationData[orbitName].permutation[idx]} ${inverseTransformation.transformationData[orbitName].orientation[idx]}`;\n      }\n      // console.log(key, step.lookup);\n      const info = step.lookup[key];\n      if (!info) {\n        throw new Error(\"Missing algorithm in sgs or esgs?\");\n      }\n      algBuilder.experimentalPushAlg(info.alg);\n      if (algBuilder.experimentalNumAlgNodes() >= bestLenSofar) {\n        return null;\n      }\n      transformation = transformation.applyTransformation(info.transformation);\n      if (DOUBLECHECK_PLACED_PIECES) {\n        for (let i = 0; i < cubieSeq.length; i++) {\n          const location = cubieSeq[i];\n          const orbitName = location.orbitName;\n          const idx = location.permutationIdx;\n          if (\n            transformation.transformationData[orbitName].permutation[idx] !==\n              idx ||\n            transformation.transformationData[orbitName].orientation[idx] !== 0\n          ) {\n            throw new Error(\"bad SGS :-(\");\n          }\n        }\n      }\n    }\n    return algBuilder.toAlg();\n  }\n}\n\nexport function randomStateFromSGS(\n  kpuzzle: KPuzzle,\n  sgs: SGSCachedData,\n): KState {\n  let transformation = kpuzzle.identityTransformation();\n  for (const step of sgs.ordering) {\n    const sgsAction = randomChoice(Object.values(step.lookup));\n    transformation = transformation.applyTransformation(\n      sgsAction.transformation,\n    );\n  }\n  return transformation.toKState();\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicSideEvents = from<\n  typeof import(\"./search-dynamic-sgs-side-events\")\n>(() => import(\"./search-dynamic-sgs-side-events\"));\n", "import type { Alg } from \"../../../alg\";\nimport {\n  KPuzzle,\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"../../../kpuzzle\";\nimport { from } from \"../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const twsearchPromise: Promise<\n  typeof import(\"../../../vendor/mpl/twsearch\")\n> = from(async () => import(\"../../../vendor/mpl/twsearch\"));\n\nexport interface TwsearchOptions {\n  moveSubset?: string[];\n  startState?: KTransformationData;\n  minDepth?: number;\n  maxDepth?: number;\n}\n\nlet existingPuzzleDefString: undefined | string;\nlet existingMoveSubsetString: undefined | string;\n\nfunction mustBeNaturalNumber(meaning: string, n: number): void {\n  if (typeof n !== \"number\" || !Number.isInteger(n) || n < 0) {\n    throw new Error(`Invalid ${meaning}: ${n}`);\n  }\n}\n\nexport async function solveTwsearch(\n  def: KPuzzleDefinition,\n  stateData: KTransformationData,\n  options?: TwsearchOptions,\n): Promise<Alg> {\n  const {\n    setArg,\n    setKPuzzleDefString,\n    serializeDefToTws,\n    solveState,\n    serializeKTransformationDataToTws,\n  } = await twsearchPromise;\n  const kpuzzle = new KPuzzle(def);\n  setArg(\"--startprunedepth 5\"); // TODO\n  let moveSubsetString = \"\"; // TODO: pass the full set of moves, to avoid rotations not being treated as moves.\n  if (options) {\n    if (options.moveSubset) {\n      moveSubsetString = options?.moveSubset?.join(\",\");\n      // TODO: better, reusable validation\n      if (moveSubsetString.includes(\" \")) {\n        throw new Error(\"A move contains a space\u203D\");\n      }\n      if (moveSubsetString.includes(\"-\")) {\n        throw new Error(\"A move contains a dash\");\n      }\n      setArg(`--moves ${moveSubsetString}`); // TODO: remove the need for this.\n    }\n    let { minDepth, maxDepth } = options;\n    if (typeof minDepth !== \"undefined\") {\n      mustBeNaturalNumber(\"minDepth\", minDepth);\n      if (typeof maxDepth !== \"undefined\") {\n        mustBeNaturalNumber(\"maxDepth\", maxDepth);\n      } else {\n        maxDepth = 1000000;\n      }\n\n      setArg(\"--randomstart\");\n      setArg(`--mindepth ${minDepth}`);\n      setArg(`--maxdepth ${maxDepth}`);\n    } else if (typeof maxDepth !== \"undefined\") {\n      mustBeNaturalNumber(\"maxDepth\", maxDepth);\n      setArg(\"--mindepth 0\");\n      setArg(`--maxdepth ${maxDepth}`);\n    }\n  }\n\n  const puzzleDefString = serializeDefToTws(kpuzzle, options);\n  if (existingPuzzleDefString) {\n    if (existingPuzzleDefString !== puzzleDefString) {\n      throw new Error(\n        \"Attempted to solve two puzzles in the same worker using `twsearch`. This is not currently supported!\",\n      );\n    }\n  } else {\n    existingPuzzleDefString = puzzleDefString;\n    await setKPuzzleDefString(puzzleDefString);\n  }\n\n  if (\n    typeof existingMoveSubsetString !== \"undefined\" &&\n    moveSubsetString !== existingMoveSubsetString\n  ) {\n    throw new Error(\n      \"Attempted to solve two different move subsets in the same worker using `twsearch`. This is not currently supported!\",\n    );\n  }\n\n  return await solveState(\n    serializeKTransformationDataToTws(\"SearchState\", stateData, true),\n  );\n}\n", "import { Alg, Move } from \"../../../../alg\";\nimport type { KPuzzle } from \"../../../../kpuzzle\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { cube2x2x2, puzzles } from \"../../../../puzzles\";\nimport { randomPermuteInPlace, randomUIntBelow } from \"random-uint-below\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\nimport { solveTwsearch, twsearchPromise } from \"../twsearch\";\nimport { experimentalNormalize2x2x2Orientation } from \"../../../../puzzles/cubing-private\";\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgsCachedData: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedData222();\n      return new TrembleSolver(\n        await puzzles[\"2x2x2\"].kpuzzle(),\n        sgsCachedData,\n        \"URFLBD\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitialize222(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solve222HTMSubOptimal(\n  state: KState,\n  maxDepth: number = 11,\n): Promise<Alg> {\n  mustBeInsideWorker();\n  return await solveTwsearch(\n    (\n      await cube2x2x2.kpuzzle()\n    ).definition,\n    state.experimentalToTransformation()!.transformationData,\n    {\n      moveSubset: \"UFLR\".split(\"\"), // TODO: <U, F, R>\n      maxDepth,\n    },\n  );\n}\n\n// TODO: fix def consistency.\n// TODO: why is this ending up with the wrong rotation sometimes?\nexport async function solve222HTMOptimal(\n  state: KState,\n  maxDepth: number = 11,\n): Promise<Alg> {\n  mustBeInsideWorker();\n  const { normalizedState, normalizationAlg } =\n    experimentalNormalize2x2x2Orientation(state);\n  const orientedResult = await solveTwsearch(\n    (\n      await cube2x2x2.kpuzzle()\n    ).definition,\n    normalizedState.experimentalToTransformation()!.transformationData,\n    {\n      moveSubset: \"UFLR\".split(\"\"), // TODO: <U, F, R>\n      maxDepth,\n    },\n  );\n  return normalizationAlg.concat(orientedResult);\n}\n\nasync function hasHTMSolutionWithFewerMoves(\n  state: KState,\n  filterMin: number,\n): Promise<boolean> {\n  try {\n    (await solve222HTMOptimal(state, filterMin - 1)).log();\n    return true;\n  } catch (e) {\n    if (e instanceof (await twsearchPromise).NoSolutionError) {\n      return false;\n    }\n    throw e;\n  }\n}\n\nfunction isCancelling(alg: Alg): boolean {\n  let lastFamily: undefined | string;\n  for (const node of alg.childAlgNodes()) {\n    const move = node.as(Move);\n    if (!move) {\n      throw new Error(\"Unexpected solution with a non-move node!\");\n    }\n    const { family } = move;\n    if (\n      lastFamily &&\n      ((lastFamily === \"L\" && family === \"R\") ||\n        (lastFamily === \"R\" && family === \"L\"))\n    ) {\n      return true;\n    }\n    lastFamily = family;\n  }\n  return false;\n}\n\n// TODO: fix def consistency.\nexport async function solve222ForScramble(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  return solveTwsearch(\n    (await cube2x2x2.kpuzzle()).definition,\n    state.experimentalToTransformation()!.transformationData,\n    {\n      moveSubset: \"UFLR\".split(\"\"),\n      minDepth: 11,\n    },\n  );\n}\n\n// TODO: factor out and test.\nfunction mutatingRandomizeOrbit(\n  kpuzzle: KPuzzle,\n  orbitName: string,\n  state: KState,\n  options?: { orientationSum?: number },\n): void {\n  randomPermuteInPlace(state.stateData[orbitName].pieces);\n\n  const orbitDef = kpuzzle.definition.orbits[orbitName];\n  const ori = state.stateData[orbitName].orientation;\n\n  let sum = 0;\n  for (let i = 0; i < orbitDef.numPieces; i++) {\n    const o = randomUIntBelow(orbitDef.numOrientations);\n    ori[i] = o;\n    sum += o;\n  }\n\n  // console.log(\"aaaa\", options && \"orientationSum\" in options);\n  if (options && \"orientationSum\" in options) {\n    // console.log(\"sfdsf\", options!.orientationSum),\n    ori[0] =\n      (((ori[0] + options.orientationSum! - sum) % orbitDef.numOrientations) +\n        orbitDef.numOrientations) %\n      orbitDef.numOrientations;\n  }\n}\n\n// TODO: Use SGS?\nexport async function random222State(): Promise<KState> {\n  const kpuzzle = await puzzles[\"2x2x2\"].kpuzzle();\n  const stateCopy: KState = new KState(\n    kpuzzle,\n    JSON.parse(JSON.stringify(kpuzzle.startState().stateData)),\n  ); // TODO\n  mutatingRandomizeOrbit(kpuzzle, \"CORNERS\", stateCopy, {\n    orientationSum: 0,\n  });\n  return stateCopy;\n}\n\nexport async function random222Scramble(): Promise<Alg> {\n  let state = await random222State();\n  while (await hasHTMSolutionWithFewerMoves(state, 4)) {\n    console.info(\"Filtered out a 2x2x2 state!\");\n    state = await random222State();\n  }\n  const inverseState = state\n    .experimentalToTransformation()!\n    .invert()\n    .toKState(); // Note: Inversion is not needed for randomness, but it is more consistent with other code.\n  let sol = await solve222ForScramble(inverseState);\n  while (isCancelling(sol)) {\n    // Rely on `--randomstart` to find us a non-cancelling with \u22482/3 probability.\n    // TODO: Check that this works for 100% of states.\n    sol = await solve222ForScramble(inverseState);\n  }\n\n  return sol;\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamic4x4x4Solver = from<\n  typeof import(\"./search-dynamic-solve-4x4x4\")\n>(() => import(\"./search-dynamic-solve-4x4x4\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { dynamic4x4x4Solver } from \"./dynamic/4x4x4\";\n\nconst randomSuffixes = [\n  [null, \"x\", \"x2\", \"x'\", \"z\", \"z'\"],\n  [null, \"y\", \"y2\", \"y'\"],\n];\n\nexport async function initialize444(): Promise<void> {\n  return (await dynamic4x4x4Solver).initialize();\n}\n\nexport async function random444Scramble(): Promise<Alg> {\n  return (await dynamic4x4x4Solver).random444Scramble();\n}\n\nexport async function random444OrientedScramble(): Promise<Alg> {\n  return addOrientationSuffix(await random444Scramble(), randomSuffixes);\n}\n", "import { Alg, AlgBuilder, Move, QuantumMove } from \"../../../../alg\";\nimport { randomChoice, randomUIntBelow } from \"random-uint-below\";\n\nfunction numMoves(n: number): number {\n  switch (n) {\n    case 5:\n      return 60;\n    case 6:\n      return 80;\n    default:\n      return 100;\n  }\n}\n\nconst axesFaces = [\n  [\"U\", \"D\"],\n  [\"L\", \"R\"],\n  [\"F\", \"B\"],\n];\nconst axesMovesCache: Map<number, QuantumMove[][]> = new Map();\nfunction cachedAxesMoves(n: number): QuantumMove[][] {\n  const existing = axesMovesCache.get(n);\n  if (existing) {\n    return existing;\n  }\n  const axesMoves = [];\n  for (const faces of axesFaces) {\n    const axisMoveFamilies: QuantumMove[] = [];\n    axesMoves.push(axisMoveFamilies);\n\n    for (const face of faces) {\n      axisMoveFamilies.push(new QuantumMove(face));\n      if (n > 3) {\n        axisMoveFamilies.push(new QuantumMove(`${face}w`));\n      }\n      for (let i = 3; i <= n / 2; i++) {\n        axisMoveFamilies.push(new QuantumMove(`${face}w`, i));\n      }\n    }\n  }\n  axesMovesCache.set(n, axesMoves);\n  return axesMoves;\n}\n\n// TODO: Document this algorithm and compare to TNoodle.\nexport async function bigCubeRandomMoves(n: number): Promise<Alg> {\n  const axesMoves = cachedAxesMoves(n);\n\n  const cachedNumMoves = numMoves(n);\n  const algBuilder = new AlgBuilder();\n  let currentAxisIdx = 0;\n  const currentAxisQuantumMoves = new Set();\n  while (algBuilder.experimentalNumAlgNodes() < cachedNumMoves) {\n    const newAxisIdx = randomUIntBelow(3);\n    if (newAxisIdx !== currentAxisIdx) {\n      currentAxisQuantumMoves.clear();\n    }\n    currentAxisIdx = newAxisIdx;\n\n    const quantumMove = randomChoice(axesMoves[currentAxisIdx]);\n    const quantumMoveStr = quantumMove.toString();\n    if (currentAxisQuantumMoves.has(quantumMoveStr)) {\n      // Skip duplicates and resample with replacement.\n      continue;\n    }\n    currentAxisQuantumMoves.add(quantumMoveStr);\n    algBuilder.push(new Move(quantumMove, randomChoice([1, 2, -1])));\n  }\n\n  return algBuilder.toAlg();\n}\n", "import type { Alg } from \"../../../../alg\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { bigCubeRandomMoves } from \"./big-cubes\";\n\nconst randomSuffixes = [\n  [null, \"3Rw\", \"3Rw2\", \"3Rw'\", \"3Fw\", \"3Fw'\"],\n  [null, \"3Dw\", \"3Dw2\", \"3Dw'\"],\n];\n\nexport async function oriented555RandomMoves(): Promise<Alg> {\n  return addOrientationSuffix(await bigCubeRandomMoves(5), randomSuffixes);\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicFTOSolver = from<\n  typeof import(\"./search-dynamic-solve-fto\")\n>(() => import(\"./search-dynamic-solve-fto\"));\n", "import { Alg } from \"../../../../alg\";\nimport type { KState } from \"../../../../kpuzzle/KState\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { from } from \"../../../../vendor/mit/p-lazy/p-lazy\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { dynamicFTOSolver } from \"./dynamic/fto\";\n\nconst dynamic = from<\n  typeof import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\")\n>(() => import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\"));\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (await dynamic).sgsDataFTO();\n      return new TrembleSolver(await puzzles[\"fto\"].kpuzzle(), json, [\n        \"U\",\n        \"R\",\n        \"F\",\n        \"L\",\n        \"D\",\n        \"B\",\n        \"BR\",\n        \"BL\",\n      ]);\n    })())\n  );\n}\n\nexport async function preInitializeFTO(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveFTO(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    state,\n    TREMBLE_DEPTH,\n    () => 3, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomFTOScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(await (await dynamicFTOSolver).randomFTOScrambleString());\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicKilominxSolver = from<\n  typeof import(\"./search-dynamic-solve-kilominx\")\n>(() => import(\"./search-dynamic-solve-kilominx\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicKilominxSolver } from \"./dynamic/kilominx\";\n\nexport async function randomKilominxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await dynamicKilominxSolver).getRandomKilominxScramble();\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicMasterTetraminxSolver = from<\n  typeof import(\"./search-dynamic-solve-master_tetraminx\")\n>(() => import(\"./search-dynamic-solve-master_tetraminx\"));\n", "import { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicMasterTetraminxSolver } from \"./dynamic/master_tetraminx\";\n\nexport async function randomMasterTetraminxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(\n    await (\n      await dynamicMasterTetraminxSolver\n    ).randomMasterTetraminxScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KStateData } from \"../../../../kpuzzle\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 2;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedSGSDataMegaminx();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n        json,\n        [\"U\", \"R\", \"F\", \"L\", \"BR\", \"BL\", \"FR\", \"FL\", \"DR\", \"DL\", \"B\", \"D\"],\n      );\n    })())\n  );\n}\n\nexport async function preInitializeMegaminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveMegaminx(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const stateDataWithoutMO: KStateData = JSON.parse(\n    JSON.stringify(state.stateData),\n  );\n  stateDataWithoutMO.CENTERS.orientation = new Array(12).fill(0);\n  const stateWithoutMO = new KState(\n    await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n    stateDataWithoutMO,\n  );\n  const alg = await trembleSolver.solve(\n    stateWithoutMO,\n    TREMBLE_DEPTH,\n    () => 5, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KState } from \"../../../../kpuzzle/KState\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomStateFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataPyraminx();\n      return new TrembleSolver(\n        await puzzles.pyraminx.kpuzzle(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializePyraminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solvePyraminx(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(state, TREMBLE_DEPTH, () => 3); // TODO: Attach quantum move order lookup to puzzle.\n  return alg;\n}\n\nexport async function randomPyraminxStateFixedOrientation(): Promise<KState> {\n  mustBeInsideWorker();\n  // Note: this sets all center orientations to 0.\n  return randomStateFromSGS(\n    await puzzles.pyraminx.kpuzzle(),\n    await (await searchDynamicSideEvents).sgsDataPyraminxFixedOrientation(),\n  );\n}\n\nexport async function randomPyraminxScrambleFixedOrientation(): Promise<Alg> {\n  return solvePyraminx(await randomPyraminxStateFixedOrientation());\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicUnofficial = from<\n  typeof import(\"./search-dynamic-sgs-unofficial\")\n>(() => import(\"./search-dynamic-sgs-unofficial\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { searchDynamicUnofficial } from \"./dynamic/sgs-unofficial\";\n\nexport async function randomRediCubeScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await searchDynamicUnofficial).getRandomRediCubeScramble();\n}\n", "import type { Alg, QuantumMove } from \"../../../../alg\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomStateFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataSkewb();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializeSkewb(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nasync function resetCenterOrientation(state: KState): Promise<KState> {\n  return new KState(\n    await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n    {\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    },\n  );\n}\n\n// TODO: fix def consistency.\nexport async function solveSkewb(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    await resetCenterOrientation(state),\n    TREMBLE_DEPTH,\n    (quantumMove: QuantumMove) => (quantumMove.family === \"y\" ? 4 : 3), // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomSkewbFixedCornerState(): Promise<KState> {\n  // Note: this sets all center orientations to 0.\n  return randomStateFromSGS(\n    await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n    await (await searchDynamicSideEvents).sgsDataSkewbFixedCorner(),\n  );\n}\n\nexport async function randomSkewbFixedCornerScramble(): Promise<Alg> {\n  return solveSkewb(await randomSkewbFixedCornerState());\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicSq1Solver = from<\n  typeof import(\"./search-dynamic-solve-sq1\")\n>(() => import(\"./search-dynamic-solve-sq1\"));\n", "import { Alg } from \"../../../../alg\";\nimport { dynamicSq1Solver } from \"./dynamic/sq1\";\n\nexport async function getRandomSquare1Scramble(): Promise<Alg> {\n  return Alg.fromString(\n    await (await dynamicSq1Solver).getRandomSquare1ScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../alg\";\nimport {\n  KPuzzleDefinition,\n  KState,\n  KStateData,\n  KTransformationData,\n} from \"../../kpuzzle\";\nimport { puzzles } from \"../../puzzles\";\nimport { setIsInsideWorker } from \"./inside-worker\";\nimport {\n  preInitialize222,\n  random222Scramble,\n  solve222HTMSubOptimal,\n} from \"./solve/puzzles/2x2x2\";\nimport {\n  initialize333,\n  random333FewestMovesScramble,\n  random333OrientedScramble,\n  random333Scramble,\n  solve333,\n} from \"./solve/puzzles/3x3x3\";\nimport {\n  initialize444,\n  random444OrientedScramble,\n  random444Scramble,\n} from \"./solve/puzzles/4x4x4\";\nimport { oriented555RandomMoves } from \"./solve/puzzles/5x5x5\";\nimport { bigCubeRandomMoves } from \"./solve/puzzles/big-cubes\";\nimport { randomFTOScramble } from \"./solve/puzzles/fto\";\nimport { randomKilominxScramble } from \"./solve/puzzles/kilominx\";\nimport { randomMasterTetraminxScramble } from \"./solve/puzzles/master_tetraminx\";\nimport { solveMegaminx } from \"./solve/puzzles/megaminx\";\nimport {\n  randomPyraminxScrambleFixedOrientation,\n  solvePyraminx,\n} from \"./solve/puzzles/pyraminx\";\nimport { randomRediCubeScramble } from \"./solve/puzzles/redi_cube\";\nimport {\n  randomSkewbFixedCornerScramble,\n  solveSkewb,\n} from \"./solve/puzzles/skewb\";\nimport { getRandomSquare1Scramble } from \"./solve/puzzles/sq1\";\nimport { solveTwsearch, TwsearchOptions } from \"./solve/twsearch\";\n\nconst IDLE_PREFETCH_TIMEOUT_MS = 1000;\n\nsetIsInsideWorker(true);\n\nlet DEBUG_MEASURE_PERF = true;\nexport function setDebugMeasurePerf(newDebugMeasurePerf: boolean): void {\n  DEBUG_MEASURE_PERF = newDebugMeasurePerf;\n}\n\nfunction now() {\n  return (typeof performance === \"undefined\" ? Date : performance).now();\n}\n\nasync function measurePerf<T>(\n  name: string,\n  f: () => T | Promise<T>,\n  options?: { isPrefetch?: boolean },\n): Promise<T> {\n  if (!DEBUG_MEASURE_PERF) {\n    return f();\n  }\n\n  const start = now();\n  const result = f();\n  if ((result as any)?.then) {\n    await result;\n  }\n  const end = now();\n  console.warn(\n    `${name}${options?.isPrefetch ? \" (prefetched)\" : \"\"}: ${Math.round(\n      end - start,\n    )}ms`,\n  );\n  return result;\n}\n\nconst prefetchPromises: Map<string, Promise<Alg>> = new Map();\n// This would just be a number, except `node` is extremely silly and returns an object instead.\n// https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\nlet queuedPrefetchTimeoutID: ReturnType<typeof setTimeout> | null = null;\n\nasync function randomScrambleForEvent(\n  eventID: string,\n  options?: { isPrefetch?: boolean },\n): Promise<Alg> {\n  switch (eventID) {\n    case \"222\":\n      return measurePerf(\"random222Scramble\", random222Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"333\":\n    case \"333oh\":\n    case \"333ft\":\n      return measurePerf(\"random333Scramble\", random333Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"333fm\":\n      return measurePerf(\n        \"random333FewestMovesScramble\",\n        random333FewestMovesScramble,\n      );\n    case \"333bf\":\n    case \"333mb\":\n      return measurePerf(\n        \"random333OrientedScramble\",\n        random333OrientedScramble,\n      );\n    case \"444\":\n      return measurePerf(\"random444Scramble\", random444Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"444bf\":\n      return measurePerf(\n        \"random444OrientedScramble\",\n        random444OrientedScramble,\n      );\n    case \"555\":\n      return measurePerf(\n        \"bigCubeScramble(5)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 5),\n      );\n    case \"555bf\":\n      return measurePerf(\"oriented555RandomMoves\", oriented555RandomMoves);\n    case \"666\":\n      return measurePerf(\n        \"bigCubeScramble(6)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 6),\n      );\n    case \"777\":\n      return measurePerf(\n        \"bigCubeScramble(7)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 7),\n      );\n    case \"skewb\":\n      return measurePerf(\n        \"randomSkewbFixedCornerScramble\",\n        randomSkewbFixedCornerScramble,\n      );\n    case \"pyram\":\n      return measurePerf(\n        \"randomPyraminxScrambleFixedOrientation\",\n        randomPyraminxScrambleFixedOrientation,\n      );\n    case \"sq1\":\n      return measurePerf(\"getRandomSquare1Scramble\", getRandomSquare1Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"fto\":\n      return measurePerf(\"randomFTOScramble\", randomFTOScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"master_tetraminx\":\n      return measurePerf(\n        \"randomMasterTetraminxScramble\",\n        randomMasterTetraminxScramble,\n      );\n    case \"kilominx\":\n      return measurePerf(\"randomKilominxScramble\", randomKilominxScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"redi_cube\":\n      return measurePerf(\"randomRediCubeScramble\", randomRediCubeScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    default:\n      throw new Error(`unsupported event: ${eventID}`);\n  }\n}\n\nexport enum PrefetchLevel {\n  Auto = \"auto\",\n  None = \"none\",\n  Immediate = \"immediate\",\n}\n\nlet currentPrefetchLevel = PrefetchLevel.Auto;\n\nexport const insideAPI = {\n  initialize: async (eventID: string) => {\n    switch (eventID) {\n      case \"222\":\n        return measurePerf(\"preInitialize222\", preInitialize222);\n      case \"333\":\n      case \"333oh\":\n      case \"333ft\":\n        return measurePerf(\"initialize333\", initialize333);\n      case \"444\":\n        return measurePerf(\"initialize444\", initialize444);\n      default:\n        throw new Error(`unsupported event: ${eventID}`);\n    }\n  },\n\n  setScramblePrefetchLevel(prefetchLevel: `${PrefetchLevel}`) {\n    currentPrefetchLevel = prefetchLevel as PrefetchLevel;\n  },\n\n  randomScrambleForEvent: async (eventID: string): Promise<Alg> => {\n    let promise = prefetchPromises.get(eventID);\n    if (promise) {\n      prefetchPromises.delete(eventID);\n    } else {\n      promise = randomScrambleForEvent(eventID);\n    }\n    if (currentPrefetchLevel !== PrefetchLevel.None) {\n      promise.then(() => {\n        // `queuedPrefetch` could be 0, but:\n        // > Passing an invalid ID to clearTimeout() silently does nothing; no exception is thrown.\n        // https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout#notes\n        if (queuedPrefetchTimeoutID) {\n          clearTimeout(queuedPrefetchTimeoutID);\n        }\n        queuedPrefetchTimeoutID = setTimeout(\n          () => {\n            prefetchPromises.set(\n              eventID,\n              randomScrambleForEvent(eventID, {\n                isPrefetch: true,\n              }),\n            );\n          },\n          currentPrefetchLevel === PrefetchLevel.Immediate\n            ? 0\n            : IDLE_PREFETCH_TIMEOUT_MS,\n        );\n      });\n    }\n    return promise;\n  },\n\n  randomScrambleStringForEvent: async (eventID: string): Promise<string> => {\n    return (await insideAPI.randomScrambleForEvent(eventID)).toString();\n  },\n\n  solve333ToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"3x3x3\"].kpuzzle(), stateData);\n    return (await solve333(state)).toString();\n  },\n\n  solve222ToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"2x2x2\"].kpuzzle(), stateData);\n    return (await solve222HTMSubOptimal(state)).toString();\n  },\n\n  solveSkewbToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"skewb\"].kpuzzle(), stateData);\n    return (await solveSkewb(state)).toString();\n  },\n\n  solvePyraminxToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"pyraminx\"].kpuzzle(), stateData);\n    return (await solvePyraminx(state)).toString();\n  },\n\n  solveMegaminxToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"megaminx\"].kpuzzle(), stateData);\n    return (await solveMegaminx(state)).toString();\n  },\n\n  setDebugMeasurePerf: async (measure: boolean): Promise<void> => {\n    setDebugMeasurePerf(measure);\n  },\n\n  solveTwsearchToString: async (\n    def: KPuzzleDefinition,\n    stateData: KTransformationData,\n    options?: TwsearchOptions,\n  ): Promise<string> => {\n    return (await solveTwsearch(def, stateData, options)).toString();\n  },\n};\n\nexport type WorkerInsideAPI = typeof insideAPI;\n"],
  "mappings": "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",
  "names": ["DEFAULT_STAGE1_DEPTH_LIMIT", "DOUBLECHECK_PLACED_PIECES", "DEBUG", "calculateMoves", "kpuzzle", "moveNames", "searchMoves", "moveName", "rootMove", "Move", "transformation", "TrembleSolver", "sgs", "trembleMoveNames", "state", "stage1DepthLimit", "quantumMoveOrder", "bestAlg", "bestLen", "recur", "recursiveTransformation", "togo", "sofar", "sgsAlg", "newAlg", "len", "countMoves", "searchMove", "d", "Alg", "initialTransformation", "bestLenSofar", "algBuilder", "AlgBuilder", "step", "cubieSeq", "key", "inverseTransformation", "i", "loc", "orbitName", "idx", "info", "location", "randomStateFromSGS", "sgsAction", "randomChoice", "searchDynamicSideEvents", "from", "twsearchPromise", "from", "existingPuzzleDefString", "existingMoveSubsetString", "mustBeNaturalNumber", "meaning", "n", "solveTwsearch", "def", "stateData", "options", "setArg", "setKPuzzleDefString", "serializeDefToTws", "solveState", "serializeKTransformationDataToTws", "kpuzzle", "KPuzzle", "moveSubsetString", "minDepth", "maxDepth", "puzzleDefString", "cachedTrembleSolver", "getCachedTrembleSolver", "sgsCachedData", "searchDynamicSideEvents", "TrembleSolver", "puzzles", "preInitialize222", "solve222HTMSubOptimal", "state", "maxDepth", "mustBeInsideWorker", "solveTwsearch", "cube2x2x2", "solve222HTMOptimal", "normalizedState", "normalizationAlg", "normalize2x2x2Orientation", "orientedResult", "hasHTMSolutionWithFewerMoves", "filterMin", "e", "twsearchPromise", "isCancelling", "alg", "lastFamily", "node", "move", "Move", "family", "solve222ForScramble", "mutatingRandomizeOrbit", "kpuzzle", "orbitName", "options", "randomPermuteInPlace", "orbitDef", "ori", "sum", "i", "o", "randomUIntBelow", "random222State", "stateCopy", "KState", "random222Scramble", "inverseState", "sol", "dynamic4x4x4Solver", "from", "randomSuffixes", "initialize444", "dynamic4x4x4Solver", "random444Scramble", "random444OrientedScramble", "addOrientationSuffix", "numMoves", "n", "axesFaces", "axesMovesCache", "cachedAxesMoves", "existing", "axesMoves", "faces", "axisMoveFamilies", "face", "QuantumMove", "bigCubeRandomMoves", "cachedNumMoves", "algBuilder", "AlgBuilder", "currentAxisIdx", "currentAxisQuantumMoves", "newAxisIdx", "randomUIntBelow", "quantumMove", "randomChoice", "quantumMoveStr", "Move", "randomSuffixes", "oriented555RandomMoves", "addOrientationSuffix", "bigCubeRandomMoves", "dynamicFTOSolver", "from", "dynamic", "from", "randomFTOScramble", "mustBeInsideWorker", "Alg", "dynamicFTOSolver", "dynamicKilominxSolver", "from", "randomKilominxScramble", "mustBeInsideWorker", "dynamicKilominxSolver", "dynamicMasterTetraminxSolver", "from", "randomMasterTetraminxScramble", "mustBeInsideWorker", "Alg", "dynamicMasterTetraminxSolver", "TREMBLE_DEPTH", "cachedTrembleSolver", "getCachedTrembleSolver", "json", "searchDynamicSideEvents", "TrembleSolver", "solveMegaminx", "state", "mustBeInsideWorker", "trembleSolver", "getCachedTrembleSolver", "stateDataWithoutMO", "stateWithoutMO", "KState", "searchDynamicSideEvents", "TREMBLE_DEPTH", "TREMBLE_DEPTH", "cachedTrembleSolver", "getCachedTrembleSolver", "json", "searchDynamicSideEvents", "TrembleSolver", "puzzles", "solvePyraminx", "state", "mustBeInsideWorker", "getCachedTrembleSolver", "TREMBLE_DEPTH", "randomPyraminxStateFixedOrientation", "randomStateFromSGS", "puzzles", "searchDynamicSideEvents", "randomPyraminxScrambleFixedOrientation", "searchDynamicUnofficial", "from", "randomRediCubeScramble", "mustBeInsideWorker", "searchDynamicUnofficial", "TREMBLE_DEPTH", "cachedTrembleSolver", "getCachedTrembleSolver", "json", "searchDynamicSideEvents", "TrembleSolver", "resetCenterOrientation", "state", "KState", "searchDynamicSideEvents", "solveSkewb", "mustBeInsideWorker", "getCachedTrembleSolver", "TREMBLE_DEPTH", "quantumMove", "randomSkewbFixedCornerState", "randomStateFromSGS", "randomSkewbFixedCornerScramble", "dynamicSq1Solver", "from", "getRandomSquare1Scramble", "Alg", "dynamicSq1Solver", "IDLE_PREFETCH_TIMEOUT_MS", "setIsInsideWorker", "DEBUG_MEASURE_PERF", "setDebugMeasurePerf", "newDebugMeasurePerf", "now", "measurePerf", "name", "f", "options", "start", "result", "end", "prefetchPromises", "queuedPrefetchTimeoutID", "randomScrambleForEvent", "eventID", "random222Scramble", "random333Scramble", "random333FewestMovesScramble", "random333OrientedScramble", "random444Scramble", "random444OrientedScramble", "bigCubeRandomMoves", "oriented555RandomMoves", "randomSkewbFixedCornerScramble", "randomPyraminxScrambleFixedOrientation", "getRandomSquare1Scramble", "randomFTOScramble", "randomMasterTetraminxScramble", "randomKilominxScramble", "randomRediCubeScramble", "currentPrefetchLevel", "insideAPI", "eventID", "measurePerf", "preInitialize222", "initialize333", "initialize444", "prefetchLevel", "promise", "prefetchPromises", "randomScrambleForEvent", "queuedPrefetchTimeoutID", "IDLE_PREFETCH_TIMEOUT_MS", "stateData", "state", "KState", "puzzles", "solve333", "solve222HTMSubOptimal", "solveSkewb", "solvePyraminx", "solveMegaminx", "measure", "setDebugMeasurePerf", "def", "options", "solveTwsearch"]
}
