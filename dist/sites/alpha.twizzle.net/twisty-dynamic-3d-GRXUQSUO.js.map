{
  "version": 3,
  "sources": ["../../../src/cubing/twisty/controllers/easing.ts", "../../../src/cubing/twisty/views/3D/puzzles/Cube3D.ts", "../../../src/cubing/twisty/views/3D/puzzles/PG3D.ts", "../../../src/cubing/twisty/views/3D/Twisty3DScene.ts", "../../../src/cubing/twisty/heavy-code-imports/dynamic-entries/twisty-dynamic-3d.ts"],
  "sourcesContent": ["export function smootherStep(x: number): number {\n  return x * x * x * (10 - x * (15 - 6 * x));\n}\n", "import {\n  BackSide,\n  BoxGeometry,\n  BufferAttribute,\n  BufferGeometry,\n  DoubleSide,\n  Euler,\n  FrontSide,\n  Group,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Quaternion,\n  Texture,\n  TextureLoader,\n  Vector2,\n  Vector3,\n} from \"three\";\nimport type { KPuzzle } from \"../../../../kpuzzle\";\nimport type { ExperimentalStickeringMask } from \"../../../../puzzles/cubing-private\";\nimport type {\n  FaceletMeshStickeringMask,\n  StickeringMask,\n} from \"../../../../puzzles/stickerings/mask\";\nimport type {\n  MillisecondTimestamp,\n  PuzzlePosition,\n} from \"../../../controllers/AnimationTypes\";\nimport { smootherStep } from \"../../../controllers/easing\";\nimport {\n  HintFaceletStyle,\n  hintFaceletStyles,\n} from \"../../../model/props/puzzle/display/HintFaceletProp\";\nimport type { InitialHintFaceletsAnimation } from \"../../../model/props/puzzle/display/InitialHintFaceletsAnimationProp\";\nimport type { FaceletScale } from \"../../../model/props/puzzle/display/FaceletScaleProp\";\nimport { TAU } from \"../TAU\";\nimport { haveStartedSharingRenderers } from \"../Twisty3DVantage\";\nimport type { Twisty3DPuzzle } from \"./Twisty3DPuzzle\";\n\nconst svgLoader = new TextureLoader();\n\nconst ignoredMaterial = new MeshBasicMaterial({\n  color: 0x444444,\n  side: DoubleSide,\n});\n\nconst ignoredMaterialHint = new MeshBasicMaterial({\n  color: 0xcccccc,\n  side: BackSide,\n  transparent: true,\n  opacity: 0.75,\n});\n\nconst invisibleMaterial = new MeshBasicMaterial({\n  visible: false,\n});\n\nconst orientedMaterial = new MeshBasicMaterial({\n  color: 0x44ddcc,\n});\n\nconst orientedMaterialHint = new MeshBasicMaterial({\n  color: 0x44ddcc,\n  side: BackSide,\n  transparent: true,\n  opacity: 0.5,\n});\n\ninterface MaterialMap\n  extends Record<FaceletMeshStickeringMask, MeshBasicMaterial> {\n  regular: MeshBasicMaterial;\n  dim: MeshBasicMaterial;\n  ignored: MeshBasicMaterial;\n  invisible: MeshBasicMaterial;\n}\n\nclass AxisInfo {\n  public stickerMaterial: MaterialMap;\n  public hintStickerMaterial: MaterialMap;\n  constructor(\n    public vector: Vector3,\n    public fromZ: Euler,\n    public color: number,\n    public dimColor: number,\n    public hintOpacityScale: number, // TODO: make this work better across bright *and* dark backgrounds. Maybe tweak sticker compositing settings?\n    options?: { hintColor?: number; hintDimColor?: number },\n  ) {\n    // TODO: Make sticker material single-sided when cubie foundation is opaque?\n    this.stickerMaterial = {\n      regular: new MeshBasicMaterial({\n        color,\n        side: FrontSide, // TODO: set to `DoubleSide` when hint facelets are disabled.\n      }),\n      dim: new MeshBasicMaterial({\n        color: dimColor,\n        side: FrontSide, // TODO: set to `DoubleSide` when hint facelets are disabled.\n      }),\n      oriented: orientedMaterial,\n      ignored: ignoredMaterial,\n      invisible: invisibleMaterial,\n    };\n    this.hintStickerMaterial = {\n      regular: new MeshBasicMaterial({\n        color: options?.hintColor ?? color,\n        side: BackSide,\n        transparent: true,\n        opacity: 0.5 * hintOpacityScale,\n      }),\n      dim: new MeshBasicMaterial({\n        color: options?.hintDimColor ?? dimColor,\n        side: BackSide,\n        transparent: true,\n        opacity: 0.5 * hintOpacityScale,\n      }),\n      oriented: orientedMaterialHint,\n      ignored: ignoredMaterialHint,\n      invisible: invisibleMaterial,\n    };\n  }\n}\n\nconst axesInfo: AxisInfo[] = [\n  new AxisInfo(\n    new Vector3(0, 1, 0),\n    new Euler(-TAU / 4, 0, 0),\n    0xffffff,\n    0xdddddd,\n    1.25,\n  ),\n  new AxisInfo(\n    new Vector3(-1, 0, 0),\n    new Euler(0, -TAU / 4, 0),\n    0xff8800,\n    0x884400,\n    1,\n    { hintDimColor: 0x996600 },\n  ),\n  new AxisInfo(\n    new Vector3(0, 0, 1),\n    new Euler(0, 0, 0),\n    0x00ff00,\n    0x008800,\n    1,\n    { hintDimColor: 0x009900 },\n  ),\n  new AxisInfo(\n    new Vector3(1, 0, 0),\n    new Euler(0, TAU / 4, 0),\n    0xff0000,\n    0x660000,\n    1,\n    { hintDimColor: 0x990000 },\n  ),\n  new AxisInfo(\n    new Vector3(0, 0, -1),\n    new Euler(0, TAU / 2, 0),\n    0x2266ff,\n    0x113388,\n    0.75,\n    { hintDimColor: 0x001866 },\n  ),\n  new AxisInfo(\n    new Vector3(0, -1, 0),\n    new Euler(TAU / 4, 0, 0),\n    0xffff00,\n    0x888800,\n    1.25,\n    { hintDimColor: 0xbbbb00 },\n  ),\n];\n\nconst face: { [s: string]: number } = {\n  U: 0,\n  L: 1,\n  F: 2,\n  R: 3,\n  B: 4,\n  D: 5,\n};\n\nconst familyToAxis: { [s: string]: number } = {\n  U: face.U,\n  u: face.U,\n  Uw: face.U,\n  Uv: face.U,\n  y: face.U,\n  L: face.L,\n  l: face.L,\n  Lw: face.L,\n  Lv: face.L,\n  M: face.L,\n  F: face.F,\n  f: face.F,\n  Fw: face.F,\n  Fv: face.F,\n  S: face.F,\n  z: face.F,\n  R: face.R,\n  r: face.R,\n  Rw: face.R,\n  Rv: face.R,\n  x: face.R,\n  B: face.B,\n  b: face.B,\n  Bw: face.B,\n  Bv: face.B,\n  D: face.D,\n  d: face.D,\n  Dw: face.D,\n  Dv: face.D,\n  E: face.D,\n};\n\nconst cubieDimensions = {\n  // stickerWidth: 0.85, // Now `faceletScale` in options.\n  stickerElevation: 0.503,\n  foundationWidth: 1,\n  hintStickerElevation: 1.45,\n};\nconst EXPERIMENTAL_PICTURE_CUBE_HINT_ELEVATION = 2;\n\n/** @deprecated */\nexport function experimentalSetDefaultStickerElevation(\n  stickerElevation: number,\n): void {\n  cubieDimensions.stickerElevation = stickerElevation;\n}\n\nexport interface Cube3DOptions {\n  showMainStickers?: boolean;\n  hintFacelets?: HintFaceletStyle;\n  showFoundation?: boolean; // TODO: better name\n  experimentalStickeringMask?: ExperimentalStickeringMask;\n  foundationSprite?: Texture | null;\n  hintSprite?: Texture | null;\n  initialHintFaceletsAnimation?: InitialHintFaceletsAnimation;\n  faceletScale?: \"auto\" | number;\n}\n\nconst cube3DOptionsDefaults: Cube3DOptions = {\n  showMainStickers: true,\n  hintFacelets: \"floating\",\n  showFoundation: true,\n  experimentalStickeringMask: undefined,\n  foundationSprite: null,\n  hintSprite: null,\n  initialHintFaceletsAnimation: \"auto\",\n  faceletScale: \"auto\",\n};\n\nconst DEFAULT_STICKER_SCALE = 0.85;\nfunction getFaceletScale(options: Cube3DOptions): number {\n  if (\n    typeof options.faceletScale === \"undefined\" ||\n    options.faceletScale === \"auto\"\n  ) {\n    return DEFAULT_STICKER_SCALE;\n  }\n  return options.faceletScale;\n}\n\n// TODO: Make internal foundation faces one-sided, facing to the outside of the cube.\nconst blackMesh = new MeshBasicMaterial({\n  color: 0x000000,\n  opacity: 1,\n  transparent: true,\n});\n\nconst blackTranslucentMesh = new MeshBasicMaterial({\n  color: 0x000000,\n  opacity: 0.3,\n  transparent: true,\n});\n\nclass CubieDef {\n  public matrix: Matrix4;\n  public stickerFaces: number[];\n  // stickerFaceNames can be e.g. [\"U\", \"F\", \"R\"], \"UFR\" if every face is a single letter.\n  constructor(\n    public orbit: string,\n    stickerFaceNames: string[] | string,\n    q: Quaternion,\n  ) {\n    const individualStickerFaceNames =\n      typeof stickerFaceNames === \"string\"\n        ? stickerFaceNames.split(\"\")\n        : stickerFaceNames;\n    this.stickerFaces = individualStickerFaceNames.map((s) => face[s]);\n    this.matrix = new Matrix4();\n    this.matrix.setPosition(firstPiecePosition[orbit]);\n    this.matrix.premultiply(new Matrix4().makeRotationFromQuaternion(q));\n  }\n}\n\nfunction t(v: Vector3, t4: number): Quaternion {\n  return new Quaternion().setFromAxisAngle(v, (TAU * t4) / 4);\n}\n\nconst r = {\n  O: new Vector3(0, 0, 0),\n  U: new Vector3(0, -1, 0),\n  L: new Vector3(1, 0, 0),\n  F: new Vector3(0, 0, -1),\n  R: new Vector3(-1, 0, 0),\n  B: new Vector3(0, 0, 1),\n  D: new Vector3(0, 1, 0),\n};\n\ninterface OrbitIndexed<T> {\n  [s: string]: T;\n}\ntype PieceIndexed<T> = OrbitIndexed<T[]>;\n\nconst firstPiecePosition: OrbitIndexed<Vector3> = {\n  EDGES: new Vector3(0, 1, 1),\n  CORNERS: new Vector3(1, 1, 1),\n  CENTERS: new Vector3(0, 1, 0),\n};\nconst orientationRotation: OrbitIndexed<Matrix4[]> = {\n  EDGES: [0, 1].map((i) =>\n    new Matrix4().makeRotationAxis(\n      firstPiecePosition.EDGES.clone().normalize(),\n      (-i * TAU) / 2,\n    ),\n  ),\n  CORNERS: [0, 1, 2].map((i) =>\n    new Matrix4().makeRotationAxis(\n      firstPiecePosition.CORNERS.clone().normalize(),\n      (-i * TAU) / 3,\n    ),\n  ),\n  CENTERS: [0, 1, 2, 3].map((i) =>\n    new Matrix4().makeRotationAxis(\n      firstPiecePosition.CENTERS.clone().normalize(),\n      (-i * TAU) / 4,\n    ),\n  ),\n};\nconst cubieStickerOrder = [face.U, face.F, face.R];\n\nconst pieceDefs: PieceIndexed<CubieDef> = {\n  EDGES: [\n    new CubieDef(\"EDGES\", \"UF\", t(r.O, 0)),\n    new CubieDef(\"EDGES\", \"UR\", t(r.U, 3)),\n    new CubieDef(\"EDGES\", \"UB\", t(r.U, 2)),\n    new CubieDef(\"EDGES\", \"UL\", t(r.U, 1)),\n    new CubieDef(\"EDGES\", \"DF\", t(r.F, 2)),\n    new CubieDef(\"EDGES\", \"DR\", t(r.F, 2).premultiply(t(r.D, 1))),\n    new CubieDef(\"EDGES\", \"DB\", t(r.F, 2).premultiply(t(r.D, 2))),\n    new CubieDef(\"EDGES\", \"DL\", t(r.F, 2).premultiply(t(r.D, 3))),\n    new CubieDef(\"EDGES\", \"FR\", t(r.U, 3).premultiply(t(r.R, 3))),\n    new CubieDef(\"EDGES\", \"FL\", t(r.U, 1).premultiply(t(r.R, 3))),\n    new CubieDef(\"EDGES\", \"BR\", t(r.U, 3).premultiply(t(r.R, 1))),\n    new CubieDef(\"EDGES\", \"BL\", t(r.U, 1).premultiply(t(r.R, 1))),\n  ],\n  CORNERS: [\n    new CubieDef(\"CORNERS\", \"UFR\", t(r.O, 0)),\n    new CubieDef(\"CORNERS\", \"URB\", t(r.U, 3)),\n    new CubieDef(\"CORNERS\", \"UBL\", t(r.U, 2)),\n    new CubieDef(\"CORNERS\", \"ULF\", t(r.U, 1)),\n    new CubieDef(\"CORNERS\", \"DRF\", t(r.F, 2).premultiply(t(r.D, 1))),\n    new CubieDef(\"CORNERS\", \"DFL\", t(r.F, 2).premultiply(t(r.D, 0))),\n    new CubieDef(\"CORNERS\", \"DLB\", t(r.F, 2).premultiply(t(r.D, 3))),\n    new CubieDef(\"CORNERS\", \"DBR\", t(r.F, 2).premultiply(t(r.D, 2))),\n  ],\n  CENTERS: [\n    new CubieDef(\"CENTERS\", \"U\", t(r.O, 0)),\n    new CubieDef(\"CENTERS\", \"L\", t(r.R, 3).premultiply(t(r.U, 1))),\n    new CubieDef(\"CENTERS\", \"F\", t(r.R, 3)),\n    new CubieDef(\"CENTERS\", \"R\", t(r.R, 3).premultiply(t(r.D, 1))),\n    new CubieDef(\"CENTERS\", \"B\", t(r.R, 3).premultiply(t(r.D, 2))),\n    new CubieDef(\"CENTERS\", \"D\", t(r.R, 2)),\n  ],\n};\n\nconst CUBE_SCALE = 1 / 3;\n\ninterface FaceletInfo {\n  faceIdx: number;\n  facelet: Mesh;\n  hintFacelet?: Mesh;\n}\n\n// TODO: Compatibility with Randelshofer or standard net layout? Offer a\n// conversion function?\nconst pictureStickerCoords: Record<string, number[][][]> = {\n  EDGES: [\n    [\n      [0, 4, 6],\n      [0, 4, 5],\n    ],\n    [\n      [3, 5, 7],\n      [0, 7, 5],\n    ],\n    [\n      [2, 4, 8],\n      [0, 10, 5],\n    ],\n    [\n      [1, 3, 7],\n      [0, 1, 5],\n    ],\n    [\n      [2, 4, 2],\n      [2, 4, 3],\n    ],\n    [\n      [3, 5, 1],\n      [2, 7, 3],\n    ],\n    [\n      [0, 4, 0],\n      [2, 10, 3],\n    ],\n    [\n      [1, 3, 1],\n      [2, 1, 3],\n    ],\n    [\n      [3, 5, 4],\n      [3, 6, 4],\n    ],\n    [\n      [1, 3, 4],\n      [1, 2, 4],\n    ],\n    [\n      [1, 9, 4],\n      [1, 8, 4],\n    ],\n    [\n      [3, 11, 4],\n      [3, 0, 4],\n    ],\n  ],\n  CORNERS: [\n    [\n      [0, 5, 6],\n      [0, 5, 5],\n      [0, 6, 5],\n    ],\n    [\n      [3, 5, 8],\n      [0, 8, 5],\n      [0, 9, 5],\n    ],\n    [\n      [2, 3, 8],\n      [0, 11, 5],\n      [0, 0, 5],\n    ],\n    [\n      [1, 3, 6],\n      [0, 2, 5],\n      [0, 3, 5],\n    ],\n    [\n      [3, 5, 2],\n      [2, 6, 3],\n      [2, 5, 3],\n    ],\n    [\n      [2, 3, 2],\n      [2, 3, 3],\n      [2, 2, 3],\n    ],\n    [\n      [1, 3, 0],\n      [2, 0, 3],\n      [2, 11, 3],\n    ],\n    [\n      [0, 5, 0],\n      [2, 9, 3],\n      [2, 8, 3],\n    ],\n  ],\n  CENTERS: [\n    [[0, 4, 7]],\n    [[0, 1, 4]],\n    [[0, 4, 4]],\n    [[0, 7, 4]],\n    [[0, 10, 4]],\n    [[0, 4, 1]],\n  ],\n};\n\nlet sharedCubieFoundationGeometryCache: BoxGeometry | null = null;\nfunction sharedCubieFoundationGeometry(): BoxGeometry {\n  return (\n    sharedCubieFoundationGeometryCache ??\n    (sharedCubieFoundationGeometryCache = new BoxGeometry(\n      cubieDimensions.foundationWidth,\n      cubieDimensions.foundationWidth,\n      cubieDimensions.foundationWidth,\n    ))\n  );\n}\n\nfunction newStickerGeometry(): BufferGeometry {\n  const r = new BufferGeometry();\n  const half = 0.5;\n  r.setAttribute(\n    \"position\",\n    new BufferAttribute(\n      new Float32Array([\n        half,\n        half,\n        0,\n        -half,\n        half,\n        0,\n        half,\n        -half,\n        0,\n        -half,\n        half,\n        0,\n        -half,\n        -half,\n        0,\n        half,\n        -half,\n        0,\n      ]),\n      3,\n    ),\n  );\n  r.setAttribute(\n    \"uv\",\n    new BufferAttribute(\n      new Float32Array([\n        1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1,\n      ]),\n      2,\n    ),\n  );\n  //  r.setAttribute('normals', new BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]), 3));\n  return r;\n}\n\nlet sharedStickerGeometryCache: BufferGeometry | null = null;\nfunction sharedStickerGeometry(): BufferGeometry {\n  return (\n    sharedStickerGeometryCache ??\n    (sharedStickerGeometryCache = newStickerGeometry())\n  );\n}\n\n// TODO: Split into \"scene model\" and \"view\".\nexport class Cube3D extends Object3D implements Twisty3DPuzzle {\n  kpuzzleFaceletInfo: Record<string, FaceletInfo[][]>;\n  private pieces: PieceIndexed<Object3D> = {};\n  private options: Cube3DOptions;\n  // TODO: Keep track of option-based meshes better.\n  private experimentalHintStickerMeshes: Mesh[] = [];\n  private experimentalFoundationMeshes: Mesh[] = [];\n\n  private setSpriteURL: (url: string) => void;\n  private sprite: Texture | Promise<Texture> = new Promise((resolve) => {\n    this.setSpriteURL = (url: string): void => {\n      svgLoader.load(url, resolve);\n    };\n  });\n\n  // TODO: Don't overwrite the static function.\n  // TODO: This doesn't work dynamically yet.\n  setSprite(texture: Texture): void {\n    this.sprite = texture;\n  }\n\n  private setHintSpriteURL: (url: string) => void;\n  private hintSprite: Texture | Promise<Texture> = new Promise((resolve) => {\n    this.setHintSpriteURL = (url: string): void => {\n      svgLoader.load(url, resolve);\n    };\n  });\n\n  // TODO: Don't overwrite the static function.\n  // TODO: This doesn't work dynamically yet.\n  setHintSprite(texture: Texture): void {\n    this.hintSprite = texture;\n  }\n\n  constructor(\n    private kpuzzle: KPuzzle,\n    private scheduleRenderCallback?: () => void,\n    options: Cube3DOptions = {},\n  ) {\n    super();\n\n    this.options = { ...cube3DOptionsDefaults };\n    Object.assign(this.options, options); // TODO: check if this works\n\n    if (this.kpuzzle.name() !== \"3x3x3\") {\n      throw new Error(\n        `Invalid puzzle for this Cube3D implementation: ${this.kpuzzle.name()}`,\n      );\n    }\n\n    if (options.foundationSprite) {\n      this.setSprite(options.foundationSprite);\n    }\n    if (options.hintSprite) {\n      this.setHintSprite(options.hintSprite);\n    }\n\n    this.kpuzzleFaceletInfo = {};\n    for (const orbit in pieceDefs) {\n      const orbitFaceletInfo: FaceletInfo[][] = [];\n      this.kpuzzleFaceletInfo[orbit] = orbitFaceletInfo;\n      this.pieces[orbit] = pieceDefs[orbit].map(\n        this.createCubie.bind(this, orbit, orbitFaceletInfo),\n      );\n    }\n    this.scale.set(CUBE_SCALE, CUBE_SCALE, CUBE_SCALE);\n\n    // TODO: Can we construct this directly instead of applying it later? Would that be more code-efficient?\n    if (this.options.experimentalStickeringMask) {\n      this.setStickeringMask(this.options.experimentalStickeringMask);\n    }\n    this.#animateRaiseHintFacelets();\n\n    if (this.options.faceletScale) {\n      this.experimentalSetFaceletScale(this.options.faceletScale);\n    }\n  }\n\n  #sharedHintStickerGeometryCache: BufferGeometry | null = null;\n  #sharedHintStickerGeometry(): BufferGeometry {\n    return (this.#sharedHintStickerGeometryCache ??= newStickerGeometry());\n  }\n\n  // TODO: Generalize this into an animation mechanism.\n  #animateRaiseHintFacelets(): void {\n    if (\n      this.options.initialHintFaceletsAnimation === \"none\" ||\n      (this.options.initialHintFaceletsAnimation !== \"always\" &&\n        haveStartedSharingRenderers())\n    ) {\n      return;\n    }\n    const translationRange =\n      cubieDimensions.hintStickerElevation - cubieDimensions.stickerElevation;\n    this.#sharedHintStickerGeometry().translate(0, 0, -translationRange);\n    setTimeout(() => {\n      const hintStartTime = performance.now();\n      let lastTranslation = 0;\n      const translationDuration: MillisecondTimestamp = 1000;\n      function ease(x: number) {\n        return x * (2 - x);\n      }\n      const animateRaiseHintSticker = () => {\n        const elapsed = performance.now() - hintStartTime;\n        const newTranslation =\n          ease(elapsed / translationDuration) * translationRange;\n        this.#sharedHintStickerGeometry().translate(\n          0,\n          0,\n          newTranslation - lastTranslation,\n        );\n        lastTranslation = newTranslation;\n        if (elapsed < translationDuration) {\n          requestAnimationFrame(animateRaiseHintSticker);\n          this.scheduleRenderCallback?.();\n        }\n      };\n      animateRaiseHintSticker();\n    }, 500);\n  }\n\n  // Can only be called once.\n  /** @deprecated */\n  experimentalSetStickerSpriteURL(stickerSpriteURL: string): void {\n    this.setSpriteURL(stickerSpriteURL);\n  }\n\n  // Can only be called once.\n  /** @deprecated */\n  experimentalSetHintStickerSpriteURL(hintStickerSpriteURL: string): void {\n    this.setHintSpriteURL(hintStickerSpriteURL);\n  }\n\n  setStickeringMask(stickeringMask: StickeringMask): void {\n    if (stickeringMask.specialBehaviour === \"picture\") {\n      // TODO: if the latest stickering mask was already \"picture\", don't redo work.\n      for (const pieceInfos of Object.values(this.kpuzzleFaceletInfo)) {\n        for (const faceletInfos of pieceInfos) {\n          for (const faceletInfo of faceletInfos) {\n            faceletInfo.facelet.material = invisibleMaterial;\n            const { hintFacelet } = faceletInfo;\n            if (hintFacelet) {\n              hintFacelet.material = invisibleMaterial;\n            }\n          }\n        }\n      }\n      return;\n    }\n    this.options.experimentalStickeringMask = stickeringMask;\n    for (const [orbitName, orbitStickeringMask] of Object.entries(\n      stickeringMask.orbits,\n    )) {\n      for (\n        let pieceIdx = 0;\n        pieceIdx < orbitStickeringMask.pieces.length;\n        pieceIdx++\n      ) {\n        const pieceStickeringMask = orbitStickeringMask.pieces[pieceIdx];\n        if (pieceStickeringMask) {\n          const pieceInfo = this.kpuzzleFaceletInfo[orbitName][pieceIdx];\n          for (\n            let faceletIdx = 0;\n            faceletIdx < pieceInfo.length;\n            faceletIdx++\n          ) {\n            const faceletStickeringMask =\n              pieceStickeringMask.facelets[faceletIdx];\n            if (faceletStickeringMask) {\n              const faceletInfo = pieceInfo[faceletIdx];\n\n              const stickeringMask =\n                typeof faceletStickeringMask === \"string\"\n                  ? faceletStickeringMask\n                  : faceletStickeringMask?.mask;\n\n              faceletInfo.facelet.material =\n                axesInfo[faceletInfo.faceIdx].stickerMaterial[stickeringMask];\n              // TODO\n              const hintStickeringMask =\n                typeof faceletStickeringMask === \"string\"\n                  ? stickeringMask\n                  : faceletStickeringMask.hintMask ?? stickeringMask;\n              if (faceletInfo.hintFacelet) {\n                faceletInfo.hintFacelet.material =\n                  axesInfo[faceletInfo.faceIdx].hintStickerMaterial[\n                    hintStickeringMask\n                  ];\n              }\n            }\n          }\n        }\n      }\n    }\n    if (this.scheduleRenderCallback) {\n      this.scheduleRenderCallback();\n    }\n  }\n\n  /** @deprecated */\n  public experimentalUpdateOptions(options: Cube3DOptions): void {\n    if (\"showMainStickers\" in options) {\n      throw new Error(\"Unimplemented\");\n    }\n\n    const showFoundation = options.showFoundation;\n    if (\n      typeof showFoundation !== \"undefined\" &&\n      this.options.showFoundation !== showFoundation\n    ) {\n      this.options.showFoundation = showFoundation;\n      for (const foundation of this.experimentalFoundationMeshes) {\n        foundation.visible = showFoundation;\n      }\n    }\n\n    const hintFacelets = options.hintFacelets;\n    if (\n      typeof hintFacelets !== \"undefined\" &&\n      this.options.hintFacelets !== hintFacelets &&\n      hintFaceletStyles[hintFacelets] // TODO: test this\n    ) {\n      this.options.hintFacelets = hintFacelets;\n      for (const hintSticker of this.experimentalHintStickerMeshes) {\n        hintSticker.visible = hintFacelets === \"floating\";\n      }\n      this.scheduleRenderCallback!(); // TODO\n    }\n\n    const { experimentalStickeringMask } = options;\n    if (typeof experimentalStickeringMask !== \"undefined\") {\n      this.options.experimentalStickeringMask = experimentalStickeringMask;\n      this.setStickeringMask(experimentalStickeringMask);\n      this.scheduleRenderCallback!(); // TODO\n    }\n\n    const { faceletScale } = options;\n    if (typeof faceletScale !== \"undefined\") {\n      this.experimentalSetFaceletScale(faceletScale);\n    }\n  }\n\n  public onPositionChange(p: PuzzlePosition): void {\n    const reid333 = p.state;\n    for (const orbit in pieceDefs) {\n      const pieces = pieceDefs[orbit];\n      for (let i = 0; i < pieces.length; i++) {\n        const j = reid333.stateData[orbit].pieces[i];\n        this.pieces[orbit][j].matrix.copy(pieceDefs[orbit][i].matrix);\n        this.pieces[orbit][j].matrix.multiply(\n          orientationRotation[orbit][reid333.stateData[orbit].orientation[i]],\n        );\n      }\n      for (const moveProgress of p.movesInProgress) {\n        const move = moveProgress.move;\n        const turnNormal = axesInfo[familyToAxis[move.family]].vector;\n        const moveMatrix = new Matrix4().makeRotationAxis(\n          turnNormal,\n          (-this.ease(moveProgress.fraction) *\n            moveProgress.direction *\n            move.amount *\n            TAU) /\n            4,\n        );\n        for (let i = 0; i < pieces.length; i++) {\n          const quantumTransformation = this.kpuzzle.moveToTransformation(\n            move.modified({ amount: 1 }),\n          );\n          const k =\n            quantumTransformation.transformationData[orbit].permutation[i];\n          if (\n            i !== k ||\n            quantumTransformation.transformationData[orbit].orientation[i] !== 0\n          ) {\n            const j = reid333.stateData[orbit].pieces[i];\n            this.pieces[orbit][j].matrix.premultiply(moveMatrix);\n          }\n        }\n      }\n    }\n    this.scheduleRenderCallback!();\n  }\n\n  // TODO: Always create (but sometimes hide parts) so we can show them later,\n  // or (better) support creating puzzle parts on demand.\n  private createCubie(\n    orbit: string,\n    orbitFacelets: FaceletInfo[][],\n    piece: CubieDef,\n    orbitPieceIdx: number,\n  ): Object3D {\n    const cubieFaceletInfo: FaceletInfo[] = [];\n    orbitFacelets.push(cubieFaceletInfo);\n    const cubie = new Group();\n    if (this.options.showFoundation) {\n      const foundation = this.createCubieFoundation();\n      cubie.add(foundation);\n      this.experimentalFoundationMeshes.push(foundation);\n    }\n    for (let i = 0; i < piece.stickerFaces.length; i++) {\n      const sticker = this.createSticker(\n        axesInfo[cubieStickerOrder[i]],\n        axesInfo[piece.stickerFaces[i]],\n        false,\n      );\n      const faceletInfo: FaceletInfo = {\n        faceIdx: piece.stickerFaces[i],\n        facelet: sticker,\n      };\n      cubie.add(sticker);\n      if (this.options.hintFacelets === \"floating\") {\n        const hintSticker = this.createSticker(\n          axesInfo[cubieStickerOrder[i]],\n          axesInfo[piece.stickerFaces[i]],\n          true,\n        );\n        cubie.add(hintSticker);\n        faceletInfo.hintFacelet = hintSticker;\n        this.experimentalHintStickerMeshes.push(hintSticker);\n      }\n\n      if (\n        this.options.experimentalStickeringMask?.specialBehaviour ===\n          \"picture\" &&\n        pictureStickerCoords[orbit] &&\n        pictureStickerCoords[orbit][orbitPieceIdx] &&\n        pictureStickerCoords[orbit][orbitPieceIdx][i]\n      ) {\n        const [rotate, offsetX, offsetY] =\n          pictureStickerCoords[orbit][orbitPieceIdx][i];\n        (async () => {\n          const addImageSticker = async (hint: boolean) => {\n            const texture: Texture = await (hint\n              ? this.hintSprite\n              : this.sprite);\n\n            const mesh = this.createSticker(\n              axesInfo[cubieStickerOrder[i]],\n              axesInfo[piece.stickerFaces[i]],\n              hint,\n            );\n            mesh.material = new MeshBasicMaterial({\n              map: texture,\n              side: hint ? BackSide : DoubleSide,\n              transparent: true,\n            });\n\n            const x1 = offsetX / 12;\n            const x2 = (offsetX + 1) / 12;\n            const y1 = offsetY / 9;\n            const y2 = (offsetY + 1) / 9;\n\n            let v1 = new Vector2(x1, y1);\n            let v2 = new Vector2(x1, y2);\n            let v3 = new Vector2(x2, y2);\n            let v4 = new Vector2(x2, y1);\n\n            switch (rotate) {\n              case 1: {\n                [v1, v2, v3, v4] = [v2, v3, v4, v1];\n                break;\n              }\n              case 2: {\n                [v1, v2, v3, v4] = [v3, v4, v1, v2];\n                break;\n              }\n              case 3: {\n                [v1, v2, v3, v4] = [v4, v1, v2, v3];\n                break;\n              }\n            }\n            mesh.geometry.setAttribute(\n              \"uv\",\n              new BufferAttribute(\n                new Float32Array([\n                  v3.x,\n                  v3.y,\n                  v2.x,\n                  v2.y,\n                  v4.x,\n                  v4.y,\n                  v2.x,\n                  v2.y,\n                  v1.x,\n                  v1.y,\n                  v4.x,\n                  v4.y,\n                ]),\n                2,\n              ),\n            );\n            cubie.add(mesh);\n          };\n          // const delay: number = ({\n          //   CENTERS: 1000,\n          //   EDGES: 2000,\n          //   CORNERS: 3500,\n          // } as Record<string, number>)[orbit];\n          // if (orbit === \"CENTERS\" && orbitPieceIdx === 5) {\n          addImageSticker(true);\n          addImageSticker(false);\n          // } else {\n          //   await this.sprite;\n          //   await this.hintSprite;\n          //   setTimeout(\n          //     () => addImageSticker(true),\n          //     delay + orbitPieceIdx * 100,\n          //   );\n          //   setTimeout(\n          //     () => addImageSticker(false),\n          //     delay + orbitPieceIdx * 100,\n          //   );\n          // }\n        })();\n      }\n\n      cubieFaceletInfo.push(faceletInfo);\n    }\n    cubie.matrix.copy(piece.matrix);\n    cubie.matrixAutoUpdate = false;\n    this.add(cubie);\n    return cubie;\n  }\n\n  // TODO: Support creating only the outward-facing parts?\n  private createCubieFoundation(): Mesh {\n    const box = sharedCubieFoundationGeometry();\n    return new Mesh(\n      box,\n      this.options.experimentalStickeringMask?.specialBehaviour === \"picture\"\n        ? blackMesh\n        : blackTranslucentMesh,\n    );\n  }\n\n  private createSticker(\n    posAxisInfo: AxisInfo,\n    materialAxisInfo: AxisInfo,\n    isHint: boolean,\n  ): Mesh {\n    const geo =\n      this.options.experimentalStickeringMask?.specialBehaviour === \"picture\"\n        ? newStickerGeometry()\n        : isHint\n        ? this.#sharedHintStickerGeometry()\n        : sharedStickerGeometry();\n    const stickerMesh = new Mesh(\n      geo,\n      isHint\n        ? materialAxisInfo.hintStickerMaterial.regular\n        : materialAxisInfo.stickerMaterial.regular,\n    );\n    stickerMesh.setRotationFromEuler(posAxisInfo.fromZ);\n    stickerMesh.position.copy(posAxisInfo.vector);\n    stickerMesh.position.multiplyScalar(\n      isHint\n        ? this.options.experimentalStickeringMask?.specialBehaviour ===\n          \"picture\"\n          ? EXPERIMENTAL_PICTURE_CUBE_HINT_ELEVATION\n          : cubieDimensions.hintStickerElevation\n        : cubieDimensions.stickerElevation,\n    );\n    stickerMesh.scale.setScalar(getFaceletScale(this.options));\n    return stickerMesh;\n  }\n\n  /** @deprecated */\n  experimentalSetFoundationOpacity(opacity: number): void {\n    (\n      this.experimentalFoundationMeshes[0].material as MeshBasicMaterial\n    ).opacity = opacity;\n  }\n\n  /** @deprecated */\n  experimentalSetFaceletScale(faceletScale: FaceletScale): void {\n    this.options.faceletScale = faceletScale;\n    for (const orbitInfo of Object.values(this.kpuzzleFaceletInfo)) {\n      for (const pieceInfo of orbitInfo) {\n        for (const faceletInfo of pieceInfo) {\n          faceletInfo.facelet.scale.setScalar(getFaceletScale(this.options));\n          faceletInfo.hintFacelet?.scale.setScalar(\n            getFaceletScale(this.options),\n          );\n          // faceletInfo.facelet.setRotationFromAxisAngle(new Vector3(0, 1, 0), 0);\n          // faceletInfo.facelet.rotateOnAxis(new Vector3(1, 0, 1), TAU / 6);\n        }\n      }\n    }\n  }\n\n  // /** @deprecated */\n  // experimentalSetCenterStickerWidth(width: number): void {\n  //   for (const orbitInfo of [this.kpuzzleFaceletInfo[\"CENTERS\"]]) {\n  //     for (const pieceInfo of orbitInfo) {\n  //       for (const faceletInfo of pieceInfo) {\n  //         faceletInfo.facelet.scale.setScalar(\n  //           width / getStickerScale(this.options),\n  //         );\n  //         // faceletInfo.facelet.setRotationFromAxisAngle(new Vector3(0, 1, 0), 0);\n  //         // faceletInfo.facelet.rotateOnAxis(new Vector3(1, 0, 1), TAU / 6);\n  //       }\n  //     }\n  //   }\n  // }\n\n  private ease(fraction: number): number {\n    return smootherStep(fraction);\n  }\n}\n", "import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  DoubleSide,\n  Euler,\n  FrontSide,\n  Group,\n  Material,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Texture,\n  Vector3,\n} from \"three\";\nimport { Move } from \"../../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../../kpuzzle\";\nimport type {\n  StickerDat,\n  StickerDatAxis,\n  StickerDatSticker,\n} from \"../../../../puzzle-geometry\";\nimport type { TextureMapper } from \"../../../../puzzle-geometry/PuzzleGeometry\";\nimport {\n  ExperimentalFaceletMeshStickeringMask,\n  experimentalGetFaceletStickeringMask,\n  ExperimentalStickeringMask,\n} from \"../../../../puzzles/cubing-private\";\nimport type { PuzzlePosition } from \"../../../controllers/AnimationTypes\";\nimport { smootherStep } from \"../../../controllers/easing\";\nimport type { HintFaceletStyle } from \"../../../model/props/puzzle/display/HintFaceletProp\";\nimport { TAU } from \"../TAU\";\nimport type { Twisty3DPuzzle } from \"./Twisty3DPuzzle\";\n\nconst foundationMaterial = new MeshBasicMaterial({\n  side: DoubleSide,\n  color: 0x000000,\n});\nconst invisMaterial = new MeshBasicMaterial({\n  visible: false,\n});\nconst basicStickerMaterial = new MeshBasicMaterial({\n  vertexColors: true,\n});\n\nfunction dist(coords: number[], a: number, b: number): number {\n  return Math.hypot(\n    coords[3 * a] - coords[3 * b],\n    coords[3 * a + 1] - coords[3 * b + 1],\n    coords[3 * a + 2] - coords[3 * b + 2],\n  );\n}\n\nfunction triarea(coords: number[], a: number, b: number, c: number): number {\n  const ab = dist(coords, a, b);\n  const bc = dist(coords, b, c);\n  const ac = dist(coords, a, c);\n  const p = (ab + bc + ac) / 2;\n  return Math.sqrt(p * (p - ab) * (p - bc) * (p - ac));\n}\n\nfunction polyarea(coords: number[]): number {\n  let sum = 0;\n  for (let i = 2; 3 * i < coords.length; i++) {\n    sum += triarea(coords, 0, 1, i);\n  }\n  return sum;\n}\n\nfunction normalize(r: number[]): number[] {\n  const m = Math.hypot(r[0], r[1], r[2]);\n  r[0] /= m;\n  r[1] /= m;\n  r[2] /= m;\n  return r;\n}\n\nfunction cross(a: number[], b: number[]): number[] {\n  const r = new Array<number>(3);\n  r[0] = a[1] * b[2] - a[2] * b[1];\n  r[1] = a[2] * b[0] - a[0] * b[2];\n  r[2] = a[0] * b[1] - a[1] * b[0];\n  return r;\n}\n\nfunction normal(c: number[]): number[] {\n  const a: number[] = [c[3] - c[0], c[4] - c[1], c[5] - c[2]];\n  const b: number[] = [c[6] - c[3], c[7] - c[4], c[8] - c[5]];\n  const r = cross(a, b);\n  return normalize(r);\n}\n\nfunction trimEdges(face: number[], tr: number): number[] {\n  const r: number[] = [];\n  const A: number[] = new Array(3);\n  const B: number[] = new Array(3);\n  for (let iter = 1; iter < 10; iter++) {\n    for (let i = 0; i < face.length; i += 3) {\n      const pi = (i + face.length - 3) % face.length;\n      const ni = (i + 3) % face.length;\n      for (let k = 0; k < 3; k++) {\n        A[k] = face[pi + k] - face[i + k];\n        B[k] = face[ni + k] - face[i + k];\n      }\n      const alen = Math.hypot(A[0], A[1], A[2]);\n      const blen = Math.hypot(B[0], B[1], B[2]);\n      for (let k = 0; k < 3; k++) {\n        A[k] /= alen;\n        B[k] /= blen;\n      }\n      const d = A[0] * B[0] + A[1] * B[1] + A[2] * B[2];\n      const m = tr / Math.sqrt(1 - d * d);\n      for (let k = 0; k < 3; k++) {\n        r[i + k] = face[i + k] + (A[k] + B[k]) * m;\n      }\n    }\n    let good = true;\n    for (let i = 0; good && i < r.length; i += 3) {\n      const ni = (i + 3) % face.length;\n      let t = 0;\n      for (let k = 0; k < 3; k++) {\n        const a = face[ni + k] - face[i + k];\n        const b = r[ni + k] - r[i + k];\n        t += a * b;\n      }\n      if (t <= 0) {\n        good = false;\n      }\n    }\n    if (good) {\n      return r;\n    }\n    tr /= 2;\n  }\n  return face;\n}\n\nclass Filler {\n  pos: number;\n  ipos: number;\n  vertices: Float32Array;\n  colors: Uint8Array;\n  uvs?: Float32Array;\n  ind: Uint8Array;\n  constructor(public sz: number, public tm: TextureMapper) {\n    this.vertices = new Float32Array(9 * sz);\n    this.uvs = undefined;\n    this.colors = new Uint8Array(18 * sz);\n    this.ind = new Uint8Array(sz);\n    this.pos = 0;\n    this.ipos = 0;\n  }\n\n  add(pt: number[], i: number, c: number) {\n    this.vertices[this.pos] = pt[3 * i + 0];\n    this.vertices[this.pos + 1] = pt[3 * i + 1];\n    this.vertices[this.pos + 2] = pt[3 * i + 2];\n    this.colors[this.pos] = c >> 16;\n    this.colors[this.pos + 1] = (c >> 8) & 255;\n    this.colors[this.pos + 2] = c & 255;\n    this.pos += 3;\n  }\n\n  addUncolored(pt: number[], i: number) {\n    this.vertices[this.pos] = pt[3 * i + 0];\n    this.vertices[this.pos + 1] = pt[3 * i + 1];\n    this.vertices[this.pos + 2] = pt[3 * i + 2];\n    this.pos += 3;\n  }\n\n  setind(i: number) {\n    this.ind[this.ipos++] = i;\n  }\n\n  makePoly(coords: number[], color: number, ind: number): void {\n    const ncoords: number[] = coords;\n    for (let g = 1; 3 * (g + 1) < ncoords.length; g++) {\n      this.add(ncoords, 0, color);\n      this.add(ncoords, g, color);\n      this.add(ncoords, g + 1, color);\n      this.setind(ind);\n    }\n  }\n\n  setAttributes(geo: BufferGeometry) {\n    geo.setAttribute(\"position\", new BufferAttribute(this.vertices, 3));\n    // the geometry only needs the first half of the array\n    const sa2 = this.colors.subarray(0, 9 * this.sz);\n    geo.setAttribute(\"color\", new BufferAttribute(sa2, 3, true));\n  }\n\n  makeGroups(geo: BufferGeometry) {\n    geo.clearGroups();\n    for (let i = 0; i < this.ipos; ) {\n      const si = i++;\n      const iv = this.ind[si];\n      while (this.ind[i] === iv) {\n        i++;\n      }\n      geo.addGroup(3 * si, 3 * (i - si), iv);\n    }\n  }\n\n  saveOriginalColors() {\n    this.colors.copyWithin(this.pos, 0, this.pos);\n  }\n}\n\nclass StickerDef {\n  private origColor: number;\n  private origColorStickeringMask: number;\n  private faceColor: number;\n  private texturePtr?: StickerDef = undefined;\n  public twistVal: number = -1;\n  public stickerStart: number;\n  public stickerEnd: number;\n  public hintStart: number;\n  public hintEnd: number;\n  public foundationStart: number;\n  public foundationEnd: number;\n  private isDup: boolean;\n  private faceNum: number;\n  constructor(\n    filler: Filler,\n    stickerDat: StickerDatSticker,\n    trim: number,\n    options?: {\n      stickeringMask?: ExperimentalFaceletMeshStickeringMask;\n    },\n  ) {\n    this.isDup = !!stickerDat.isDup;\n    this.faceNum = stickerDat.face;\n    this.stickerStart = filler.ipos;\n    const sdColor = new Color(stickerDat.color).getHex();\n    this.origColor = sdColor;\n    this.origColorStickeringMask = sdColor;\n    if (options?.stickeringMask) {\n      this.setStickeringMask(filler, options.stickeringMask);\n    }\n    this.faceColor = sdColor;\n    const coords = this.stickerCoords(stickerDat.coords, trim);\n    filler.makePoly(coords, this.faceColor, this.isDup ? 4 : 0);\n    this.stickerEnd = filler.ipos;\n  }\n\n  private stickerCoords(coords: number[], trim: number): number[] {\n    return trimEdges(coords.slice(), trim);\n  }\n\n  private hintCoords(\n    coords: number[],\n    hintStickerHeightScale: number,\n    trim: number,\n    normal: number[],\n  ): number[] {\n    coords = this.stickerCoords(coords, trim); // pick up trim from stickers\n    normal = normal.slice();\n    for (let i = 0; i < 3; i++) {\n      normal[i] *= 0.5 * hintStickerHeightScale;\n    }\n    const hCoords = new Array<number>(coords.length);\n    for (let i = 0; 3 * i < coords.length; i++) {\n      const j = coords.length / 3 - 1 - i;\n      hCoords[3 * i] = coords[3 * j] + normal[0];\n      hCoords[3 * i + 1] = coords[3 * j + 1] + normal[1];\n      hCoords[3 * i + 2] = coords[3 * j + 2] + normal[2];\n    }\n    return hCoords;\n  }\n\n  private foundationCoords(coords: number[]): number[] {\n    const ncoords = coords.slice();\n    for (let i = 0; i < coords.length; i++) {\n      ncoords[i] = coords[i] * 0.999;\n    }\n    return ncoords;\n  }\n\n  addHint(\n    filler: Filler,\n    stickerDat: StickerDatSticker,\n    hintStickers: boolean,\n    hintStickerHeightScale: number,\n    trim: number,\n    normal: number[],\n  ): void {\n    this.hintStart = filler.ipos;\n    const coords = this.hintCoords(\n      stickerDat.coords,\n      hintStickerHeightScale,\n      trim,\n      normal,\n    );\n    filler.makePoly(\n      coords,\n      this.faceColor,\n      hintStickers && !this.isDup ? 2 : 4,\n    );\n    this.hintEnd = filler.ipos;\n  }\n\n  public addFoundation(\n    filler: Filler,\n    stickerDat: StickerDatSticker,\n    black: number,\n  ) {\n    this.foundationStart = filler.ipos;\n    const coords = this.foundationCoords(stickerDat.coords);\n    filler.makePoly(coords, black, this.isDup ? 4 : 6);\n    this.foundationEnd = filler.ipos;\n  }\n\n  private setHintStickers(filler: Filler, hintStickers: boolean): void {\n    const indv = this.isDup || !hintStickers ? 4 : 2;\n    for (let i = this.hintStart; i < this.hintEnd; i++) {\n      filler.ind[i] = indv | (filler.ind[i] & 1);\n    }\n  }\n\n  setStickeringMask(\n    filler: Filler,\n    faceletMeshStickeringMask: ExperimentalFaceletMeshStickeringMask,\n  ): void {\n    let c = 0;\n    switch (faceletMeshStickeringMask) {\n      case \"regular\": {\n        c = this.origColor;\n        break;\n      }\n      case \"dim\": {\n        if (this.origColor === 0xffffff) {\n          c = 0xdddddd;\n        } else {\n          c = new Color(this.origColor).multiplyScalar(0.5).getHex();\n        }\n        break;\n      }\n      case \"oriented\": {\n        c = 0xff88ff;\n        break;\n      }\n      case \"ignored\": {\n        c = 0x444444;\n        break;\n      }\n      case \"invisible\":\n        c = this.origColor;\n    }\n    this.origColorStickeringMask = c;\n    for (let i = 9 * this.stickerStart; i < 9 * this.stickerEnd; i += 3) {\n      filler.colors[filler.pos + i] = c >> 16;\n      filler.colors[filler.pos + i + 1] = (c >> 8) & 255;\n      filler.colors[filler.pos + i + 2] = c & 255;\n    }\n    for (let i = 9 * this.hintStart; i < 9 * this.hintEnd; i += 3) {\n      filler.colors[filler.pos + i] = c >> 16;\n      filler.colors[filler.pos + i + 1] = (c >> 8) & 255;\n      filler.colors[filler.pos + i + 2] = c & 255;\n    }\n    this.setHintStickers(\n      filler,\n      faceletMeshStickeringMask !== \"invisible\" && !this.isDup,\n    );\n  }\n\n  public addUVs(filler: Filler): void {\n    const uvs = filler.uvs!;\n    const vert = filler.vertices;\n    const coords = new Array(3);\n    for (let i = 3 * this.stickerStart; i < 3 * this.stickerEnd; i++) {\n      coords[0] = vert[3 * i];\n      coords[1] = vert[3 * i + 1];\n      coords[2] = vert[3 * i + 2];\n      const uv = filler.tm.getuv(this.faceNum, coords);\n      uvs[2 * i] = uv[0];\n      uvs[2 * i + 1] = uv[1];\n    }\n    for (let i = 3 * this.hintStart; i < 3 * this.hintEnd; i++) {\n      coords[0] = vert[3 * i];\n      coords[1] = vert[3 * i + 1];\n      coords[2] = vert[3 * i + 2];\n      const uv = filler.tm.getuv(this.faceNum, coords);\n      uvs[2 * i] = uv[0];\n      uvs[2 * i + 1] = uv[1];\n    }\n  }\n\n  public setTexture(filler: Filler, sd: StickerDef): number {\n    if (this.texturePtr === sd) {\n      return 0;\n    }\n    this.texturePtr = sd;\n    const sz = 6 * filler.sz;\n    filler.uvs!.copyWithin(\n      6 * this.stickerStart,\n      6 * sd.stickerStart + sz,\n      6 * sd.stickerEnd + sz,\n    );\n    filler.uvs!.copyWithin(\n      6 * this.hintStart,\n      6 * sd.hintStart + sz,\n      6 * sd.hintEnd + sz,\n    );\n    return 1;\n  }\n\n  public setColor(filler: Filler, sd: StickerDef): number {\n    const c = sd.origColorStickeringMask;\n    if (this.faceColor !== c) {\n      this.faceColor = c;\n      const sz = filler.pos;\n      filler.colors.copyWithin(\n        9 * this.stickerStart,\n        9 * sd.stickerStart + sz,\n        9 * sd.stickerEnd + sz,\n      );\n      filler.colors.copyWithin(\n        9 * this.hintStart,\n        9 * sd.hintStart + sz,\n        9 * sd.hintEnd + sz,\n      );\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n}\n\nclass HitPlaneDef {\n  public cubie: Group;\n  private geo: BufferGeometry;\n  constructor(hitface: any, tm: TextureMapper, stickerDat: StickerDat) {\n    this.cubie = new Group();\n    const coords = hitface.coords as number[];\n    const filler = new Filler(coords.length / 3 - 2, tm);\n    for (let g = 1; 3 * g + 3 < coords.length; g++) {\n      filler.addUncolored(coords, 0);\n      filler.addUncolored(coords, g);\n      filler.addUncolored(coords, g + 1);\n    }\n    this.geo = new BufferGeometry();\n    filler.setAttributes(this.geo);\n    const obj = new Mesh(this.geo, invisMaterial);\n    obj.userData.quantumMove = stickerDat.notationMapper.notationToExternal(\n      new Move(hitface.name),\n    );\n    this.cubie.scale.setScalar(0.99);\n    this.cubie.add(obj);\n  }\n}\n\nclass AxisInfo {\n  public axis: Vector3;\n  public order: number;\n  constructor(axisDat: StickerDatAxis) {\n    const vec = axisDat.coordinates;\n    this.axis = new Vector3(vec[0], vec[1], vec[2]);\n    this.order = axisDat.order;\n  }\n}\n\nexport interface PG3DOptions {\n  stickeringMask?: ExperimentalStickeringMask;\n}\n\nconst DEFAULT_COLOR_FRACTION = 0.71;\nconst PG_SCALE = 0.5;\n\n// TODO: Split into \"scene model\" and \"view\".\n/*\n *  PG3D uses a single geometry for the puzzle, with all the faces for\n *  each sticker (including the foundation stickers) in a single\n *  geometry.  We use the materialIndex in the face to point to a\n *  specific entry, which is either a colored sticker, invisible, or\n *  black (foundation).\n *\n *  To support general twisting of a subset of the puzzle, we then\n *  instantiate this same geometry in two different meshes with two\n *  distinct material arrays.  One, the fixed mesh, has the material\n *  array set up like:  [colored, invisible, black, invisible].\n *  The twisting mesh has the material array set up as\n *  [invisible, colored, invislble, black].  When not twisted, the\n *  two meshes are directly coincident, and the (shared) materialIndex\n *  in each face points to a non-invisible material in exactly one of\n *  the two meshes.  When we decide to twist some cubies, we make\n *  the cubies that move point to visible materials in the moving\n *  mesh (which makes them point to invisible materials in the static\n *  mesh).  This way, we only need to rotate the moving mesh as a\n *  single object---this should be very fast, and occur entirely in\n *  the GPU.  Unfortunately this doesn't quite work as fast as we'd\n *  like because three.js makes a draw call every time we have a change\n *  in the material index.  By moving the foundation triangles separate\n *  from the sticker triangles, we enhance the probability that many\n *  triangles can be rendered in one call speeding up the render.\n *  We also get some assistance from puzzleGeometry to try to keep\n *  nearby stickers close to each other.\n */\nexport class PG3D extends Object3D implements Twisty3DPuzzle {\n  private stickers: { [key: string]: StickerDef[][] };\n  private axesInfo: { [key: string]: AxisInfo };\n\n  private stickerTargets: Object3D[] = [];\n  private controlTargets: Object3D[] = [];\n\n  private movingObj: Object3D;\n  private filler: Filler;\n  private foundationBound: number; // before this: colored; after: black\n  private fixedGeo: BufferGeometry;\n  private lastPos: PuzzlePosition;\n  private lastMoveTransformation: KTransformation;\n  private hintMaterial: Material;\n  private stickerMaterial: Material;\n  private materialArray1: Material[];\n  private materialArray2: Material[];\n  private textured: boolean = false;\n  private showHintStickers: boolean = false;\n  private showFoundations: boolean = false;\n  private hintMaterialDisposable: boolean;\n  private stickerMaterialDisposable: boolean;\n\n  #pendingStickeringUpdate: boolean = false;\n\n  public isPG3DForTwisty3DPuzzleWrapper: true;\n\n  constructor(\n    private scheduleRenderCallback: () => void,\n    private kpuzzle: KPuzzle,\n    private stickerDat: StickerDat,\n    enableFoundationOpt: boolean = false,\n    enableHintStickersOpt: boolean = false,\n    hintStickerHeightScale: number = 1,\n    private faceletScale: \"auto\" | number = 1,\n    private params: PG3DOptions = {},\n  ) {\n    super();\n    if (stickerDat.stickers.length === 0) {\n      throw Error(\"Reuse of stickerdat from pg; please don't do that.\");\n    }\n    this.hintMaterial = new MeshBasicMaterial({\n      vertexColors: true,\n      transparent: true,\n      opacity: 0.5,\n    });\n    this.hintMaterialDisposable = true;\n    this.stickerMaterial = basicStickerMaterial;\n    this.stickerMaterialDisposable = false;\n    this.axesInfo = {};\n    const axesDef = this.stickerDat.axis;\n    for (const axis of axesDef) {\n      this.axesInfo[axis.quantumMove.family] = new AxisInfo(axis);\n    }\n    const stickers = this.stickerDat.stickers as any[];\n    this.stickers = {};\n    this.materialArray1 = new Array(8);\n    this.materialArray2 = new Array(8);\n    // TODO: the argument enableFoundationOpt really means, do we ever want to display\n    // foundations.  But it is presently *used* to mean, show foundations initially\n    // (and maybe setStickeringMask changes this).  So for now we set up the\n    // show flag from the enable flag, and turn on the enable flag so later when it's\n    // used we will get the foundations.  What this means is the geometry always \"pays\"\n    // for foundations, even if they aren't displayed.\n    this.showFoundation(enableFoundationOpt);\n    enableFoundationOpt = true;\n    let triangleCount = 0;\n    const multiplier = 3;\n    for (const sticker of stickers) {\n      const sides = sticker.coords.length / 3;\n      triangleCount += multiplier * (sides - 2);\n    }\n    const filler = new Filler(triangleCount, stickerDat.textureMapper);\n    const black = 0;\n    const normals: number[][] = [];\n    let totArea = 0;\n    for (const f of stickerDat.faces) {\n      normals.push(normal(f.coords));\n      totArea += polyarea(f.coords);\n    }\n    const colorfrac =\n      faceletScale !== \"auto\"\n        ? faceletScale * faceletScale\n        : DEFAULT_COLOR_FRACTION;\n    let nonDupStickers = 0;\n    for (const sticker of stickers) {\n      if (!sticker.isDup) {\n        nonDupStickers++;\n      }\n    }\n    const trim =\n      (Math.sqrt(totArea / nonDupStickers) * (1 - Math.sqrt(colorfrac))) / 2;\n    for (const sticker of stickers) {\n      const orbit = sticker.orbit;\n      const ord = sticker.ord;\n      const ori = sticker.ori;\n      if (!this.stickers[orbit]) {\n        this.stickers[orbit] = [];\n      }\n      if (!this.stickers[orbit][ori]) {\n        this.stickers[orbit][ori] = [];\n      }\n      const options: {\n        stickeringMask?: ExperimentalFaceletMeshStickeringMask;\n      } = {};\n      if (params.stickeringMask) {\n        options.stickeringMask = experimentalGetFaceletStickeringMask(\n          params.stickeringMask,\n          orbit,\n          ord,\n          ori,\n          false,\n        );\n      }\n      const stickerdef = new StickerDef(filler, sticker, trim, options);\n      this.stickers[orbit][ori][ord] = stickerdef;\n    }\n    // TODO: the argument enableHintStickersOpt really means, do we ever want to display\n    // hint stickers.  But it is presently *used* to mean, show hint stickers initially\n    // (and maybe setStickeringMask changes this).  So for now we set up the\n    // show flag from the enable flag, and turn on the enable flag so later when it's\n    // used we will get the hint stickers.  What this means is the geometry always \"pays\"\n    // for hint stickers, even if they aren't displayed.\n    this.showHintStickers = enableHintStickersOpt;\n    enableHintStickersOpt = true;\n    for (const sticker of stickers) {\n      const orbit = sticker.orbit;\n      const ord = sticker.ord;\n      const ori = sticker.ori;\n      this.stickers[orbit][ori][ord].addHint(\n        filler,\n        sticker,\n        enableHintStickersOpt,\n        hintStickerHeightScale,\n        trim,\n        normals[sticker.face],\n      );\n    }\n    this.foundationBound = filler.ipos;\n    for (const sticker of stickers) {\n      const orbit = sticker.orbit;\n      const ord = sticker.ord;\n      const ori = sticker.ori;\n      if (enableFoundationOpt) {\n        this.stickers[orbit][ori][ord].addFoundation(filler, sticker, black);\n      }\n    }\n    const fixedGeo = new BufferGeometry();\n    filler.setAttributes(fixedGeo);\n    filler.makeGroups(fixedGeo);\n    const obj = new Mesh(fixedGeo, this.materialArray1);\n    obj.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);\n    this.add(obj);\n    const obj2 = new Mesh(fixedGeo, this.materialArray2);\n    obj2.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);\n    this.add(obj2);\n    const hitfaces = this.stickerDat.faces as any[];\n    this.movingObj = obj2;\n    this.fixedGeo = fixedGeo;\n    this.filler = filler;\n    for (const hitface of hitfaces) {\n      const facedef = new HitPlaneDef(\n        hitface,\n        stickerDat.textureMapper,\n        this.stickerDat,\n      );\n      facedef.cubie.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);\n      this.add(facedef.cubie);\n      this.controlTargets.push(facedef.cubie.children[0]);\n    }\n    filler.saveOriginalColors();\n    stickerDat.stickers = []; // don't need these anymore\n    this.updateMaterialArrays();\n    /*\n    this.experimentalUpdateTexture(\n      true,\n      new TextureLoader().load(\n        \"/experiments.cubing.net/cubing.js/twisty/mkbhd-sprite-red.png\",\n      ),\n      new TextureLoader().load(\n        \"/experiments.cubing.net/cubing.js/twisty/mkbhd-sprite-red-hint.png\",\n      ),\n    );\n    */\n  }\n\n  public dispose(): void {\n    if (this.fixedGeo) {\n      this.fixedGeo.dispose();\n    }\n    if (this.stickerMaterialDisposable) {\n      this.stickerMaterial.dispose();\n      this.stickerMaterial = basicStickerMaterial;\n      this.stickerMaterialDisposable = false;\n    }\n    if (this.hintMaterialDisposable) {\n      this.hintMaterial.dispose();\n      this.hintMaterial = basicStickerMaterial;\n      this.hintMaterialDisposable = false;\n    }\n  }\n\n  public experimentalGetStickerTargets(): Object3D[] {\n    return this.stickerTargets;\n  }\n\n  public experimentalGetControlTargets(): Object3D[] {\n    return this.controlTargets;\n  }\n\n  #isValidMove(move: Move): boolean {\n    try {\n      this.kpuzzle.moveToTransformation(move);\n      return true;\n    } catch (_) {\n      return false;\n    }\n  }\n\n  getClosestMoveToAxis(\n    point: Vector3,\n    transformations: {\n      invert: boolean;\n      depth?: \"secondSlice\" | \"rotation\" | \"none\";\n    },\n  ): { move: Move; order: number } | null {\n    let closestMove: Move | null = null;\n    let closestMoveDotProduct: number = 0;\n\n    let modify: (move: Move) => Move = (m) => m;\n    switch (transformations.depth) {\n      case \"secondSlice\": {\n        modify = (m: Move) => m.modified({ innerLayer: 2 });\n        break;\n      }\n      case \"rotation\": {\n        modify = (m: Move) => m.modified({ family: `${m.family}v` });\n        break;\n      }\n    }\n\n    for (const axis of this.stickerDat.axis) {\n      const product = point.dot(new Vector3(...axis.coordinates));\n      if (product > closestMoveDotProduct) {\n        const modified = this.stickerDat.notationMapper.notationToExternal(\n          modify(axis.quantumMove),\n        );\n        if (!modified) {\n          continue;\n        }\n        if (this.#isValidMove(modified)) {\n          closestMoveDotProduct = product;\n          closestMove = modified;\n        }\n      }\n    }\n\n    if (!closestMove) {\n      return null;\n    }\n\n    if (transformations.invert) {\n      closestMove = closestMove.invert();\n    }\n    const order = this.kpuzzle\n      .moveToTransformation(closestMove)\n      .repetitionOrder();\n    return { move: closestMove, order }; // TODO: push this down\n  }\n\n  setStickeringMask(stickeringMask: ExperimentalStickeringMask): void {\n    this.params.stickeringMask = stickeringMask;\n    if (stickeringMask.specialBehaviour !== \"picture\") {\n      for (const orbitName in this.kpuzzle.definition.orbits) {\n        const { numPieces, numOrientations: orientations } =\n          this.kpuzzle.definition.orbits[orbitName];\n        for (let pieceIdx = 0; pieceIdx < numPieces; pieceIdx++) {\n          for (let faceletIdx = 0; faceletIdx < orientations; faceletIdx++) {\n            const faceletStickeringMask = experimentalGetFaceletStickeringMask(\n              stickeringMask,\n              orbitName,\n              pieceIdx,\n              faceletIdx,\n              false,\n            );\n            const stickerDef = this.stickers[orbitName][faceletIdx][pieceIdx];\n            if (\n              this.textured &&\n              this.hintMaterialDisposable &&\n              faceletStickeringMask === \"invisible\"\n            ) {\n              // ignore \"invisible\" if textured hints\n            } else {\n              stickerDef.setStickeringMask(this.filler, faceletStickeringMask);\n            }\n          }\n        }\n      }\n    }\n    this.#pendingStickeringUpdate = true;\n    if (this.lastPos) {\n      this.onPositionChange(this.lastPos);\n    }\n  }\n\n  public onPositionChange(p: PuzzlePosition): void {\n    const transformation = p.state.experimentalToTransformation();\n    if (!transformation) {\n      throw new Error(\"indistinguishable pieces are not supported by PG3D yet\");\n    }\n    const noRotation = new Euler();\n    this.movingObj.rotation.copy(noRotation);\n    let colormods = 0;\n    const filler = this.filler;\n    const ind = filler.ind;\n    if (\n      !this.lastPos ||\n      this.#pendingStickeringUpdate ||\n      !this.lastPos.state\n        .experimentalToTransformation()!\n        .isIdentical(transformation)\n    ) {\n      for (const orbit in this.stickers) {\n        const pieces = this.stickers[orbit];\n        const pos2 = transformation.transformationData[orbit];\n        const orin = pieces.length;\n        if (orin === 1) {\n          const pieces2 = pieces[0];\n          for (let i = 0; i < pieces2.length; i++) {\n            const ni = pos2.permutation[i];\n            if (this.textured) {\n              colormods += pieces2[i].setTexture(filler, pieces2[ni]);\n            } else {\n              colormods += pieces2[i].setColor(filler, pieces2[ni]);\n            }\n          }\n        } else {\n          for (let ori = 0; ori < orin; ori++) {\n            const pieces2 = pieces[ori];\n            for (let i = 0; i < pieces2.length; i++) {\n              const nori = (ori + orin - pos2.orientation[i]) % orin;\n              const ni = pos2.permutation[i];\n              if (this.textured) {\n                colormods += pieces2[i].setTexture(filler, pieces[nori][ni]);\n              } else {\n                colormods += pieces2[i].setColor(filler, pieces[nori][ni]);\n              }\n            }\n          }\n        }\n      }\n      this.lastPos = p;\n    }\n    let vismods = 0;\n    for (const moveProgress of p.movesInProgress) {\n      const externalMove = moveProgress.move;\n      // TODO: unswizzle goes external to internal, and so does the call after that\n      // and so does the stateForBlockMove call\n      const unswizzled = this.stickerDat.unswizzle(externalMove);\n      if (!unswizzled) {\n        // bad times, but let's not throw.\n        return;\n      }\n\n      const move = externalMove;\n      let quantumTransformation;\n      try {\n        quantumTransformation = this.kpuzzle.moveToTransformation(\n          move.modified({ amount: 1 }),\n        );\n      } catch (e) {\n        // couldn't get it from a quantum of the external move.  Let's try\n        // getting it from a quantum of the internal move, translated back\n        // to external so we can get the transformation.  This happens for\n        // instance when working with \"x2\" on megaminx.\n        const move1 = this.stickerDat.notationMapper.notationToInternal(move);\n        if (move1) {\n          const move2 = this.stickerDat.notationMapper.notationToExternal(\n            move1.modified({ amount: 1 }),\n          );\n          if (move2) {\n            quantumTransformation = this.kpuzzle.moveToTransformation(move2);\n          }\n        }\n        if (!quantumTransformation) {\n          console.log(e);\n          throw e;\n        }\n      }\n      const ax = this.axesInfo[unswizzled.family];\n      const turnNormal = ax.axis;\n      const angle =\n        (-this.ease(moveProgress.fraction) *\n          moveProgress.direction *\n          unswizzled.amount *\n          TAU) /\n        ax.order;\n      this.movingObj.rotateOnAxis(turnNormal, angle);\n      if (this.lastMoveTransformation !== quantumTransformation) {\n        for (const orbit in this.stickers) {\n          const pieces = this.stickers[orbit];\n          const orin = pieces.length;\n          const bmv = quantumTransformation.transformationData[orbit];\n          for (let ori = 0; ori < orin; ori++) {\n            const pieces2 = pieces[ori];\n            for (let i = 0; i < pieces2.length; i++) {\n              const p2 = pieces2[i];\n              const ni = bmv.permutation[i];\n              let tv = 0;\n              if (ni !== i || bmv.orientation[i] !== 0) {\n                tv = 1;\n              }\n              if (tv !== p2.twistVal) {\n                if (tv) {\n                  for (let j = p2.stickerStart; j < p2.stickerEnd; j++) {\n                    ind[j] |= 1;\n                  }\n                  for (let j = p2.hintStart; j < p2.hintEnd; j++) {\n                    ind[j] |= 1;\n                  }\n                  for (let j = p2.foundationStart; j < p2.foundationEnd; j++) {\n                    ind[j] |= 1;\n                  }\n                } else {\n                  for (let j = p2.stickerStart; j < p2.stickerEnd; j++) {\n                    ind[j] &= ~1;\n                  }\n                  for (let j = p2.hintStart; j < p2.hintEnd; j++) {\n                    ind[j] &= ~1;\n                  }\n                  for (let j = p2.foundationStart; j < p2.foundationEnd; j++) {\n                    ind[j] &= ~1;\n                  }\n                }\n                p2.twistVal = tv;\n                vismods++;\n              }\n            }\n          }\n        }\n        this.lastMoveTransformation = quantumTransformation;\n      }\n    }\n    if (this.#pendingStickeringUpdate || vismods) {\n      this.filler.makeGroups(this.fixedGeo);\n    }\n    if (this.#pendingStickeringUpdate || colormods) {\n      if (this.textured) {\n        (this.fixedGeo.getAttribute(\"uv\") as BufferAttribute).updateRange = {\n          offset: 0,\n          count: 6 * this.foundationBound,\n        };\n        (\n          this.fixedGeo.getAttribute(\"uv\") as BufferAttribute\n        ).needsUpdate = true;\n      }\n      if (this.#pendingStickeringUpdate || !this.textured) {\n        (this.fixedGeo.getAttribute(\"color\") as BufferAttribute).updateRange = {\n          offset: 0,\n          count: 9 * this.foundationBound,\n        };\n        (\n          this.fixedGeo.getAttribute(\"color\") as BufferAttribute\n        ).needsUpdate = true;\n      }\n    }\n    this.scheduleRenderCallback();\n    this.#pendingStickeringUpdate = false;\n  }\n\n  private ease(fraction: number): number {\n    return smootherStep(fraction);\n  }\n\n  private showHintFacelets(v: boolean) {\n    this.showHintStickers = v;\n  }\n\n  private updateMaterialArrays() {\n    for (let i = 0; i < 8; i++) {\n      this.materialArray1[i] = invisMaterial;\n      this.materialArray2[i] = invisMaterial;\n    }\n    this.materialArray1[0] = this.stickerMaterial;\n    this.materialArray2[1] = this.stickerMaterial;\n    if (this.showHintStickers) {\n      this.materialArray1[2] = this.hintMaterial;\n      this.materialArray2[3] = this.hintMaterial;\n    } else {\n      this.materialArray1[2] = invisMaterial;\n      this.materialArray2[3] = invisMaterial;\n    }\n    if (this.showFoundations) {\n      this.materialArray1[6] = foundationMaterial;\n      this.materialArray2[7] = foundationMaterial;\n    } else {\n      this.materialArray1[6] = invisMaterial;\n      this.materialArray2[7] = invisMaterial;\n    }\n  }\n\n  private showFoundation(v: boolean) {\n    this.showFoundations = v;\n  }\n\n  private setHintStickerOpacity(v: number): void {\n    if (this.hintMaterialDisposable) {\n      this.hintMaterial.dispose();\n      this.hintMaterialDisposable = false;\n    }\n    if (v === 0) {\n      this.hintMaterial = invisMaterial;\n    } else if (v === 1) {\n      this.hintMaterial = this.stickerMaterial;\n    } else {\n      this.hintMaterial = new MeshBasicMaterial({\n        vertexColors: true,\n        transparent: true,\n        opacity: v,\n      });\n      this.hintMaterialDisposable = true;\n    }\n  }\n\n  public experimentalUpdateOptions(options: {\n    showMainStickers?: boolean;\n    hintFacelets?: HintFaceletStyle;\n    showFoundation?: boolean; // TODO: better name\n    hintStickerOpacity?: number;\n    faceletScale?: \"auto\" | number;\n  }): void {\n    if (options.hintFacelets !== undefined) {\n      this.showHintFacelets(options.hintFacelets !== \"none\");\n    }\n    if (options.showFoundation !== undefined) {\n      this.showFoundation(options.showFoundation);\n    }\n    if (options.hintStickerOpacity !== undefined) {\n      this.setHintStickerOpacity(options.hintStickerOpacity);\n    }\n    this.#pendingStickeringUpdate = true;\n    if (this.lastPos) {\n      this.onPositionChange(this.lastPos);\n    }\n    if (\n      typeof options.faceletScale !== \"undefined\" &&\n      options.faceletScale !== this.faceletScale\n    ) {\n      console.warn(\n        \"Dynamic facelet scale is not yet supported for PG3D. For now, re-create the TwistyPlayer to change the facelet scale.\",\n      );\n    }\n    this.updateMaterialArrays();\n    this.scheduleRenderCallback();\n  }\n\n  private adduvs() {\n    const filler = this.filler;\n    if (filler.uvs) {\n      return;\n    }\n    this.filler.uvs = new Float32Array(12 * filler.sz);\n    for (const orbit in this.stickers) {\n      const pieces = this.stickers[orbit];\n      const orin = pieces.length;\n      for (let ori = 0; ori < orin; ori++) {\n        const pieces2 = pieces[ori];\n        for (const piece2 of pieces2) {\n          piece2.addUVs(this.filler);\n        }\n      }\n    }\n    filler.uvs!.copyWithin(6 * filler.sz, 0, 6 * filler.sz);\n    const sa1 = filler.uvs!.subarray(0, 6 * filler.sz);\n    this.fixedGeo.setAttribute(\"uv\", new BufferAttribute(sa1, 2, true));\n  }\n\n  public experimentalUpdateTexture(\n    enabled: boolean,\n    stickerTexture?: Texture | null,\n    hintTexture?: Texture | null,\n  ) {\n    if (!stickerTexture) {\n      enabled = false;\n    }\n    if (enabled && !this.filler.uvs) {\n      this.adduvs();\n    }\n    this.textured = enabled;\n    if (this.stickerMaterialDisposable) {\n      this.stickerMaterial.dispose();\n      this.stickerMaterialDisposable = false;\n    }\n    if (enabled) {\n      this.stickerMaterial = new MeshBasicMaterial({\n        map: stickerTexture,\n        side: FrontSide,\n        transparent: false,\n      });\n      this.stickerMaterialDisposable = true;\n    } else {\n      this.stickerMaterial = basicStickerMaterial;\n    }\n    if (this.hintMaterialDisposable) {\n      this.hintMaterial.dispose();\n      this.hintMaterialDisposable = false;\n    }\n    if (enabled) {\n      this.hintMaterial = new MeshBasicMaterial({\n        map: hintTexture,\n        side: FrontSide,\n        transparent: true,\n      });\n      this.hintMaterialDisposable = true;\n    } else {\n      this.hintMaterial = basicStickerMaterial;\n    }\n    if (enabled) {\n      this.showHintFacelets(hintTexture !== null);\n    }\n    this.updateMaterialArrays();\n    this.#pendingStickeringUpdate = true;\n    if (this.lastPos) {\n      this.onPositionChange(this.lastPos);\n    }\n    this.scheduleRenderCallback();\n  }\n}\n", "import type { Scene as ThreeScene } from \"three\";\nimport { THREEJS } from \"../../heavy-code-imports/3d\";\nimport type { Twisty3DPuzzle } from \"./puzzles/Twisty3DPuzzle\";\nimport type { Twisty3DRenderTarget } from \"./Twisty3DRenderTarget\";\n\nexport class Twisty3DScene implements Twisty3DRenderTarget {\n  private renderTargets: Set<Twisty3DRenderTarget> = new Set();\n  public twisty3Ds: Set<Twisty3DPuzzle> = new Set();\n\n  threeJSScene: Promise<ThreeScene> = (async () =>\n    new (await THREEJS).Scene())();\n  constructor() {}\n\n  addRenderTarget(renderTarget: Twisty3DRenderTarget): void {\n    this.renderTargets.add(renderTarget);\n  }\n\n  scheduleRender(): void {\n    for (const renderTarget of this.renderTargets) {\n      renderTarget.scheduleRender();\n    }\n  }\n\n  async addTwisty3DPuzzle(twisty3DPuzzle: Twisty3DPuzzle): Promise<void> {\n    this.twisty3Ds.add(twisty3DPuzzle);\n    (await this.threeJSScene).add(twisty3DPuzzle);\n    // TODO: scheduleRender?\n  }\n\n  async removeTwisty3DPuzzle(twisty3DPuzzle: Twisty3DPuzzle): Promise<void> {\n    this.twisty3Ds.delete(twisty3DPuzzle);\n    (await this.threeJSScene).remove(twisty3DPuzzle);\n    // TODO: scheduleRender?\n  }\n\n  async clearPuzzles(): Promise<void> {\n    for (const puz of this.twisty3Ds) {\n      (await this.threeJSScene).remove(puz);\n    }\n    this.twisty3Ds.clear();\n    // TODO: scheduleRender?\n  }\n}\n", "import { cube3x3x3, PuzzleLoader } from \"../../../puzzles\";\nimport type { HintFaceletStyle } from \"../../model/props/puzzle/display/HintFaceletProp\";\nimport type { FaceletScale } from \"../../model/props/puzzle/display/FaceletScaleProp\";\nimport { Cube3D, Cube3DOptions } from \"../../views/3D/puzzles/Cube3D\";\nimport { PG3D } from \"../../views/3D/puzzles/PG3D\";\n\n// Mangled to avoid autocompleting.\n// This must not be imported directly.\nexport * as T3I from \"three\";\nexport { Cube3D } from \"../../views/3D/puzzles/Cube3D\";\nexport { PG3D } from \"../../views/3D/puzzles/PG3D\";\nexport { Twisty3DScene } from \"../../views/3D/Twisty3DScene\";\n\nexport async function cube3DShim(\n  renderCallback: () => void,\n  options?: Cube3DOptions,\n): Promise<Cube3D> {\n  return new Cube3D(await cube3x3x3.kpuzzle(), renderCallback, options);\n}\n\n// TODO: take loader?\nexport async function pg3dShim(\n  renderCallback: () => void,\n  puzzleLoader: PuzzleLoader,\n  hintFacelets: HintFaceletStyle,\n  faceletScale: FaceletScale,\n): Promise<PG3D> {\n  return new PG3D(\n    renderCallback,\n    await puzzleLoader.kpuzzle(),\n    (await puzzleLoader.pg!()).get3d(),\n    true,\n    hintFacelets === \"floating\",\n    undefined,\n    faceletScale,\n  );\n}\n"],
  "mappings": "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",
  "names": ["smootherStep", "x", "svgLoader", "TextureLoader", "ignoredMaterial", "MeshBasicMaterial", "DoubleSide", "ignoredMaterialHint", "BackSide", "invisibleMaterial", "orientedMaterial", "orientedMaterialHint", "AxisInfo", "vector", "fromZ", "color", "dimColor", "hintOpacityScale", "options", "FrontSide", "axesInfo", "Vector3", "Euler", "TAU", "face", "familyToAxis", "cubieDimensions", "EXPERIMENTAL_PICTURE_CUBE_HINT_ELEVATION", "cube3DOptionsDefaults", "DEFAULT_STICKER_SCALE", "getFaceletScale", "options", "blackMesh", "MeshBasicMaterial", "blackTranslucentMesh", "CubieDef", "orbit", "stickerFaceNames", "q", "individualStickerFaceNames", "face", "Matrix4", "firstPiecePosition", "t", "v", "t4", "Quaternion", "TAU", "r", "Vector3", "orientationRotation", "i", "cubieStickerOrder", "pieceDefs", "CUBE_SCALE", "pictureStickerCoords", "sharedCubieFoundationGeometryCache", "sharedCubieFoundationGeometry", "BoxGeometry", "cubieDimensions", "newStickerGeometry", "BufferGeometry", "half", "BufferAttribute", "sharedStickerGeometryCache", "sharedStickerGeometry", "Cube3D", "Object3D", "kpuzzle", "scheduleRenderCallback", "resolve", "url", "svgLoader", "#sharedHintStickerGeometryCache", "orbitFaceletInfo", "#animateRaiseHintFacelets", "texture", "#sharedHintStickerGeometry", "haveStartedSharingRenderers", "translationRange", "hintStartTime", "lastTranslation", "translationDuration", "ease", "x", "animateRaiseHintSticker", "elapsed", "newTranslation", "stickerSpriteURL", "hintStickerSpriteURL", "stickeringMask", "pieceInfos", "faceletInfos", "faceletInfo", "invisibleMaterial", "hintFacelet", "orbitName", "orbitStickeringMask", "pieceIdx", "pieceStickeringMask", "pieceInfo", "faceletIdx", "faceletStickeringMask", "axesInfo", "hintStickeringMask", "showFoundation", "foundation", "hintFacelets", "hintFaceletStyles", "hintSticker", "experimentalStickeringMask", "faceletScale", "p", "reid333", "pieces", "j", "moveProgress", "move", "turnNormal", "familyToAxis", "moveMatrix", "quantumTransformation", "k", "orbitFacelets", "piece", "orbitPieceIdx", "cubieFaceletInfo", "cubie", "Group", "sticker", "rotate", "offsetX", "offsetY", "addImageSticker", "hint", "mesh", "BackSide", "DoubleSide", "x1", "x2", "y1", "y2", "v1", "Vector2", "v2", "v3", "v4", "box", "Mesh", "posAxisInfo", "materialAxisInfo", "isHint", "geo", "stickerMesh", "EXPERIMENTAL_PICTURE_CUBE_HINT_ELEVATION", "opacity", "orbitInfo", "fraction", "smootherStep", "foundationMaterial", "MeshBasicMaterial", "DoubleSide", "invisMaterial", "basicStickerMaterial", "dist", "coords", "a", "b", "triarea", "c", "ab", "bc", "ac", "p", "polyarea", "sum", "i", "normalize", "r", "m", "cross", "normal", "trimEdges", "face", "tr", "A", "B", "iter", "pi", "ni", "k", "alen", "blen", "d", "good", "t", "Filler", "sz", "tm", "pt", "color", "ind", "ncoords", "g", "geo", "BufferAttribute", "sa2", "si", "iv", "StickerDef", "filler", "stickerDat", "trim", "options", "sdColor", "Color", "hintStickerHeightScale", "hCoords", "j", "hintStickers", "black", "indv", "faceletMeshStickeringMask", "uvs", "vert", "uv", "sd", "HitPlaneDef", "hitface", "Group", "BufferGeometry", "obj", "Mesh", "Move", "AxisInfo", "axisDat", "vec", "Vector3", "DEFAULT_COLOR_FRACTION", "PG_SCALE", "PG3D", "Object3D", "scheduleRenderCallback", "kpuzzle", "enableFoundationOpt", "enableHintStickersOpt", "faceletScale", "params", "#pendingStickeringUpdate", "axesDef", "axis", "stickers", "triangleCount", "multiplier", "sticker", "sides", "normals", "totArea", "f", "colorfrac", "nonDupStickers", "orbit", "ord", "ori", "getFaceletStickeringMask", "stickerdef", "fixedGeo", "obj2", "hitfaces", "facedef", "#isValidMove", "move", "point", "transformations", "closestMove", "closestMoveDotProduct", "modify", "product", "modified", "order", "stickeringMask", "orbitName", "numPieces", "orientations", "pieceIdx", "faceletIdx", "faceletStickeringMask", "stickerDef", "transformation", "noRotation", "Euler", "colormods", "pieces", "pos2", "orin", "pieces2", "nori", "vismods", "moveProgress", "externalMove", "unswizzled", "quantumTransformation", "e", "move1", "move2", "ax", "turnNormal", "angle", "TAU", "bmv", "p2", "tv", "fraction", "smootherStep", "v", "piece2", "sa1", "enabled", "stickerTexture", "hintTexture", "FrontSide", "Twisty3DScene", "THREEJS", "renderTarget", "twisty3DPuzzle", "puz", "cube3DShim", "renderCallback", "options", "Cube3D", "cube3x3x3", "pg3dShim", "puzzleLoader", "hintFacelets", "faceletScale", "PG3D"]
}
