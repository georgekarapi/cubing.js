{
  "version": 3,
  "sources": ["../../../../src/cubing/kpuzzle/construct.ts", "../../../../src/cubing/kpuzzle/KTransformation.ts", "../../../../src/cubing/kpuzzle/calculate.ts", "../../../../src/cubing/kpuzzle/combine.ts", "../../../../src/cubing/kpuzzle/KState.ts", "../../../../src/cubing/kpuzzle/KPuzzle.ts", "../../../../src/cubing/kpuzzle/index.ts", "../../../../src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts", "../../../../src/cubing/puzzles/stickerings/puzzle-stickerings.ts", "../../../../src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts", "../../../../src/cubing/puzzles/PuzzleLoader.ts", "../../../../src/cubing/puzzles/implementations/dynamic/2x2x2/puzzle-orientation.ts", "../../../../src/cubing/puzzles/stickerings/mask.ts", "../../../../src/cubing/puzzles/stickerings/cube-like-stickerings.ts", "../../../../src/cubing/puzzles/async/lazy-cached.ts", "../../../../src/cubing/puzzles/async/async-pg3d.ts", "../../../../src/cubing/puzzles/customPGPuzzleLoader.ts", "../../../../src/cubing/puzzles/cubing-private/index.ts"],
  "sourcesContent": ["import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientation: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    definition.orbits,\n  )) {\n    transformation[orbitName] = constructIdentityOrbitTransformation(\n      orbitDefinition.numPieces,\n    );\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  const quantumKey = move.quantum.toString();\n  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey] as\n    | KTransformationData\n    | undefined;\n\n  if (!quantumMoveDefinition) {\n    const derivedFrom =\n      kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];\n\n    if (derivedFrom) {\n      // TODO: avoid the round trip?\n      quantumMoveDefinition =\n        kpuzzle.algToTransformation(derivedFrom).transformationData;\n    }\n  }\n\n  if (quantumMoveDefinition) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      quantumMoveDefinition,\n      move.amount,\n    );\n  }\n\n  // Handle e.g. `y2` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const moveDefinition = kpuzzle.definition.moves[move.toString()];\n  if (moveDefinition) {\n    return moveDefinition;\n  }\n\n  // Handle e.g. `y2'` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const inverseMoveDefinition =\n    kpuzzle.definition.moves[move.invert().toString()];\n  if (inverseMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);\n  }\n\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n", "import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKState(): KState {\n    return KState.fromTransformation(this);\n  }\n\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n", "import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { functionFromTraversal } from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n  KPuzzleDefinition,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignoreOrientation?: boolean;\n    ignorePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignoreOrientation &&\n      orbitTransformationData1.orientation[idx] !==\n        orbitTransformationData2.orientation[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    kpuzzle.definition.orbits,\n  )) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitName],\n        transformationData2[orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition: KOrbitDefinition =\n      kpuzzle.definition.orbits[orbitName];\n    const orbitTransformationData = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitName] = orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: orbitTransformationData.orientation,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientation[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const algNode of alg.childAlgNodes()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseAlgNode(algNode, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseAlgNode(algNode, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nexport const algToTransformation = functionFromTraversal(\n  AlgToTransformationTraversal,\n);\n\nexport function canConvertStateToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(definition)) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.startStateData[orbitName].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const transformationOrbit = transformation.transformationData[orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientation[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, Math.abs(orientationSum));\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n", "import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = transformationData1[orbitName];\n    const orbit2 = transformationData2[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToStateData(\n  definition: KPuzzleDefinition,\n  stateData: KStateData,\n  transformationData: KTransformationData,\n): KStateData {\n  const newStateData = {} as KStateData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = stateData[orbitName];\n    const orbit2 = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newStateData[orbitName] = orbit1;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newStateData;\n}\n", "import type { KPuzzle } from \"./KPuzzle\";\nimport type { Alg, Move } from \"../alg\";\nimport { applyTransformationDataToStateData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type {\n  KStateData,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport class KState {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly stateData: KStateData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      stateData: this.stateData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KState {\n    const newStateData = applyTransformationDataToStateData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.startStateData,\n      transformation.transformationData,\n    );\n    return new KState(transformation.kpuzzle, newStateData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KState {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KState {\n    if (transformation.isIdentityTransformation()) {\n      return new KState(this.kpuzzle, this.stateData);\n    }\n    const newStateData = applyTransformationDataToStateData(\n      this.kpuzzle.definition,\n      this.stateData,\n      transformation.transformationData,\n    );\n    return new KState(this.kpuzzle, newStateData);\n  }\n\n  applyMove(move: Move | string): KState {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KState {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: stateOrbitData.pieces,\n        orientation: stateOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIsSolved(options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (!this.kpuzzle.definition.experimentalIsStateSolved) {\n      throw new Error(\n        \"`KState.experimentalIsSolved()` is not supported for this puzzle at the moment.\",\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsStateSolved(this, options);\n  }\n}\n", "import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  startState(): KState {\n    return new KState(this, this.definition.startStateData);\n  }\n\n  #cachedCanConvertStateToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete start state data\n  canConvertStateToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertStateToUniqueTransformation ??=\n      ((): boolean => {\n        for (const [orbitName, orbitDefinition] of Object.entries(\n          this.definition.orbits,\n        )) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.startStateData[orbitName]\n            .pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n}\n", "export { KPuzzle } from \"./KPuzzle\";\nexport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nexport { KState } from \"./KState\";\nexport { KTransformation } from \"./KTransformation\";\n", "import type { KPuzzleDefinition } from \"../../../../kpuzzle\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: {\n    EDGES: { numPieces: 12, numOrientations: 2 },\n    CORNERS: { numPieces: 8, numOrientations: 3 },\n    CENTERS: { numPieces: 6, numOrientations: 4 },\n  },\n  startStateData: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientation: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n};\n\ncube3x3x3KPuzzleDefinition.experimentalDerivedMoves = {\n  Uw: \"u\",\n  Lw: \"l\",\n  Fw: \"f\",\n  Rw: \"r\",\n  Bw: \"b\",\n  Dw: \"d\",\n\n  Uv: \"y\",\n  Lv: \"x'\",\n  Fv: \"z\",\n  Rv: \"x\",\n  Bv: \"z'\",\n  Dv: \"y'\",\n\n  \"2U\": \"u U'\",\n  \"2L\": \"l L'\",\n  \"2F\": \"f F'\",\n  \"2R\": \"r R'\",\n  \"2B\": \"b B'\",\n  \"2D\": \"d D'\",\n};\n", "import type { PuzzleID } from \"../../twisty\";\n\nconst LL = \"Last Layer\";\nconst LS = \"Last Slot\";\nconst megaAnd3x3x3LL = {\n  \"3x3x3\": LL,\n  megaminx: LL,\n};\nconst megaAnd3x3x3LS = {\n  \"3x3x3\": LS,\n  megaminx: LS,\n};\n\nexport const experimentalStickerings: Record<\n  string,\n  { groups?: Partial<Record<PuzzleID, string>> }\n> = {\n  full: { groups: { \"3x3x3\": \"Stickering\", megaminx: \"Stickering\" } }, // default\n  OLL: { groups: megaAnd3x3x3LL },\n  PLL: { groups: megaAnd3x3x3LL },\n  LL: { groups: megaAnd3x3x3LL },\n  EOLL: { groups: megaAnd3x3x3LL },\n  COLL: { groups: megaAnd3x3x3LL },\n  OCLL: { groups: megaAnd3x3x3LL },\n  CPLL: { groups: megaAnd3x3x3LL },\n  CLL: { groups: megaAnd3x3x3LL },\n  EPLL: { groups: megaAnd3x3x3LL },\n  ELL: { groups: megaAnd3x3x3LL },\n  ZBLL: { groups: megaAnd3x3x3LL },\n  LS: { groups: megaAnd3x3x3LS },\n  ELS: { groups: megaAnd3x3x3LS },\n  CLS: { groups: megaAnd3x3x3LS },\n  ZBLS: { groups: megaAnd3x3x3LS },\n  VLS: { groups: megaAnd3x3x3LS },\n  WVLS: { groups: megaAnd3x3x3LS },\n  F2L: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Daisy: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Cross: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  EO: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOline: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOcross: { groups: { \"3x3x3\": \"ZZ\" } },\n  CMLL: { groups: { \"3x3x3\": \"Roux\" } },\n  L10P: { groups: { \"3x3x3\": \"Roux\" } },\n  L6E: { groups: { \"3x3x3\": \"Roux\" } },\n  L6EO: { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  L2C: {\n    groups: {\n      \"4x4x4\": \"Reduction\",\n      \"5x5x5\": \"Reduction\",\n      \"6x6x6\": \"Reduction\",\n    },\n  },\n  PBL: {\n    groups: {\n      \"2x2x2\": \"Ortega\",\n    },\n  },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  invisible: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  picture: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } }, // TODO\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } },\n};\n", "import { Alg } from \"../../../../alg\";\nimport { KState, KTransformation } from \"../../../../kpuzzle\";\nimport { experimental3x3x3KPuzzle } from \"../../../cubing-private\";\n\nexport function puzzleOrientation3x3x3Idx(state: KState): [number, number] {\n  const idxU = state.stateData[\"CENTERS\"].pieces[0];\n  const idxD = state.stateData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = state.stateData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCacheRaw: KTransformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array<KTransformation>(6);\n  });\n\nconst puzzleOrientationCacheInitialized = false;\nexport function puzzleOrientation3x3x3Cache(): KTransformation[][] {\n  if (!puzzleOrientationCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(\n            transformation.toKState(),\n          );\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize3x3x3Orientation(state: KState): KState {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(state);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return state.applyTransformation(orientationTransformation);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs3x3x3Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize3x3x3Orientation(state);\n  }\n  if (options.ignoreCenterOrientation) {\n    state = new KState(state.kpuzzle, {\n      EDGES: state.stateData.EDGES,\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    });\n  }\n  return !!state.experimentalToTransformation()?.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n", "import type { PuzzleSpecificSimplifyOptions } from \"../alg\";\nimport type { AppendOptions } from \"../alg/simplify\";\nimport type { KPuzzle } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../twisty\";\nimport type { StickeringMask } from \"./stickerings/mask\";\n\nexport interface PuzzleLoader {\n  id: string;\n  // shortName?: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number; // TODO: date?\n  /** @deprecated */\n  def?: never;\n  kpuzzle: () => Promise<KPuzzle>; // TODO\n  svg: () => Promise<string>;\n  llSVG?: () => Promise<string>;\n  pg?: () => Promise<PuzzleGeometry>;\n  stickeringMask?: (\n    stickering: ExperimentalStickering,\n  ) => Promise<StickeringMask>;\n  stickerings?: () => Promise<ExperimentalStickering[]>;\n  puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n  puzzleSpecificSimplifyOptionsPromise?: Promise<PuzzleSpecificSimplifyOptions>; // TODO\n}\n\n// TODO: consolidate the `puzzleSpecificSimplifyOptionsPromise` with `puzzleSpecificSimplifyOptions` somehow, so that we don't have to do this.\nexport async function getPartialAppendOptionsForPuzzleSpecificSimplifyOptions(\n  puzzleLoader: PuzzleLoader,\n): Promise<AppendOptions> {\n  const puzzleSpecificSimplifyOptions =\n    await (puzzleLoader.puzzleSpecificSimplifyOptions ??\n      puzzleLoader.puzzleSpecificSimplifyOptionsPromise);\n  if (!puzzleSpecificSimplifyOptions) {\n    return {};\n  }\n  return { puzzleLoader: { puzzleSpecificSimplifyOptions } };\n}\n", "import { Alg } from \"../../../../alg\";\nimport type { KPuzzle, KState, KTransformation } from \"../../../../kpuzzle\";\n\nexport function puzzleOrientation2x2x2Idx(state: KState): number {\n  const inverse = state.experimentalToTransformation()!.invert();\n\n  const inverseDFL = inverse.transformationData[\"CORNERS\"];\n  return inverseDFL.permutation[6] * 3 + inverseDFL.orientation[6];\n}\n\nconst puzzleOrientationCacheRaw: {\n  transformation: KTransformation;\n  alg: Alg;\n}[] = new Array<KTransformation>(24) as any;\n\nconst puzzleOrientationCacheInitialized = false;\n// We rely on the (first) caller to pass in the `KPuzzle`, so that we don't need to get our own synchronous reference.\nexport function puzzleOrientation2x2x2Cache(\n  kpuzzle: KPuzzle,\n): typeof puzzleOrientationCacheRaw {\n  if (!puzzleOrientationCacheInitialized) {\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = kpuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const idx = puzzleOrientation2x2x2Idx(transformation.toKState());\n          puzzleOrientationCacheRaw[idx] = {\n            transformation: transformation.invert(),\n            alg: uAlg.concat(yAlg),\n          };\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize2x2x2Orientation(state: KState): {\n  normalizedState: KState;\n  normalizationAlg: Alg;\n} {\n  const idx = puzzleOrientation2x2x2Idx(state);\n  const { transformation, alg } = puzzleOrientation2x2x2Cache(state.kpuzzle)[\n    idx\n  ];\n  return {\n    normalizedState: state.applyTransformation(transformation),\n    normalizationAlg: alg.invert(),\n  };\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs2x2x2Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize2x2x2Orientation(state).normalizedState;\n  }\n  return !!state.experimentalToTransformation()!.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n", "// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshStickeringMask =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"ignored\"\n  | \"invisible\";\n\nexport type FaceletStickeringMask = {\n  mask: FaceletMeshStickeringMask;\n  hintMask?: FaceletMeshStickeringMask;\n};\n\nexport type PieceStickeringMask = {\n  // TODO: foundation?\n  facelets: (FaceletMeshStickeringMask | FaceletStickeringMask | null)[];\n};\n\nexport type OrbitStickeringMask = {\n  pieces: (PieceStickeringMask | null)[];\n};\n\nexport type StickeringMask = {\n  specialBehaviour?: \"picture\"; // TODO: remove this\n  name?: string; // TODO\n  orbits: Record<string, OrbitStickeringMask>;\n};\n\nexport function getFaceletStickeringMask(\n  stickeringMask: StickeringMask,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshStickeringMask {\n  const orbitStickeringMask = stickeringMask.orbits[orbitName];\n  const pieceStickeringMask: PieceStickeringMask | null =\n    orbitStickeringMask.pieces[pieceIdx];\n  if (pieceStickeringMask === null) {\n    return regular;\n  }\n  const faceletStickeringMask:\n    | FaceletMeshStickeringMask\n    | FaceletStickeringMask\n    | null = pieceStickeringMask.facelets?.[faceletIdx];\n  if (faceletStickeringMask === null) {\n    return regular;\n  }\n  if (typeof faceletStickeringMask === \"string\") {\n    return faceletStickeringMask;\n  }\n  if (hint) {\n    return faceletStickeringMask.hintMask ?? faceletStickeringMask.mask;\n  }\n  console.log(faceletStickeringMask);\n  return faceletStickeringMask.mask;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const [orbitName, orbitDef] of Object.entries(\n      kpuzzle.definition.orbits,\n    )) {\n      this.stickerings.set(\n        orbitName,\n        new Array(orbitDef.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\n\n// We specify 5 facelets, because that's the maximum we need for any built-in puzzles (e.g. Megaminx centers or icosa vertices).\n// TODO: use \"primary\" and \"non-primary\" fields instead of listing all non-primary facelets.\nconst pieceStickerings: Record<string, PieceStickeringMask> = {\n  // regular\n  [PieceStickering.Regular]: {\n    // r\n    facelets: [regular, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Ignored]: {\n    // i\n    facelets: [ignored, ignored, ignored, ignored, ignored],\n  },\n\n  // oriented stickers\n  [PieceStickering.OrientationStickers]: {\n    // o\n    facelets: [oriented, oriented, oriented, oriented, oriented],\n  },\n\n  // \"OLL\"\n  [PieceStickering.IgnoreNonPrimary]: {\n    // riiii\n    facelets: [regular, ignored, ignored, ignored, ignored],\n  },\n\n  // invisible\n  [PieceStickering.Invisible]: {\n    // invisiblePiece\n    facelets: [invisible, invisible, invisible, invisible, invisible],\n  },\n\n  // \"PLL\"\n  [PieceStickering.PermuteNonPrimary]: {\n    // drrrr\n    facelets: [dim, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Dim]: {\n    // d\n    facelets: [dim, dim, dim, dim, dim],\n  },\n\n  // \"OLL\"\n  [PieceStickering.Ignoriented]: {\n    // diiii\n    facelets: [dim, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.OrientationWithoutPermutation]: {\n    // oiiii\n    facelets: [oriented, ignored, ignored, ignored, ignored],\n  },\n};\n\nexport function getPieceStickeringMask(\n  pieceStickering: PieceStickering,\n): PieceStickeringMask {\n  return pieceStickerings[pieceStickering];\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toStickeringMask(): StickeringMask {\n    const stickeringMask: StickeringMask = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceStickeringMask[] = [];\n      const orbitStickeringMask: OrbitStickeringMask = {\n        pieces,\n      };\n      stickeringMask.orbits[orbitName] = orbitStickeringMask;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceStickeringMask(pieceStickering));\n      }\n    }\n    return stickeringMask;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] =\n          !pieceSet.stickerings.get(orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitName].permutation[i] !== i ||\n          transformation.transformationData[orbitName].orientation[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  orbits(orbitNames: string[]): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName)!.fill(true);\n    }\n    return pieceSet;\n  }\n\n  orbitPrefix(orbitPrefix: string): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName in this.kpuzzle.definition.orbits) {\n      if (orbitName.startsWith(orbitPrefix)) {\n        pieceSet.stickerings.get(orbitName)!.fill(true);\n      }\n    }\n    return pieceSet;\n  }\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const [orbitName, orbitDef] of Object.entries(this.def.orbits)) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDef.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n", "import type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PieceSet,\n  PieceStickering,\n  StickeringMask,\n  PuzzleStickering,\n  StickeringManager,\n} from \"./mask\";\nimport { experimentalStickerings } from \"./puzzle-stickerings\";\n\n// TODO: cache calculations?\nexport async function cubeLikeStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const CENTERS = (): PieceSet => m.orbitPrefix(\"CENTER\");\n  const EDGES = (): PieceSet => m.orbitPrefix(\"EDGE\");\n  const CORNERS = (): PieceSet =>\n    m.or([\n      m.orbitPrefix(\"CORNER\"),\n      m.orbitPrefix(\"C4RNER\"),\n      m.orbitPrefix(\"C5RNER\"),\n    ]);\n\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n  const centerLL = (): PieceSet => m.and([LL(), CENTERS()]);\n\n  const edgeFR = (): PieceSet => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  const cornerDFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Regular); // For PG\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\": {\n      dimF2L();\n      setPLL();\n      break;\n    }\n    case \"CLS\": {\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"OLL\": {\n      dimF2L();\n      setOLL();\n      break;\n    }\n    case \"EOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"COLL\": {\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"OCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"CPLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.and([CORNERS(), LL()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      puzzleStickering.set(\n        m.and([m.not(CORNERS()), LL()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"CLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"EPLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), EDGES()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"ELL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ELS\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    }\n    case \"LL\": {\n      dimF2L();\n      break;\n    }\n    case \"F2L\": {\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    }\n    case \"ZBLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ZBLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"VLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    }\n    case \"WVLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"LS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim);\n      break;\n    }\n    case \"EO\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    }\n    case \"EOline\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    }\n    case \"EOcross\": {\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    }\n    case \"CMLL\": {\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L10P\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L6E\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    }\n    case \"L6EO\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.OrientationStickers,\n      ); // For PG\n      break;\n    }\n    case \"Daisy\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"Cross\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"2x2x2\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"2x2x3\": {\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"L2C\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"L\", \"R\", \"B\", \"D\"])),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    case \"PBL\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"D\"])),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"Void Cube\": {\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    }\n    case \"picture\":\n    // fallthrough\n    case \"invisible\": {\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    }\n    case \"centers-only\": {\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toStickeringMask();\n}\n\nexport async function cubeLikeStickeringList(\n  puzzleID: PuzzleID,\n  options?: { use3x3x3Fallbacks: boolean },\n): Promise<ExperimentalStickering[]> {\n  const stickerings: ExperimentalStickering[] = [];\n  const stickeringsFallback: ExperimentalStickering[] = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups) {\n      if (puzzleID in info.groups) {\n        stickerings.push(name);\n      } else if (options?.use3x3x3Fallbacks && \"3x3x3\" in info.groups) {\n        stickeringsFallback.push(name);\n      }\n    }\n  }\n  return stickerings.concat(stickeringsFallback);\n}\n", "export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n", "import { KPuzzle, KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { StickeringMask } from \"../stickerings/mask\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../stickerings/cube-like-stickerings\";\nimport { getCached } from \"./lazy-cached\";\nimport { Move, PuzzleSpecificSimplifyOptions, QuantumMove } from \"../../alg\";\nimport { PLazy } from \"../../vendor/mit/p-lazy/p-lazy\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(this.pg(), this.id));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n\n  puzzleSpecificSimplifyOptionsPromise = puzzleSpecificSimplifyOptionsPromise(\n    this.kpuzzle.bind(this),\n  );\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return cubeLikeStickeringMask(this, stickering);\n  }\n  stickerings = () =>\n    cubeLikeStickeringList(this.id as PuzzleID, { use3x3x3Fallbacks: true });\n}\n\nexport function puzzleSpecificSimplifyOptionsPromise(\n  kpuzzlePromiseFn: () => Promise<KPuzzle>,\n): Promise<PuzzleSpecificSimplifyOptions> {\n  return new PLazy(\n    async (resolve: (options: PuzzleSpecificSimplifyOptions) => void) => {\n      const kpuzzle = await kpuzzlePromiseFn();\n      resolve({\n        quantumMoveOrder: (m: QuantumMove) => {\n          return kpuzzle.moveToTransformation(new Move(m)).repetitionOrder();\n        },\n      });\n    },\n  );\n}\n", "import { KPuzzle, KPuzzleDefinition } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport { puzzleSpecificSimplifyOptionsPromise } from \"./async/async-pg3d\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: dedup with `cubing/puzzles`\nexport async function asyncGetKPuzzle(\n  desc: PuzzleDescriptionString,\n): Promise<KPuzzle> {\n  const pg = await descAsyncGetPuzzleGeometry(desc);\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = `description: ${desc}`;\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const kpuzzlePromiseFn = async () => {\n    return (cachedKPuzzle ??= asyncGetKPuzzle(desc));\n  };\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: kpuzzlePromiseFn,\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n    puzzleSpecificSimplifyOptionsPromise:\n      puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn),\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n", "import { KPuzzle } from \"../../kpuzzle\";\nimport { cube3x3x3KPuzzleDefinition as experimentalCube3x3x3KPuzzleDefinition } from \"../implementations/dynamic/3x3x3/3x3x3.kpuzzle.json\";\nimport { experimentalIs3x3x3Solved } from \"../implementations/dynamic/3x3x3/puzzle-orientation\";\nexport { getPartialAppendOptionsForPuzzleSpecificSimplifyOptions } from \"../PuzzleLoader\";\nexport { experimentalCube3x3x3KPuzzleDefinition };\n\n/** @deprecated */\nexport const experimental3x3x3KPuzzle = new KPuzzle(\n  experimentalCube3x3x3KPuzzleDefinition,\n);\nexperimentalCube3x3x3KPuzzleDefinition.experimentalIsStateSolved =\n  experimentalIs3x3x3Solved;\n\nexport {\n  experimentalIs3x3x3Solved,\n  normalize3x3x3Orientation as experimentalNormalize3x3x3Orientation,\n  puzzleOrientation3x3x3Cache as experimentalPuzzleOrientation3x3x3Cache,\n  puzzleOrientation3x3x3Idx as experimentalPuzzleOrientation3x3x3Idx,\n} from \"../implementations/dynamic/3x3x3/puzzle-orientation\"; // TODO: Actually dynamic\nexport { experimentalStickerings } from \"../stickerings/puzzle-stickerings\";\n\nexport {\n  experimentalIs2x2x2Solved,\n  normalize2x2x2Orientation as experimentalNormalize2x2x2Orientation,\n  puzzleOrientation2x2x2Cache as experimentalPuzzleOrientation2x2x2Cache,\n  puzzleOrientation2x2x2Idx as experimentalPuzzleOrientation2x2x2Idx,\n} from \"../implementations/dynamic/2x2x2/puzzle-orientation\"; // TODO: Actually dynamic\n\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"../customPGPuzzleLoader\";\nexport { getFaceletStickeringMask as experimentalGetFaceletStickeringMask } from \"../stickerings/mask\";\nexport type {\n  PieceStickeringMask as ExperimentalPieceStickeringMask,\n  FaceletMeshStickeringMask as ExperimentalFaceletMeshStickeringMask,\n  StickeringMask as ExperimentalStickeringMask,\n} from \"../stickerings/mask\";\nexport {\n  getPieceStickeringMask as experimentalGetPieceStickeringMask,\n  PieceStickering as ExperimentalPieceStickering,\n} from \"../stickerings/mask\";\n"],
  "mappings": "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",
  "names": ["FREEZE", "identityOrbitCache", "constructIdentityOrbitTransformation", "numPieces", "cached", "newPermutation", "newOrientation", "i", "orbitTransformation", "constructIdentityTransformationDataUncached", "definition", "transformation", "orbitName", "orbitDefinition", "moveToTransformationUncached", "kpuzzle", "move", "quantumKey", "quantumMoveDefinition", "derivedFrom", "repeatTransformationUncached", "moveDefinition", "inverseMoveDefinition", "KTransformation", "kpuzzle", "transformationData", "invertTransformation", "#cachedIsIdentity", "transformation", "constructIdentityTransformationDataUncached", "t2", "isTransformationDataIdentical", "source", "combineTransformationData", "move", "alg", "KState", "transformationRepetitionOrder", "amount", "repeatTransformationUncached", "isOrbitTransformationDataIdentityUncached", "numOrientations", "orbitTransformationData", "permutation", "numPieces", "idx", "orientation", "isOrbitTransformationDataIdentical", "orbitDefinition", "orbitTransformationData1", "orbitTransformationData2", "options", "isTransformationDataIdentical", "kpuzzle", "transformationData1", "transformationData2", "orbitName", "invertTransformation", "transformationData", "newTransformationData", "newPerm", "newOri", "fromIdx", "repeatTransformationUncached", "amount", "halfish", "twiceHalfish", "combineTransformationData", "AlgToTransformationTraversal", "TraversalDownUp", "alg", "transformation", "algNode", "grouping", "algTransformation", "KTransformation", "move", "commutator", "aTransformation", "bTransformation", "conjugate", "_", "algToTransformation", "functionFromTraversal", "gcd", "a", "b", "transformationRepetitionOrder", "definition", "transformation", "order", "orbitName", "orbitDefinition", "transformationOrbit", "orbitPieces", "startIdx", "currentIdx", "orientationSum", "cycleLength", "combineTransformationData", "definition", "transformationData1", "transformationData2", "newTransformationData", "orbitName", "orbitDefinition", "orbit1", "orbit2", "isOrbitTransformationDataIdentityUncached", "newPerm", "idx", "newOri", "applyTransformationDataToStateData", "stateData", "transformationData", "newStateData", "newPieces", "KState", "kpuzzle", "stateData", "transformation", "newStateData", "applyTransformationDataToStateData", "source", "move", "alg", "transformationData", "orbitName", "stateOrbitData", "transformationOrbit", "KTransformation", "options", "KPuzzle", "definition", "options", "#moveToTransformationDataCache", "KTransformation", "move", "Move", "cacheKey", "cachedTransformationData", "transformationData", "moveToTransformationUncached", "alg", "Alg", "algToTransformation", "source", "KState", "#cachedCanConvertStateToUniqueTransformation", "orbitName", "orbitDefinition", "pieces", "piece", "kpuzzle_exports", "__export", "KPuzzle", "KState", "KTransformation", "cube3x3x3KPuzzleDefinition", "LL", "LS", "megaAnd3x3x3LL", "megaAnd3x3x3LS", "experimentalStickerings", "puzzleOrientation3x3x3Idx", "state", "idxU", "idxD", "unadjustedIdxL", "idxL", "puzzleOrientationCacheRaw", "puzzleOrientationCacheInitialized", "puzzleOrientation3x3x3Cache", "uAlgs", "s", "Alg", "yAlg", "uAlg", "transformation", "experimental3x3x3KPuzzle", "i", "normalize3x3x3Orientation", "orientationTransformation", "experimentalIs3x3x3Solved", "options", "KState", "getPartialAppendOptionsForPuzzleSpecificSimplifyOptions", "puzzleLoader", "puzzleSpecificSimplifyOptions", "puzzleOrientation2x2x2Idx", "state", "inverseDFL", "puzzleOrientationCacheRaw", "puzzleOrientationCacheInitialized", "puzzleOrientation2x2x2Cache", "kpuzzle", "uAlgs", "s", "Alg", "yAlg", "uAlg", "transformation", "i", "idx", "normalize2x2x2Orientation", "alg", "getFaceletStickeringMask", "stickeringMask", "orbitName", "pieceIdx", "faceletIdx", "hint", "pieceStickeringMask", "regular", "faceletStickeringMask", "PieceAnnotation", "kpuzzle", "defaultValue", "orbitName", "orbitDef", "regular", "ignored", "oriented", "invisible", "dim", "pieceStickerings", "getPieceStickeringMask", "pieceStickering", "PuzzleStickering", "pieceSet", "pieces", "i", "stickeringMask", "orbitStickeringMask", "StickeringManager", "pieceSets", "newPieceSet", "pieceLoop", "moveSource", "transformation", "moveSources", "orbitNames", "orbitPrefix", "cubeLikeStickeringMask", "puzzleLoader", "stickering", "kpuzzle", "puzzleStickering", "PuzzleStickering", "m", "StickeringManager", "LL", "orUD", "orLR", "M", "F2L", "CENTERS", "EDGES", "CORNERS", "L6E", "centerLL", "edgeFR", "cornerDFR", "slotFR", "dimF2L", "setPLL", "setOLL", "dimOLL", "cubeLikeStickeringList", "puzzleID", "options", "stickerings", "stickeringsFallback", "name", "info", "experimentalStickerings", "getCached", "getValue", "cachedPromise", "asyncGetPuzzleGeometry", "puzzleName", "asyncGetKPuzzle", "pgPromise", "pg", "kpuzzleDefinition", "puzzleGeometry", "pgNotation", "KPuzzle", "PGPuzzleLoader", "info", "puzzleSpecificSimplifyOptionsPromise", "#cachedPG", "asyncGetPuzzleGeometry", "#cachedKPuzzle", "asyncGetKPuzzle", "#cachedSVG", "CubePGPuzzleLoader", "cubeLikeStickeringList", "stickering", "cubeLikeStickeringMask", "kpuzzlePromiseFn", "PLazy", "resolve", "kpuzzle", "m", "Move", "descAsyncGetPuzzleGeometry", "desc", "asyncGetKPuzzle", "pg", "kpuzzleDefinition", "puzzleGeometry", "pgNotation", "KPuzzle", "nextCustomID", "customPGPuzzleLoader", "info", "customID", "cachedKPuzzle", "kpuzzlePromiseFn", "puzzleLoader", "puzzleSpecificSimplifyOptionsPromise", "experimental3x3x3KPuzzle", "KPuzzle", "cube3x3x3KPuzzleDefinition", "experimentalIs3x3x3Solved"]
}
