{
  "version": 3,
  "sources": ["../../../../src/cubing/twisty/model/PromiseFreshener.ts", "../../../../src/cubing/twisty/model/props/TwistyProp.ts", "../../../../src/cubing/twisty/views/node-custom-element-shims.ts", "../../../../src/cubing/twisty/views/ManagedCustomElement.ts"],
  "sourcesContent": ["// TODO: Pick a much better name.\nexport class PromiseFreshener<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  // TODO: reject instead? Drop?\n  async queue(\n    p: Promise<T>,\n  ): Promise<{ fresh: false } | { fresh: true; result: T }> {\n    const idx = ++this.#latestAssignedIdx;\n    const result = await p;\n    if (idx > this.#latestResolvedIdx) {\n      this.#latestResolvedIdx = idx;\n      return {\n        fresh: true,\n        result: result,\n      };\n    } else {\n      return { fresh: false };\n    }\n  }\n}\n\n// This will silenty drop a queued Promise (i.e. not resolve it) if a\n// newer queued one already resolved first. This is useful for classes that want\n// to know the \"latest\" state of something without jumping back to an older\n// value by accident.\n// TODO: Remove this because it's too easy to misuse?\nexport class StaleDropper<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  queue(p: Promise<T>): Promise<T> {\n    // rome-ignore lint/suspicious/noAsyncPromiseExecutor: This is a very rare case where we *do* want to drop a Promise sometimes.\n    return new Promise(async (resolve, reject) => {\n      try {\n        const idx = ++this.#latestAssignedIdx;\n        const result = await p;\n        if (idx > this.#latestResolvedIdx) {\n          this.#latestResolvedIdx = idx;\n          resolve(result);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n}\n", "import { from } from \"../../../vendor/mit/p-lazy/p-lazy\";\nimport { StaleDropper } from \"../PromiseFreshener\";\nimport type { UserVisibleErrorTracker } from \"../UserVisibleErrorTracker\";\n\n// rome-ignore lint/nursery/noBannedTypes: TODO: can we use `satisfies` below instead of using this?\ntype InputRecord = {};\n\nexport type InputProps<T extends InputRecord> = {\n  [s in keyof T]: TwistyPropParent<T[s]>;\n};\n\ntype InputPromises<T extends InputRecord> = {\n  [s in keyof T]: Promise<T[s]>;\n};\n\ninterface SourceEventDetail<OutputType> {\n  sourceProp: TwistyPropSource<OutputType, any>;\n  value: Promise<OutputType>; // TODO: remove?\n  generation: number;\n}\n\ntype SourceEvent<T> = CustomEvent<SourceEventDetail<T>>;\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\n// Values of T must be immutable.\nlet globalSourceGeneration = 0; // This is incremented before being used, so 1 will be the first active value.\nexport abstract class TwistyPropParent<T> {\n  public abstract get(): Promise<T>;\n\n  // Don't overwrite this. Overwrite `canReuseValue` instead.\n  public canReuse(v1: T, v2: T): boolean {\n    return v1 === v2 || this.canReuseValue(v1, v2);\n  }\n\n  // Overwrite with a cheap semantic comparison when possible.\n  // Note that this is not called if `v1 === v2` (in which case the value is automatically reused).\n  protected canReuseValue(_v1: T, _v2: T): boolean {\n    return false;\n  }\n\n  debugGetChildren(): TwistyPropDerived<any, any>[] {\n    return Array.from(this.#children.values());\n  }\n\n  // Propagation\n\n  #children: Set<TwistyPropDerived<any, any>> = new Set();\n  protected addChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.add(child);\n  }\n\n  protected removeChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.delete(child);\n  }\n\n  protected lastSourceGeneration: number = 0;\n  // Synchronously marks all descendants as stale. This doesn't actually\n  // literally mark as stale, but it updates the last source generation, which\n  // is used to tell if a cahced result is stale.\n  protected markStale(sourceEvent: SourceEvent<any>): void {\n    if (sourceEvent.detail.generation !== globalSourceGeneration) {\n      // The full stale propagation is synchronous, so there should not be a new one yet.\n      throw new Error(\"A TwistyProp was marked stale too late!\");\n    }\n    if (this.lastSourceGeneration === sourceEvent.detail.generation) {\n      // Already propagated.\n      return;\n    }\n    this.lastSourceGeneration = sourceEvent.detail.generation;\n    for (const child of this.#children) {\n      child.markStale(sourceEvent);\n    }\n    // We schedule sending out events *after* the (synchronous) propagation has happened, in\n    // case one of the listeners updates a source again.\n    this.#scheduleRawDispatch();\n  }\n\n  #rawListeners: Set<() => void> = new Set();\n  /** @deprecated */\n  addRawListener(listener: () => void, options?: { initial: boolean }): void {\n    this.#rawListeners.add(listener);\n    if (options?.initial) {\n      listener(); // TODO: wrap in a try?\n    }\n  }\n\n  /** @deprecated */\n  removeRawListener(listener: () => void): void {\n    this.#rawListeners.delete(listener);\n  }\n\n  /** @deprecated */\n  #scheduleRawDispatch(): void {\n    if (!this.#rawDispatchPending) {\n      this.#rawDispatchPending = true;\n      setTimeout(() => this.#dispatchRawListeners(), 0);\n    }\n  }\n\n  #rawDispatchPending: boolean = false;\n  #dispatchRawListeners(): void {\n    if (!this.#rawDispatchPending) {\n      throw new Error(\"Invalid dispatch state!\");\n    }\n    for (const listener of this.#rawListeners) {\n      listener(); // TODO: wrap in a try?\n    }\n    this.#rawDispatchPending = false;\n  }\n\n  #freshListeners: Map<(value: T) => void, () => void> = new Map();\n  // TODO: Pick a better name.\n  public addFreshListener(listener: (value: T) => void): void {\n    const staleDropper: StaleDropper<T> = new StaleDropper<T>();\n    let lastResult: T | null = null;\n    const callback = async () => {\n      const result = await staleDropper.queue(this.get());\n      if (lastResult !== null && this.canReuse(lastResult, result)) {\n        return;\n      }\n      lastResult = result;\n      listener(result);\n    };\n    this.#freshListeners.set(listener, callback);\n    this.addRawListener(callback, { initial: true });\n  }\n\n  public removeFreshListener(listener: (value: T) => void): void {\n    this.removeRawListener(this.#freshListeners.get(listener)!); // TODO: throw a custom error?\n    this.#freshListeners.delete(listener);\n  }\n}\n\nexport abstract class TwistyPropSource<\n  OutputType,\n  InputType = OutputType,\n> extends TwistyPropParent<OutputType> {\n  #value: Promise<OutputType>;\n\n  public abstract getDefaultValue(): PromiseOrValue<OutputType>;\n\n  constructor(initialValue?: PromiseOrValue<InputType>) {\n    super();\n    this.#value = from(() => this.getDefaultValue());\n    if (initialValue) {\n      this.#value = this.deriveFromPromiseOrValue(initialValue, this.#value);\n    }\n  }\n\n  set(input: PromiseOrValue<InputType>): void {\n    this.#value = this.deriveFromPromiseOrValue(input, this.#value);\n\n    const sourceEventDetail: SourceEventDetail<OutputType> = {\n      sourceProp: this,\n      value: this.#value,\n      generation: ++globalSourceGeneration,\n    };\n    this.markStale(\n      new CustomEvent<SourceEventDetail<OutputType>>(\"stale\", {\n        detail: sourceEventDetail,\n      }),\n    );\n  }\n\n  async get(): Promise<OutputType> {\n    return this.#value;\n  }\n\n  protected async deriveFromPromiseOrValue(\n    input: PromiseOrValue<InputType>,\n    oldValuePromise: Promise<OutputType>,\n  ): Promise<OutputType> {\n    return this.derive(await input, oldValuePromise);\n  }\n\n  // TODO: add an indirect layer to cache the derivation?\n  protected abstract derive(\n    input: InputType,\n    oldValuePromise: Promise<OutputType>,\n  ): PromiseOrValue<OutputType>;\n}\n\nexport abstract class SimpleTwistyPropSource<\n  SimpleType,\n> extends TwistyPropSource<SimpleType> {\n  protected override derive(input: SimpleType): PromiseOrValue<SimpleType> {\n    return input;\n  }\n}\n\n// TODO: Can we support `null` as a valid output value without loosening type\n// safety?\nexport const NO_VALUE = Symbol(\"no value\");\nexport type NoValueType = typeof NO_VALUE;\n\nexport abstract class TwistyPropDerived<\n  InputTypes extends InputRecord,\n  OutputType,\n> extends TwistyPropParent<OutputType> {\n  // cachedInputs:\n  #parents: InputProps<InputTypes>;\n\n  constructor(\n    parents: InputProps<InputTypes>,\n    protected userVisibleErrorTracker?: UserVisibleErrorTracker,\n  ) {\n    super();\n    this.#parents = parents;\n    for (const parent of Object.values(parents)) {\n      (\n        parent as TwistyPropDerived<InputProps<InputTypes>, OutputType>\n      ).addChild(this);\n    }\n  }\n\n  #cachedLastSuccessfulCalculation: {\n    inputs: InputTypes;\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  #cachedLatestGenerationCalculation: {\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  public async get(): Promise<OutputType> {\n    const generation = this.lastSourceGeneration;\n\n    if (this.#cachedLatestGenerationCalculation?.generation === generation) {\n      return this.#cachedLatestGenerationCalculation.output;\n    }\n\n    const latestGenerationCalculation = {\n      generation,\n      output: this.#cacheDerive(\n        this.#getParents(),\n        generation,\n        this.#cachedLastSuccessfulCalculation,\n      ),\n    };\n    this.#cachedLatestGenerationCalculation = latestGenerationCalculation;\n\n    this.userVisibleErrorTracker?.reset();\n    return latestGenerationCalculation.output;\n  }\n\n  async #getParents(): Promise<InputTypes> {\n    const inputValuePromises: InputPromises<InputRecord> = {} as any; // TODO\n    for (const [key, parent] of Object.entries(this.#parents)) {\n      (inputValuePromises as Record<string, Promise<unknown>>)[key] = (\n        parent as TwistyPropParent<unknown>\n      ).get();\n    }\n\n    const inputs: InputTypes = {} as any; // TODO\n    for (const key in this.#parents) {\n      inputs[key] = (await (\n        inputValuePromises as Record<string, Promise<unknown>>\n      )[key]) as any;\n    }\n    return inputs;\n  }\n\n  async #cacheDerive(\n    inputsPromise: PromiseOrValue<InputTypes>,\n    generation: number,\n    cachedLatestGenerationCalculation: {\n      inputs: InputTypes;\n      output: Promise<OutputType>;\n      generation: number;\n    } | null = null,\n  ): Promise<OutputType> {\n    const inputs = await inputsPromise;\n\n    const cache = (output: OutputType): OutputType => {\n      this.#cachedLastSuccessfulCalculation = {\n        inputs,\n        output: Promise.resolve(output),\n        generation,\n      };\n      return output;\n    };\n\n    if (!cachedLatestGenerationCalculation) {\n      return cache(await this.derive(inputs));\n    }\n\n    const cachedInputs = cachedLatestGenerationCalculation.inputs;\n    for (const key in this.#parents) {\n      const parent = this.#parents[key];\n      if (!parent.canReuse(inputs[key], cachedInputs[key])) {\n        return cache(await this.derive(inputs));\n      }\n    }\n\n    return cachedLatestGenerationCalculation.output;\n  }\n\n  protected abstract derive(input: InputTypes): PromiseOrValue<OutputType>;\n}\n\nexport class FreshListenerManager {\n  #disconnectionFunctions: (() => void)[] = [];\n\n  addListener<T>(\n    prop: TwistyPropParent<T>,\n    listener: (value: T) => void,\n  ): void {\n    let disconnected = false;\n    const wrappedListener = (value: T) => {\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      listener(value);\n    };\n\n    prop.addFreshListener(wrappedListener);\n\n    this.#disconnectionFunctions.push(() => {\n      prop.removeFreshListener(wrappedListener);\n      disconnected = true;\n    });\n  }\n\n  // TODO: Figure out the signature to let us do overloads\n  /** @deprecated */\n  public addMultiListener3<U, V, W>(\n    props: [TwistyPropParent<U>, TwistyPropParent<V>, TwistyPropParent<W>],\n    listener: (values: [U, V, W]) => void,\n  ): void {\n    this.addMultiListener(props as any, listener as any); // TODO\n  }\n  public addMultiListener<U, V>(\n    props: [TwistyPropParent<U>, TwistyPropParent<V>],\n    listener: (values: [U, V]) => void,\n  ) {\n    let disconnected = false;\n\n    // We're going to get one initial call per prop. We'll ignore all but one.\n    let initialIgnoresLeft = props.length - 1;\n    const wrappedListener = async (_: any) => {\n      if (initialIgnoresLeft > 0) {\n        initialIgnoresLeft--;\n        return;\n      }\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      // We rely on `TwistyProp` caching to give us the full set of latest\n      // values efficiently.\n      const promises = (props as TwistyPropParent<any>[]).map((prop) =>\n        prop.get(),\n      );\n      const values = await Promise.all(promises);\n      listener(values as any); // TODO: fix up types\n    };\n\n    for (const prop of props) {\n      prop.addFreshListener(wrappedListener);\n    }\n\n    this.#disconnectionFunctions.push(() => {\n      for (const prop of props) {\n        prop.removeFreshListener(wrappedListener);\n      }\n      disconnected = true;\n    });\n  }\n\n  public disconnect(): void {\n    for (const disconnectionFunction of this.#disconnectionFunctions) {\n      disconnectionFunction();\n    }\n  }\n}\n", "// Workarounds for `node`.\n// TODO: figure out how to remove this.\n\n// This stub does not need to be callable, just constructable to satisfy the `node` loader.\nclass HTMLElementStub {}\n\nlet HTMLElementShim: typeof HTMLElement;\nif (globalThis.HTMLElement) {\n  HTMLElementShim = HTMLElement;\n} else {\n  HTMLElementShim = HTMLElementStub as any;\n}\n\nexport { HTMLElementShim };\n\nclass CustomElementsStub {\n  define(): void {\n    // nothing\n  }\n}\n\nlet customElementsShim: typeof customElements;\n\nif (globalThis.customElements) {\n  customElementsShim = customElements;\n} else {\n  customElementsShim = new CustomElementsStub() as any;\n}\n\nexport { customElementsShim };\n", "import {\n  HTMLElementShim,\n  customElementsShim,\n} from \"./node-custom-element-shims\";\n\nexport class CSSSource {\n  constructor(private sourceText: string) {\n    // TODO: Replace with adopted style sheets some day if we can.\n    // const blob = new Blob([sourceText], {\n    //   type: \"text/utf8\",\n    // });\n    // this.url = URL.createObjectURL(blob);\n  }\n\n  getAsString(): string {\n    return this.sourceText;\n  }\n}\n\n// - Wrapped element\n//   - Shadow root\n//     - Content wrapper\nexport class ManagedCustomElement extends HTMLElementShim {\n  public readonly shadow: ShadowRoot; // TODO: hide this\n  public readonly contentWrapper: HTMLDivElement; // TODO: can we get rid of this wrapper?\n\n  #cssSourceMap: Map<CSSSource, HTMLStyleElement> = new Map();\n  constructor(options?: { mode: \"open\" | \"closed\" }) {\n    super();\n    this.shadow = this.attachShadow({ mode: options?.mode ?? \"closed\" });\n\n    this.contentWrapper = document.createElement(\"div\");\n    this.contentWrapper.classList.add(\"wrapper\");\n    this.shadow.appendChild(this.contentWrapper);\n  }\n\n  // Add the source, if not already added.\n  // Returns the existing if it's already on the element.\n  public addCSS(cssSource: CSSSource): HTMLStyleElement {\n    const existing = this.#cssSourceMap.get(cssSource);\n    if (existing) {\n      return existing;\n    }\n\n    const cssElem: HTMLStyleElement = document.createElement(\"style\");\n    cssElem.textContent = cssSource.getAsString();\n\n    this.#cssSourceMap.set(cssSource, cssElem);\n    this.shadow.appendChild(cssElem);\n    return cssElem;\n  }\n\n  // Remove the source, if it's currently added.\n  public removeCSS(cssSource: CSSSource): void {\n    const cssElem = this.#cssSourceMap.get(cssSource);\n    if (!cssElem) {\n      return;\n    }\n    this.shadow.removeChild(cssElem);\n    this.#cssSourceMap.delete(cssSource);\n  }\n\n  public addElement<T extends Node>(element: T): T {\n    return this.contentWrapper.appendChild(element);\n  }\n\n  public prependElement<T extends Node>(element: T): void {\n    this.contentWrapper.prepend(element);\n  }\n\n  public removeElement<T extends Node>(element: T): T {\n    return this.contentWrapper.removeChild(element);\n  }\n}\n\ncustomElementsShim.define(\n  \"twisty-managed-custom-element\",\n  ManagedCustomElement,\n);\n"],
  "mappings": "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",
  "names": ["StaleDropper", "#latestAssignedIdx", "#latestResolvedIdx", "p", "resolve", "reject", "idx", "result", "e", "globalSourceGeneration", "TwistyPropParent", "#children", "#rawListeners", "#rawDispatchPending", "#freshListeners", "v1", "v2", "_v1", "_v2", "child", "sourceEvent", "#scheduleRawDispatch", "listener", "options", "#dispatchRawListeners", "staleDropper", "StaleDropper", "lastResult", "callback", "result", "TwistyPropSource", "#value", "initialValue", "from", "input", "sourceEventDetail", "oldValuePromise", "SimpleTwistyPropSource", "NO_VALUE", "TwistyPropDerived", "parents", "userVisibleErrorTracker", "#parents", "parent", "#cachedLastSuccessfulCalculation", "#cachedLatestGenerationCalculation", "generation", "latestGenerationCalculation", "#cacheDerive", "#getParents", "inputValuePromises", "key", "inputs", "inputsPromise", "cachedLatestGenerationCalculation", "cache", "output", "cachedInputs", "FreshListenerManager", "#disconnectionFunctions", "prop", "disconnected", "wrappedListener", "value", "props", "initialIgnoresLeft", "_", "promises", "values", "disconnectionFunction", "HTMLElementStub", "HTMLElementShim", "CustomElementsStub", "customElementsShim", "CSSSource", "sourceText", "ManagedCustomElement", "HTMLElementShim", "options", "#cssSourceMap", "cssSource", "existing", "cssElem", "element", "customElementsShim"]
}
