{
  "version": 3,
  "sources": ["../../../../src/cubing/search/inside/solve/parseSGS.ts"],
  "sourcesContent": ["import { Alg } from \"../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../kpuzzle\";\n\ninterface PieceReference {\n  orbitName: string;\n  permutationIdx: number;\n}\n\nexport interface SGSAction {\n  alg: Alg;\n  transformation: KTransformation;\n}\n\nexport interface SGSCachedData {\n  ordering: {\n    pieceOrdering: PieceReference[];\n    lookup: Record<string, SGSAction>;\n  }[];\n}\n\nexport function parseSGS(kpuzzle: KPuzzle, sgs: string): SGSCachedData {\n  const subgroupSizes: number[] = [];\n  const sgsActions: SGSAction[] = [];\n  for (const line of sgs.split(\"\\n\")) {\n    const lineTokens = line.split(\" \");\n    if (line.startsWith(\"SetOrder \")) {\n      // ignore\n    } else if (line.startsWith(\"Alg \")) {\n      const alg = Alg.fromString(line.substring(4));\n      sgsActions.push({\n        alg: alg,\n        transformation: kpuzzle.algToTransformation(alg),\n      });\n    } else if (line.startsWith(\"SubgroupSizes \")) {\n      for (let j = 1; j < lineTokens.length; j++) {\n        subgroupSizes.push(parseInt(lineTokens[j]));\n      }\n    }\n  }\n\n  const sgsCachedData: SGSCachedData = {\n    ordering: new Array(subgroupSizes.length),\n  };\n  const subgroupAlgOffsets: number[] = [];\n  let sum = 0;\n  subgroupAlgOffsets.push(0);\n  const emptyAlg = Alg.fromString(\"\");\n  const identity = kpuzzle.identityTransformation();\n  for (let i = 0; i < subgroupSizes.length; i++) {\n    sum += subgroupSizes[i];\n    subgroupAlgOffsets.push(sum);\n    sgsActions.splice(sum - 1, 0, { alg: emptyAlg, transformation: identity });\n  }\n  if (sgsActions.length !== sum) {\n    throw Error(\n      `Bad sgs; expected ${sum - subgroupSizes.length} algs but saw ${\n        sgsActions.length - subgroupSizes.length\n      }`,\n    );\n  }\n  const processedPieces: Record<string, boolean[]> = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition = kpuzzle.definition.orbits[orbitName];\n    processedPieces[orbitName] = new Array(orbitDefinition.numPieces).fill(\n      false,\n    );\n  }\n  for (let i = subgroupSizes.length - 1; i >= 0; i--) {\n    const pieceOrdering: PieceReference[] = [];\n    for (let j = subgroupAlgOffsets[i]; j < subgroupAlgOffsets[i + 1]; j++) {\n      const transformation = sgsActions[j].transformation;\n      for (const orbitName in kpuzzle.definition.orbits) {\n        const orbitDefinition = kpuzzle.definition.orbits[orbitName];\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          if (\n            transformation.transformationData[orbitName].permutation[idx] !==\n              idx ||\n            transformation.transformationData[orbitName].orientation[idx] !== 0\n          ) {\n            if (!processedPieces[orbitName][idx]) {\n              pieceOrdering.push({ orbitName: orbitName, permutationIdx: idx });\n              processedPieces[orbitName][idx] = true;\n            }\n          }\n        }\n      }\n    }\n    const lookup: Record<string, SGSAction> = {};\n    for (let j = subgroupAlgOffsets[i]; j < subgroupAlgOffsets[i + 1]; j++) {\n      const transformation = sgsActions[j].transformation.invert();\n      let key = \"\";\n      for (let k = 0; k < pieceOrdering.length; k++) {\n        const loc = pieceOrdering[k];\n        key = `${key} ${\n          transformation.transformationData[loc.orbitName].permutation[\n            loc.permutationIdx\n          ]\n        } ${\n          transformation.transformationData[loc.orbitName].orientation[\n            loc.permutationIdx\n          ]\n        }`;\n      }\n      lookup[key] = sgsActions[j];\n      sgsActions[j].alg = sgsActions[j].alg.invert();\n      sgsActions[j].transformation = sgsActions[j].transformation.invert();\n    }\n    sgsCachedData.ordering[i] = {\n      pieceOrdering: pieceOrdering,\n      lookup: lookup,\n    };\n  }\n  return sgsCachedData;\n}\n"],
  "mappings": "wCAoBO,SAASA,EAASC,EAAkBC,EAA4B,CACrE,IAAMC,EAA0B,CAAC,EAC3BC,EAA0B,CAAC,EACjC,QAAWC,KAAQH,EAAI,MAAM;AAAA,CAAI,EAAG,CAClC,IAAMI,EAAaD,EAAK,MAAM,GAAG,EACjC,GAAI,CAAAA,EAAK,WAAW,WAAW,GAExB,GAAIA,EAAK,WAAW,MAAM,EAAG,CAClC,IAAME,EAAMC,EAAI,WAAWH,EAAK,UAAU,CAAC,CAAC,EAC5CD,EAAW,KAAK,CACd,IAAKG,EACL,eAAgBN,EAAQ,oBAAoBM,CAAG,CACjD,CAAC,CACH,SAAWF,EAAK,WAAW,gBAAgB,EACzC,QAASI,EAAI,EAAGA,EAAIH,EAAW,OAAQG,IACrCN,EAAc,KAAK,SAASG,EAAWG,EAAE,CAAC,EAGhD,CAEA,IAAMC,EAA+B,CACnC,SAAU,IAAI,MAAMP,EAAc,MAAM,CAC1C,EACMQ,EAA+B,CAAC,EAClCC,EAAM,EACVD,EAAmB,KAAK,CAAC,EACzB,IAAME,EAAWL,EAAI,WAAW,EAAE,EAC5BM,EAAWb,EAAQ,uBAAuB,EAChD,QAASc,EAAI,EAAGA,EAAIZ,EAAc,OAAQY,IACxCH,GAAOT,EAAcY,GACrBJ,EAAmB,KAAKC,CAAG,EAC3BR,EAAW,OAAOQ,EAAM,EAAG,EAAG,CAAE,IAAKC,EAAU,eAAgBC,CAAS,CAAC,EAE3E,GAAIV,EAAW,SAAWQ,EACxB,MAAM,MACJ,qBAAqBA,EAAMT,EAAc,uBACvCC,EAAW,OAASD,EAAc,QAEtC,EAEF,IAAMa,EAA6C,CAAC,EACpD,QAAWC,KAAahB,EAAQ,WAAW,OAAQ,CACjD,IAAMiB,EAAkBjB,EAAQ,WAAW,OAAOgB,GAClDD,EAAgBC,GAAa,IAAI,MAAMC,EAAgB,SAAS,EAAE,KAChE,EACF,CACF,CACA,QAASH,EAAIZ,EAAc,OAAS,EAAGY,GAAK,EAAGA,IAAK,CAClD,IAAMI,EAAkC,CAAC,EACzC,QAASV,EAAIE,EAAmBI,GAAIN,EAAIE,EAAmBI,EAAI,GAAIN,IAAK,CACtE,IAAMW,EAAiBhB,EAAWK,GAAG,eACrC,QAAWQ,KAAahB,EAAQ,WAAW,OAAQ,CACjD,IAAMiB,EAAkBjB,EAAQ,WAAW,OAAOgB,GAClD,QAASI,EAAM,EAAGA,EAAMH,EAAgB,UAAWG,KAE/CD,EAAe,mBAAmBH,GAAW,YAAYI,KACvDA,GACFD,EAAe,mBAAmBH,GAAW,YAAYI,KAAS,KAE7DL,EAAgBC,GAAWI,KAC9BF,EAAc,KAAK,CAAE,UAAWF,EAAW,eAAgBI,CAAI,CAAC,EAChEL,EAAgBC,GAAWI,GAAO,IAI1C,CACF,CACA,IAAMC,EAAoC,CAAC,EAC3C,QAASb,EAAIE,EAAmBI,GAAIN,EAAIE,EAAmBI,EAAI,GAAIN,IAAK,CACtE,IAAMW,EAAiBhB,EAAWK,GAAG,eAAe,OAAO,EACvDc,EAAM,GACV,QAASC,EAAI,EAAGA,EAAIL,EAAc,OAAQK,IAAK,CAC7C,IAAMC,EAAMN,EAAcK,GAC1BD,EAAM,GAAGA,KACPH,EAAe,mBAAmBK,EAAI,WAAW,YAC/CA,EAAI,mBAGNL,EAAe,mBAAmBK,EAAI,WAAW,YAC/CA,EAAI,iBAGV,CACAH,EAAOC,GAAOnB,EAAWK,GACzBL,EAAWK,GAAG,IAAML,EAAWK,GAAG,IAAI,OAAO,EAC7CL,EAAWK,GAAG,eAAiBL,EAAWK,GAAG,eAAe,OAAO,CACrE,CACAC,EAAc,SAASK,GAAK,CAC1B,cAAeI,EACf,OAAQG,CACV,CACF,CACA,OAAOZ,CACT",
  "names": ["parseSGS", "kpuzzle", "sgs", "subgroupSizes", "sgsActions", "line", "lineTokens", "alg", "Alg", "j", "sgsCachedData", "subgroupAlgOffsets", "sum", "emptyAlg", "identity", "i", "processedPieces", "orbitName", "orbitDefinition", "pieceOrdering", "transformation", "idx", "lookup", "key", "k", "loc"]
}
