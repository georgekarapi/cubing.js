{
  "version": 3,
  "sources": ["../../../../../src/sites/experiments.cubing.net/cubing.js/vr/vr-input.ts"],
  "sourcesContent": ["import {\n  AdditiveBlending,\n  BufferGeometry,\n  Float32BufferAttribute,\n  Group,\n  Line,\n  LineBasicMaterial,\n  Vector3,\n  WebGLRenderer,\n} from \"three\";\n\nexport enum Status {\n  Untargeted,\n  Targeted,\n  Pressed,\n}\n\nconst NUM_CONTROLLERS = 2;\n\nexport enum OculusButton {\n  Trackpad = 0,\n  Trigger = 1,\n  Grip = 2,\n  XorA = 3,\n  YorB = 4,\n}\n\nexport const controllerDirection: Vector3 = new Vector3(0, 0, -1);\n\nconst geometry = new BufferGeometry();\ngeometry.setAttribute(\n  \"position\",\n  new Float32BufferAttribute(\n    [\n      0,\n      0,\n      0,\n      controllerDirection.x,\n      controllerDirection.y,\n      controllerDirection.z,\n    ],\n    3,\n  ),\n);\ngeometry.setAttribute(\n  \"color\",\n  new Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3),\n);\n\nconst material = new LineBasicMaterial({\n  blending: AdditiveBlending,\n  linewidth: 10,\n  transparent: true,\n  opacity: 0.5,\n});\n\nexport enum ButtonGrouping {\n  All = \"all\",\n  Any = \"any\",\n  Single = \"single\",\n  None = \"none\",\n}\n\nexport type ButtonListenerCallback = () => void;\n\nexport interface ButtonSpec {\n  controllerIdx: number;\n  buttonIdx: number;\n  invert?: boolean;\n}\n\nclass ButtonListener {\n  // TODO: Calculate if the initial status is actually active.\n  private activeLastTime: boolean = false;\n  constructor(\n    private grouping: ButtonGrouping,\n    private buttonSpecs: ButtonSpec[],\n    private activatedCallback: ButtonListenerCallback,\n    private continuedActiveCallback?: ButtonListenerCallback,\n    private deactivatedCallback?: ButtonListenerCallback,\n  ) {}\n\n  public update(buttonStates: ButtonStates): void {\n    const active = this.currentlyActive(buttonStates);\n    if (active) {\n      if (!this.activeLastTime) {\n        this.activatedCallback();\n      } else {\n        if (this.continuedActiveCallback) {\n          this.continuedActiveCallback();\n        }\n      }\n    }\n    if (this.activeLastTime && !active && this.deactivatedCallback) {\n      this.deactivatedCallback();\n    }\n    this.activeLastTime = active;\n  }\n\n  private currentlyActive(buttonStates: ButtonStates): boolean {\n    switch (this.grouping) {\n      case ButtonGrouping.All: {\n        return this.numberPressed(buttonStates) === this.buttonSpecs.length;\n      }\n      case ButtonGrouping.Any: {\n        return this.numberPressed(buttonStates, true) > 0;\n      }\n      case ButtonGrouping.Single: {\n        return this.numberPressed(buttonStates) === 1;\n      }\n      case ButtonGrouping.None: {\n        return this.numberPressed(buttonStates, true) === 0;\n      }\n      default:\n        throw new Error(\"Unknown grouping\");\n    }\n  }\n\n  // Short-circuit: return count of 1 if count is > 0.\n  // TODO: Is the small performance gain from short-circuiting worth the extra code?\n  private numberPressed(\n    buttonStates: ButtonStates,\n    shortCircuit: boolean = false,\n  ): number {\n    let count = 0;\n    for (const button of this.buttonSpecs) {\n      if (this.isButtonPressed(buttonStates, button)) {\n        if (shortCircuit) {\n          return 1;\n        }\n        count++;\n      }\n    }\n    return count;\n  }\n\n  private isButtonPressed(\n    buttonStates: ButtonStates,\n    buttonSpec: ButtonSpec,\n  ): boolean {\n    const controllerStates = buttonStates[buttonSpec.controllerIdx] || [];\n    // Undefined (== missing) means \"not pressed\";\n    return !buttonSpec.invert === !!controllerStates[buttonSpec.buttonIdx]; // TODO\n  }\n}\n\ninterface ButtonStates {\n  [idx: number]: boolean[];\n}\n\nexport class VRInput {\n  public controllers: Group[] = [];\n  private buttonListeners: ButtonListener[] = [];\n  constructor(renderer: WebGLRenderer) {\n    for (let i = 0; i < NUM_CONTROLLERS; i++) {\n      const controller = renderer.xr.getController(i);\n      controller.add(new Line(geometry, material));\n      this.controllers.push(controller);\n    }\n  }\n\n  // Needs to be called in the animation loop when input needs to be proceessed.\n  // Note: calling this multiple times in a loop cycle may cause unexpected results.\n  public update(): void {\n    const gamepads = navigator.getGamepads();\n    const buttonStates: ButtonStates = {};\n\n    // // TODO: is it more performant if we don't read all gamepads/button states, but only the ones we're listening for?\n    for (let i = 0; gamepads.length; i++) {\n      const gamepad = gamepads[i] || { buttons: [] };\n      buttonStates[i] = [];\n      const buttons = gamepad.buttons || [];\n      for (const button of buttons) {\n        buttonStates[i].push(button.pressed);\n      }\n    }\n\n    for (const buttonListener of this.buttonListeners) {\n      buttonListener.update(buttonStates);\n    }\n  }\n\n  public addButtonListener(\n    grouping: ButtonGrouping,\n    buttonSpecs: ButtonSpec[],\n    activatedCallback: ButtonListenerCallback,\n    continuedActiveCallback?: ButtonListenerCallback,\n    deactivatedCallback?: ButtonListenerCallback,\n  ): void {\n    this.buttonListeners.push(\n      new ButtonListener(\n        grouping,\n        buttonSpecs,\n        activatedCallback,\n        continuedActiveCallback,\n        deactivatedCallback,\n      ),\n    );\n  }\n\n  public addSingleButtonListener(\n    buttonSpec: ButtonSpec,\n    activatedCallback: ButtonListenerCallback,\n    continuedActiveCallback?: ButtonListenerCallback,\n    deactivatedCallback?: ButtonListenerCallback,\n  ): void {\n    this.addButtonListener(\n      ButtonGrouping.All,\n      [buttonSpec],\n      activatedCallback,\n      continuedActiveCallback,\n      deactivatedCallback,\n    );\n  }\n}\n"],
  "mappings": "yGAWO,IAAKA,OACVA,IAAA,2BACAA,IAAA,uBACAA,IAAA,qBAHUA,OAAA,IAMNC,EAAkB,EAEZC,OACVA,IAAA,SAAW,GAAX,WACAA,IAAA,QAAU,GAAV,UACAA,IAAA,KAAO,GAAP,OACAA,IAAA,KAAO,GAAP,OACAA,IAAA,KAAO,GAAP,OALUA,OAAA,IAQCC,EAA+B,IAAIC,EAAQ,EAAG,EAAG,EAAE,EAE1DC,EAAW,IAAIC,EACrBD,EAAS,aACP,WACA,IAAIE,EACF,CACE,EACA,EACA,EACAJ,EAAoB,EACpBA,EAAoB,EACpBA,EAAoB,CACtB,EACA,CACF,CACF,EACAE,EAAS,aACP,QACA,IAAIE,EAAuB,CAAC,GAAK,GAAK,GAAK,EAAG,EAAG,CAAC,EAAG,CAAC,CACxD,EAEA,IAAMC,EAAW,IAAIC,EAAkB,CACrC,SAAUC,EACV,UAAW,GACX,YAAa,GACb,QAAS,EACX,CAAC,EAEWC,OACVA,EAAA,IAAM,MACNA,EAAA,IAAM,MACNA,EAAA,OAAS,SACTA,EAAA,KAAO,OAJGA,OAAA,IAeNC,EAAN,KAAqB,CAGnB,YACUC,EACAC,EACAC,EACAC,EACAC,EACR,CALQ,cAAAJ,EACA,iBAAAC,EACA,uBAAAC,EACA,6BAAAC,EACA,yBAAAC,EANV,KAAQ,eAA0B,EAO/B,CAEI,OAAOC,EAAkC,CAC9C,IAAMC,EAAS,KAAK,gBAAgBD,CAAY,EAC5CC,IACG,KAAK,eAGJ,KAAK,yBACP,KAAK,wBAAwB,EAH/B,KAAK,kBAAkB,GAOvB,KAAK,gBAAkB,CAACA,GAAU,KAAK,qBACzC,KAAK,oBAAoB,EAE3B,KAAK,eAAiBA,CACxB,CAEQ,gBAAgBD,EAAqC,CAC3D,OAAQ,KAAK,SAAU,CACrB,IAAK,MACH,OAAO,KAAK,cAAcA,CAAY,IAAM,KAAK,YAAY,OAE/D,IAAK,MACH,OAAO,KAAK,cAAcA,EAAc,EAAI,EAAI,EAElD,IAAK,SACH,OAAO,KAAK,cAAcA,CAAY,IAAM,EAE9C,IAAK,OACH,OAAO,KAAK,cAAcA,EAAc,EAAI,IAAM,EAEpD,QACE,MAAM,IAAI,MAAM,kBAAkB,CACtC,CACF,CAIQ,cACNA,EACAE,EAAwB,GAChB,CACR,IAAIC,EAAQ,EACZ,QAAWC,KAAU,KAAK,YACxB,GAAI,KAAK,gBAAgBJ,EAAcI,CAAM,EAAG,CAC9C,GAAIF,EACF,MAAO,GAETC,GACF,CAEF,OAAOA,CACT,CAEQ,gBACNH,EACAK,EACS,CACT,IAAMC,EAAmBN,EAAaK,EAAW,gBAAkB,CAAC,EAEpE,MAAO,CAACA,EAAW,QAAW,CAAC,CAACC,EAAiBD,EAAW,UAC9D,CACF,EAMaE,EAAN,KAAc,CAGnB,YAAYC,EAAyB,CAFrC,KAAO,YAAuB,CAAC,EAC/B,KAAQ,gBAAoC,CAAC,EAE3C,QAASC,EAAI,EAAGA,EAAI1B,EAAiB0B,IAAK,CACxC,IAAMC,EAAaF,EAAS,GAAG,cAAcC,CAAC,EAC9CC,EAAW,IAAI,IAAIC,EAAKxB,EAAUG,CAAQ,CAAC,EAC3C,KAAK,YAAY,KAAKoB,CAAU,CAClC,CACF,CAIO,QAAe,CACpB,IAAME,EAAW,UAAU,YAAY,EACjCZ,EAA6B,CAAC,EAGpC,QAASS,EAAI,EAAGG,EAAS,OAAQH,IAAK,CACpC,IAAMI,EAAUD,EAASH,IAAM,CAAE,QAAS,CAAC,CAAE,EAC7CT,EAAaS,GAAK,CAAC,EACnB,IAAMK,EAAUD,EAAQ,SAAW,CAAC,EACpC,QAAWT,KAAUU,EACnBd,EAAaS,GAAG,KAAKL,EAAO,OAAO,CAEvC,CAEA,QAAWW,KAAkB,KAAK,gBAChCA,EAAe,OAAOf,CAAY,CAEtC,CAEO,kBACLL,EACAC,EACAC,EACAC,EACAC,EACM,CACN,KAAK,gBAAgB,KACnB,IAAIL,EACFC,EACAC,EACAC,EACAC,EACAC,CACF,CACF,CACF,CAEO,wBACLM,EACAR,EACAC,EACAC,EACM,CACN,KAAK,kBACH,MACA,CAACM,CAAU,EACXR,EACAC,EACAC,CACF,CACF,CACF",
  "names": ["Status", "NUM_CONTROLLERS", "OculusButton", "controllerDirection", "Vector3", "geometry", "BufferGeometry", "Float32BufferAttribute", "material", "LineBasicMaterial", "AdditiveBlending", "ButtonGrouping", "ButtonListener", "grouping", "buttonSpecs", "activatedCallback", "continuedActiveCallback", "deactivatedCallback", "buttonStates", "active", "shortCircuit", "count", "button", "buttonSpec", "controllerStates", "VRInput", "renderer", "i", "controller", "Line", "gamepads", "gamepad", "buttons", "buttonListener"]
}
