{
  "version": 3,
  "sources": ["../../../../src/cubing/protocol/binary/orbit-indexing.ts", "../../../../src/cubing/protocol/binary/binary3x3x3.ts"],
  "sourcesContent": ["export function identityPermutation(numElems: number): number[] {\n  const arr = new Array<number>(numElems);\n  for (let i = 0; i < numElems; i++) {\n    arr[i] = i;\n  }\n  return arr;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function orientationsToMask(\n  radix: number,\n  orientations: number[],\n): number {\n  let val = 0;\n  for (const orientation of orientations) {\n    val *= radix;\n    val += orientation;\n  }\n  return val;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function maskToOrientations(\n  radix: number,\n  numElems: number,\n  mask: number,\n): number[] {\n  const arr = [];\n  while (mask > 0) {\n    arr.push(mask % radix);\n    mask = Math.floor(mask / radix);\n  }\n  return new Array<number>(numElems - arr.length).fill(0).concat(arr.reverse());\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function permutationToLex(permutation: number[]): number {\n  const n = permutation.length;\n  let lexicographicIdx = 0;\n  for (let i = 0; i < n - 1; i++) {\n    lexicographicIdx = lexicographicIdx * (n - i);\n    for (let j = i + 1; j < n; j++) {\n      if (permutation[i] > permutation[j]) {\n        lexicographicIdx += 1;\n      }\n    }\n  }\n  return lexicographicIdx;\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function lexToPermutation(\n  numPieces: number,\n  lexicographicIdx: number,\n): number[] {\n  const permutation: number[] = new Array(numPieces);\n  permutation[numPieces - 1] = 0;\n  for (let i = numPieces - 2; i >= 0; i--) {\n    permutation[i] = lexicographicIdx % (numPieces - i);\n    lexicographicIdx = Math.floor(lexicographicIdx / (numPieces - i));\n    for (let j = i + 1; j < numPieces; j++) {\n      if (permutation[j] >= permutation[i]) {\n        permutation[j] = permutation[j] + 1;\n      }\n    }\n  }\n  return permutation;\n}\n", "import { KState } from \"../../kpuzzle\";\nimport {\n  experimental3x3x3KPuzzle,\n  experimentalNormalize3x3x3Orientation,\n  experimentalPuzzleOrientation3x3x3Cache,\n  experimentalPuzzleOrientation3x3x3Idx,\n} from \"../../puzzles/cubing-private\";\nimport {\n  identityPermutation,\n  lexToPermutation,\n  maskToOrientations,\n  orientationsToMask,\n  permutationToLex,\n} from \"./orbit-indexing\";\n\n// TODO: combine with `orientPuzzle`?\nexport function reorientPuzzle(\n  state: KState,\n  idxU: number,\n  idxL: number,\n): KState {\n  return state.applyTransformation(\n    experimentalPuzzleOrientation3x3x3Cache()[idxU][idxL].invert(),\n  );\n}\n\ntype Binary3x3x3State = ArrayBuffer;\n\n// Bit lengths of the encoded components, in order.\nconst BIT_LENGTHS = [29, 12, 16, 13, 3, 2, 1, 12];\n\n// These fields are sorted by the order in which they appear in the binary format.\nexport interface Binary3x3x3Components {\n  epLex: number; // 29 bits, edge permutation\n  eoMask: number; // 12 bits, edge orientation\n  cpLex: number; // 16 bits, corner permutation\n  coMask: number; // 13 bits, corner orientation\n  poIdxU: number; // 3 bits, puzzle orientation (U face)\n  poIdxL: number; // 2 bits, puzzle orientation (L face)\n  moSupport: number; // 1 bit, center orientation support\n  moMask: number; // 12 bits, center orientation\n}\n\n// There are various clever ways to do this, but this is simple and efficient.\nfunction arraySum(arr: number[]): number {\n  let total = 0;\n  for (const entry of arr) {\n    total += entry;\n  }\n  return total;\n}\n\n// Due to limitations in JS bit operations, this is unsafe if any of the bit lengths span across the contents of more than 4 bytes.\n// - Safe: [8, 32]\n// - Unsafe: [4, 32, 4]\n// - Unsafe: [40, 4]\nfunction splitBinary(bitLengths: number[], buffy: ArrayBuffer): number[] {\n  const u8buffy = new Uint8Array(buffy);\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  const values: number[] = [];\n  for (const bitLength of bitLengths) {\n    while (bits < bitLength) {\n      accum = (accum << 8) | u8buffy[at++];\n      bits += 8;\n    }\n    values.push((accum >> (bits - bitLength)) & ((1 << bitLength) - 1));\n    bits -= bitLength;\n  }\n  return values;\n}\n\n// See above for safety notes.\nfunction concatBinary(bitLengths: number[], values: number[]): ArrayBuffer {\n  const buffy = new Uint8Array(Math.ceil(arraySum(bitLengths) / 8));\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  for (let i = 0; i < bitLengths.length; i++) {\n    accum = (accum << bitLengths[i]) | values[i];\n    bits += bitLengths[i];\n    while (bits >= 8) {\n      buffy[at++] = accum >> (bits - 8);\n      bits -= 8;\n    }\n  }\n  if (bits > 0) {\n    buffy[at++] = accum << (8 - bits);\n  }\n  return buffy;\n}\n\n// 0x111 (for idxU) means \"not supported\"\nfunction supportsPuzzleOrientation(components: Binary3x3x3Components): boolean {\n  return components.poIdxU !== 7;\n}\n\nexport function reid3x3x3ToBinaryComponents(\n  state: KState,\n): Binary3x3x3Components {\n  const normedState = experimentalNormalize3x3x3Orientation(state);\n\n  const epLex = permutationToLex(normedState.stateData[\"EDGES\"].pieces);\n  const eoMask = orientationsToMask(\n    2,\n    normedState.stateData[\"EDGES\"].orientation,\n  );\n  const cpLex = permutationToLex(normedState.stateData[\"CORNERS\"].pieces);\n  const coMask = orientationsToMask(\n    3,\n    normedState.stateData[\"CORNERS\"].orientation,\n  );\n  const [poIdxU, poIdxL] = experimentalPuzzleOrientation3x3x3Idx(state);\n  const moSupport = 1; // Required for now.\n  const moMask = orientationsToMask(\n    4,\n    normedState.stateData[\"CENTERS\"].orientation,\n  );\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\nexport function binaryComponentsToTwizzleBinary(\n  components: Binary3x3x3Components,\n): Binary3x3x3State {\n  const { epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask } =\n    components;\n\n  return concatBinary(BIT_LENGTHS, [\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  ]);\n}\n\n/** @category Binary 3x3x3 Format */\nexport function reid3x3x3ToTwizzleBinary(state: KState): Binary3x3x3State {\n  const components: Binary3x3x3Components = reid3x3x3ToBinaryComponents(state);\n  return binaryComponentsToTwizzleBinary(components);\n}\n\n/** @category Binary 3x3x3 Format */\nexport function twizzleBinaryToBinaryComponents(\n  buffer: ArrayBuffer,\n): Binary3x3x3Components {\n  const [epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask] =\n    splitBinary(BIT_LENGTHS, buffer);\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\n/** @category Binary 3x3x3 Format */\nexport function binaryComponentsToReid3x3x3(\n  components: Binary3x3x3Components,\n): KState {\n  if (components.moSupport !== 1) {\n    throw new Error(\"Must support center orientation.\");\n  }\n\n  const normedState = new KState(experimental3x3x3KPuzzle, {\n    EDGES: {\n      pieces: lexToPermutation(12, components.epLex),\n      orientation: maskToOrientations(2, 12, components.eoMask),\n    },\n    CORNERS: {\n      pieces: lexToPermutation(8, components.cpLex),\n      orientation: maskToOrientations(3, 8, components.coMask),\n    },\n    CENTERS: {\n      pieces: identityPermutation(6),\n      orientation: maskToOrientations(4, 6, components.moMask),\n    },\n  });\n\n  if (!supportsPuzzleOrientation(components)) {\n    return normedState;\n  }\n\n  return reorientPuzzle(normedState, components.poIdxU, components.poIdxL);\n}\n\n// Returns a list of error string.\n// An empty list means validation success.\nfunction validateComponents(components: Binary3x3x3Components): string[] {\n  const errors = [];\n  if (components.epLex < 0 || components.epLex >= 479001600) {\n    errors.push(`epLex (${components.epLex}) out of range`);\n  }\n  if (components.cpLex < 0 || components.cpLex >= 40320) {\n    errors.push(`cpLex (${components.cpLex}) out of range`);\n  }\n  if (components.coMask < 0 || components.coMask >= 6561) {\n    errors.push(`coMask (${components.coMask}) out of range`);\n  }\n  if (components.poIdxU < 0 || components.poIdxU >= 6) {\n    // 0x111 (for idxU) means \"not supported\"\n    if (supportsPuzzleOrientation(components)) {\n      errors.push(`poIdxU (${components.poIdxU}) out of range`);\n    }\n  }\n  // The following cannot be (f decoded from binary properl) out of rangey.\n  if (components.eoMask < 0 || components.eoMask >= 4096) {\n    errors.push(`eoMask (${components.eoMask}) out of range`);\n  }\n  if (components.moMask < 0 || components.moMask >= 4096) {\n    errors.push(`moMask (${components.moMask}) out of range`);\n  }\n  if (components.poIdxL < 0 || components.poIdxL >= 4) {\n    errors.push(`poIdxL (${components.poIdxL}) out of range`);\n  }\n  if (components.moSupport < 0 || components.moSupport >= 2) {\n    errors.push(`moSupport (${components.moSupport}) out of range`);\n  }\n  return errors;\n}\n\n/** @category Binary 3x3x3 Format */\nexport function twizzleBinaryToReid3x3x3(buffy: ArrayBuffer): KState {\n  const components = twizzleBinaryToBinaryComponents(buffy);\n  const errors = validateComponents(components);\n  if (errors.length !== 0) {\n    throw new Error(`Invalid binary state components: ${errors.join(\", \")}`);\n  }\n  return binaryComponentsToReid3x3x3(components);\n}\n"],
  "mappings": "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",
  "names": ["identityPermutation", "numElems", "arr", "i", "orientationsToMask", "radix", "orientations", "val", "orientation", "maskToOrientations", "mask", "permutationToLex", "permutation", "n", "lexicographicIdx", "j", "lexToPermutation", "numPieces", "reorientPuzzle", "state", "idxU", "idxL", "puzzleOrientation3x3x3Cache", "BIT_LENGTHS", "arraySum", "arr", "total", "entry", "splitBinary", "bitLengths", "buffy", "u8buffy", "at", "bits", "accum", "values", "bitLength", "concatBinary", "supportsPuzzleOrientation", "components", "reid3x3x3ToBinaryComponents", "normedState", "normalize3x3x3Orientation", "epLex", "permutationToLex", "eoMask", "orientationsToMask", "cpLex", "coMask", "poIdxU", "poIdxL", "puzzleOrientation3x3x3Idx", "moSupport", "moMask", "binaryComponentsToTwizzleBinary", "reid3x3x3ToTwizzleBinary", "twizzleBinaryToBinaryComponents", "buffer", "binaryComponentsToReid3x3x3", "KState", "experimental3x3x3KPuzzle", "lexToPermutation", "maskToOrientations", "identityPermutation", "validateComponents", "errors", "twizzleBinaryToReid3x3x3"]
}
