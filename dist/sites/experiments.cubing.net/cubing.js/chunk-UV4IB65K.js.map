{
  "version": 3,
  "sources": ["../../../../src/sites/experiments.cubing.net/cubing.js/3x3x3-formats/convert.ts"],
  "sourcesContent": ["import type { KStateOrbitData } from \"../../../../cubing/kpuzzle/KPuzzleDefinition\";\nimport { KState } from \"../../../../cubing/kpuzzle\";\nimport { experimental3x3x3KPuzzle } from \"../../../../cubing/puzzles/cubing-private\";\n\nexport function stateToString(state: KState): string {\n  return JSON.stringify(state.stateData, null, \"  \")\n    .replace(/\\n +(\\d+),/g, \"$1, \")\n    .replace(/\\n +(\\d+)\\n +/g, \"$1\");\n}\n\nconst pieceNames: Record<string, string[]> = {\n  EDGES: \"UF UR UB UL DF DR DB DL FR FL BR BL\".split(\" \"),\n  CORNERS: \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \"),\n  CENTERS: \"ULFRBD\".split(\"\"),\n};\n\ninterface PieceInfo {\n  piece: number;\n  orientation: number;\n}\n\nfunction rotateLeft(s: string, i: number): string {\n  return s.slice(i) + s.slice(0, i);\n}\n\nconst pieceMap: { [s: string]: PieceInfo } = {};\n// TODO: Condense the for loops.\n\nconst orbits = Object.keys(experimental3x3x3KPuzzle.definition.orbits);\nfor (const orbit of orbits) {\n  pieceNames[orbit].forEach((piece, idx) => {\n    const numOri =\n      orbit === \"CENTERS\"\n        ? 1\n        : experimental3x3x3KPuzzle.definition.orbits[orbit].numOrientations;\n    for (let i = 0; i < numOri; i++) {\n      const name = rotateLeft(piece, i);\n      pieceMap[name] = { piece: idx, orientation: i };\n      if (numOri === 3) {\n        const altName = name[0] + name[2] + name[1];\n        pieceMap[altName] = { piece: idx, orientation: i };\n      }\n    }\n  });\n}\n\nexport function kpuzzleToReidString(state: KState): string {\n  const pieces: string[] = [];\n\n  const addOrbit = (orbitName: string): void => {\n    for (let i = 0; i < state.stateData[orbitName].pieces.length; i++) {\n      pieces.push(\n        rotateLeft(\n          pieceNames[orbitName][state.stateData[orbitName].pieces[i]],\n          state.stateData[orbitName].orientation[i],\n        ),\n      );\n    }\n  };\n\n  for (const orbit of orbits) {\n    addOrbit(orbit);\n  }\n\n  return pieces.join(\" \");\n}\n\nconst reidStringStickerIdx = Array.prototype.concat.apply(Array.prototype, [\n  [44, 6, 40, 9, 68, 3, 48, 0, 36], // end of U\n  [46, 10, 49, 34, 70, 28, 61, 22, 58], // end of L\n  [50, 1, 37, 27, 72, 24, 57, 13, 54], // end of F\n  [38, 4, 41, 25, 74, 31, 53, 16, 66], // end of R\n  [42, 7, 45, 30, 76, 33, 65, 19, 62], // end of B\n  [56, 12, 52, 21, 78, 15, 60, 18, 64], // end of D\n]);\n\nexport function reidStringToStickers(s: string): number[] {\n  const arr: number[] = [];\n  for (let i = 0; i < reidStringStickerIdx.length; i++) {\n    const stickerColorFaceName = s[reidStringStickerIdx[i]];\n    const stickerColorIdx = pieceNames[\"CENTERS\"].indexOf(stickerColorFaceName);\n    arr.push(stickerColorIdx);\n  }\n  return arr;\n}\n\nexport function stickersToReidString(stickers: number[]): string {\n  const reidStringChars = new Array(79).fill(\" \");\n\n  for (let i = 0; i < reidStringStickerIdx.length; i++) {\n    const stickerColorIdx = stickers[i];\n    reidStringChars[reidStringStickerIdx[i]] =\n      pieceNames[\"CENTERS\"][stickerColorIdx];\n  }\n  return reidStringChars.join(\"\");\n}\n\nexport function kpuzzleToStickers(state: KState): number[] {\n  return reidStringToStickers(kpuzzleToReidString(state));\n}\n\nexport function stickersToKPuzzle(stickers: number[]): KState {\n  return reidStringToKState(stickersToReidString(stickers));\n}\n\nexport function reidStringToKState(s: string): KState {\n  const pieces = s.split(\" \");\n\n  const orbit = (pieces: string[]): KStateOrbitData => {\n    const orbitState: KStateOrbitData = {\n      pieces: [],\n      orientation: [],\n    };\n    for (const piece of pieces) {\n      orbitState.pieces.push(pieceMap[piece].piece);\n      orbitState.orientation.push(pieceMap[piece].orientation);\n    }\n    return orbitState;\n  };\n\n  const stateData = {\n    EDGES: orbit(pieces.slice(0, 12)),\n    CORNERS: orbit(pieces.slice(12, 20)),\n    CENTERS: orbit(pieces.slice(20, 26)),\n  };\n  return new KState(experimental3x3x3KPuzzle, stateData);\n}\n"],
  "mappings": "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",
  "names": ["stateToString", "state", "pieceNames", "rotateLeft", "s", "i", "pieceMap", "orbits", "experimental3x3x3KPuzzle", "orbit", "piece", "idx", "numOri", "name", "altName", "kpuzzleToReidString", "pieces", "addOrbit", "orbitName", "reidStringStickerIdx", "reidStringToStickers", "arr", "stickerColorFaceName", "stickerColorIdx", "stickersToReidString", "stickers", "reidStringChars", "kpuzzleToStickers", "stickersToKPuzzle", "reidStringToKState", "orbitState", "stateData", "KState"]
}
